(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{"./src/blogs/Generator.md":function(n,r){n.exports="# Generator in ES6\r\n## 序\r\nGenerator不同于一般的函数，它可以在执行过程中被暂停然后在稍后的任意时刻恢复执行，并且在过程中可以与外界双向传递数据\r\n\r\n## 如何写一个最简单的Generator\r\n```js\r\nfunction *foo() {\r\n\treturn 'hello'\r\n}\r\n\r\nconst it = foo()\r\nit.next() // { value: 'hello', done: true}\r\n```\r\n与普通函数的不同的是调用一个Generator并不会立即执行函数体，而是返回一个Iterator来控制这个Generator的执行\r\n\r\n## 如何写一个有意义的Generator\r\n上例中的Generator并没有特殊的意义，因为它中间并没有暂停的步骤，若想让一个Generator可以中断需要使用ES6新引入的关键字`yield`\r\n```js\r\nfunction *foo() {\r\n\tconst a = yield 'hello'\r\n\tconsole.log(a)\r\n\t\r\n\tconst b = yield 'world'\r\n\tconsole.log(b)\r\n\t\r\n\treturn 'finish'\r\n}\r\n```\r\n下面来依次执行上述Generator，看看每一步的结果\r\n```js\r\nconst it = foo() // 获得Iterator\r\nit.next('step 1')\r\n// {value: \"hello\", done: false}\r\n```\r\n初次执行，代码会停在`const a = yield 'hello'`处，hello作为返回值被抛到函数外\r\n\r\n需要注意的是这里通过`next()`传入的值不会被函数接受，因为**yield**将自身替换为外部传入值的时机是在代码恢复执行时\r\n```js\r\nit.next('step 2')\r\n// 'step 2'\r\n// {value: \"world\", done: false}\r\n```\r\n第二次执行，代码会停在`const b = yield 'world'`处，我们在`next()`中传入的`'step2'`被赋值给变量`a`\r\n\r\n可以看做`yield 'hello'`被替换成了`'step2'`，world作为返回值被抛出\r\n```js\r\nit.next('step 3')\r\n// 'step 3'\r\n// {value: \"finish\", done: true}\r\n```\r\n最后一次执行，`'step3'`被赋值给变量`b`，Generator执行完毕，finish作为返回值被抛出\r\n"},"./src/blogs/GulpPlugin.md":function(n,r){n.exports='# 如何编写一个自己的GulpPlugin\r\n\r\n```\r\nconst through = require("through-gulp"),\r\n\tfs = require("fs")\r\n\r\nfunction myPlugin() {\r\n\treturn through(function(file, encoding, callback) {\r\n\t\tlet result, origin\r\n\t\t\r\n\t\t// 传入的文件为空\r\n\t\tif (file.isNull()) {\r\n\t\t\tthrow "Please Check Files!"\r\n\t\t}\r\n\r\n\t\t// buffer对象可以直接操作\r\n\t\tif (file.isBuffer()) {\r\n\t\t\t//拿到单个文件buffer             \r\n\t\t\tfile.contents = new Buffer(file.contents.toString("utf-8"),"utf-8")\r\n\t\t}\r\n\t\t \r\n\t\t// stream流是不能操作的,可以通过fs.readFileSync\r\n\t\tif (file.isStream()) {\r\n\t\t\t// 同步读取\r\n\t\t\tfile.contents = new Buffer(s.readFileSync(file.path).toString("utf-8"),"utf-8")\r\n\t\t}\r\n\r\n\t\torigin = file.contents.toString("utf-8") // 转化为字符串\r\n\t\tresult = doYourPluginWork(origin) // 处理源文件 实现插件的逻辑\r\n\t\tfile.contents = new Buffer(result) // 将源文件的内容替换为插件处理完之后的内容\r\n\r\n\t\tthis.push(file)\r\n\t\tcallback() // 声明文件已处理完毕\r\n\t}, function(callback) {\r\n\t\tcallback() // 声明文件已处理完毕\r\n\t})\r\n}\r\n\r\nmodule.exports = myPlugin\r\n```\r\n'},"./src/blogs/Iterator.md":function(n,r){n.exports="# Iterator in ES6\r\n## Iterator 与 Iterable\r\nIterator可以看做一个拥有特定格式的对象，可供ES6提供的遍历->`for of`和解构->`...`等操作消费，并按顺序依次产出结果，样例如下\r\n```js\r\n// 除了以下俩个值外也可以额外返回更多的自定义属性\r\nconst IteratorResult = {\r\n\tvalue: ..., // 每次迭代产出的真实值\r\n\tdone: ..., // true|false true代表迭代结束 与true相对应的value一般建议为undefined\r\n}\r\n\r\nconst Iterator = {\r\n\t// 必须 用于返回每次迭代的结果集\r\n\tnext() { return IteratorResult},\r\n\t// 可选 提前结束迭代时做相应的资源清理操作并返回最后的结果集\r\n\treturn() {},\r\n\t// 可选 抛出异常信息并返回最后的结果集\r\n\tthrow() {}\r\n}\r\n```\r\n而Iterable则是指一个对象实现了Iterable接口(简单来说就是对象上有一个key为Symbol.iterator的方法并且这个方法会生成一个Iterator)\r\n```js\r\nconst Iterable = {\r\n\t[Symbol.iterator]() {return Iterator}\r\n}\r\n```\r\n\r\n## 如何构造一个简单的Iterable对象\r\n```js\r\nlet rand = Math.random()\r\n// 会随机产生一串数字的Iterable对象\r\nconst iterable = {\r\n\t// 必备!!! 这样才能使该对象变为Iterable\r\n\t[Symbol.iterator]() {return this},\r\n\t// 依次去获取数据\r\n\tnext() {\r\n\t\tif (rand > 0.5) {\r\n\t\t\trand = Math.random()\r\n\t\t\treturn {\r\n\t\t\t\tvalue: rand,\r\n\t\t\t\tdone: false\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\tdone: true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n// 该对象可以用for of遍历\r\nfor (let value of iterable) {\r\n\tconsole.log(value)\r\n}\r\n```\r\n\r\n## 如何构造一个完整的Iterable对象\r\n```js\r\n// 该对象可以步进的产生对数据的每一步累加结果\r\nconst stepAccumulator = {\r\n\t[Symbol.iterator]() {\r\n\t\tlet sum = 0\r\n\t\tlet index = 0\r\n\t\tconst data = this.data.slice()\r\n\t\tlet done = false\r\n\t\treturn {\r\n\t\t\t// 使迭代器(Iterator)本身可迭代(Iterable)\r\n\t\t\t[Symbol.iterator]() { return this },\r\n\t\t\tnext() {\r\n\t\t\t\tconst value = sum += data[index]\r\n\t\t\t\tindex++\r\n\t\t\t\tif (index <= data.length && !done) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tvalue,\r\n\t\t\t\t\t\tdone: false\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdone: true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\treturn(v) {\r\n\t\t\t\tconsole.log('abandoned')\r\n\t\t\t\tdone = true\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: v,\r\n\t\t\t\t\tdone: true\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tthrow(e) {\r\n\t\t\t\tconsole.log('error')\r\n\t\t\t\tdone = true\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: e,\r\n\t\t\t\t\tdone: true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tdata: []\r\n}\r\n// 设置数据\r\nstepAccumulator.data = [1, 2, 3]\r\nconsole.log(...stepAccumulator) // 1 3 6\r\n\r\n// 1 3 'abandoned'\r\nfor (let v of stepAccumulator) {\r\n\tconsole.log(v)\r\n\tif (v > 1) break\r\n}\r\n\r\nconst it = stepAccumulator[Symbol.iterator]()\r\nit.next() // { value:1, done: false }\r\nit.throw('!!!') // 'error' { vallue:'!!!', done: true }\r\nit.next() // { done: true }\r\n```\r\n* `return()`和`throw()`都可以通过**Iterator**调用，并且通常来说在调用过后便不应该能通过该迭代器获取到更多的值\r\n* 一般来说**Iterable**对象可以同时生成多个**Iterator**，且相互间的迭代不会互相影响，当然你也可以把迭代器设为单例\r\n* 任何一种取消或者提前终止迭代的行为都会使得**Iterator**自动调用`return()`来处理相关的清理工作\r\n\r\n## ES6自带的Iterable数据结构\r\n包括`String` `Map` `Set` `Array`等\r\n```js\r\nconst str = 'abc'\r\nconst arr = [1, 2, 3]\r\nconst map = new Map()\r\nmap.set('a', 1)\r\nmap.set('b', 2)\r\nfor (let v of str) {\r\n\tconsole.log(v) // 'a' 'b' 'c'\r\n}\r\nfor (let v of arr) {\r\n\tconsole.log(v) // 1 2 3\r\n}\r\nfor (let v of map) {\r\n\tconsole.log(v) // ['a', 1] ['b', 2]\r\n}\r\n```\r\n"},"./src/blogs/Symbol.md":function(n,r){n.exports="# Symbols in ES6\r\n`Symbol`是ES6中(时隔多年)新增的一种**primitive type**，可以把它看做一种自动生成**唯一字符串**的机制，它的真实值被隐藏在代码后且永远无法直接获得\r\n\r\n## 如何生成Symbol\r\n```js\r\n// 最基础的方式\r\nconst a = Symbol()\r\n\r\n// 可以传入一串描述该Symbol用途的字符串作为参数\r\nconst b = Symbol('some description text')\r\n\r\n// 从全局的Symbol库中查询所需的Symbol\r\n// 如果未找到则新建一个并返回\r\n// 这种方式较以上直接构造Symbol的优点在于\r\n// 可以不必在外部作用域中专门维护一个变量用于存储生成的Symbol\r\nconst c = Symbol.for('my Symbol')\r\n\r\n// 由于不管如何Symbol都是全局存在的\r\n// 为了尽量避免可能发生的冲突 可以给Symbol添加相应的前缀\r\nconst d = Symbol.for('prefix.Symbol')\r\n```\r\n\r\n## 如何判断一个值是否为Symbol\r\n```js\r\nconst a = Symbol()\r\n// 推荐方式\r\ntypeof a === 'symbol'// true\r\n\r\n// 其余方式\r\na instanceof Symbol // false\r\nObject(a) instanceof Symbol // true\r\nObject(a).valueOf() === a // true\r\n```\r\n\r\n## 如何获得Symbol的描述字符串\r\n```js\r\nconst a = Symbol('desc a')\r\nconst b = Symbol.for('desc b')\r\n\r\nSymbol.keyFor(a) // undefined\r\nSymbol.keyFor(b) // desc b\r\n\r\na.toString() // Symbol(desc a)\r\nb.toString() // Symbol(desc b)\r\n```\r\n通过上述对比，个人感觉用`Symbol.for()`来生成`Symbol`好像更加合适\r\n\r\n不仅可以避免使用不必要的变量污染作用域，并且能更方便的获得其描述\r\n\r\n## Symbol的用途\r\n借助`Symbol`来实现单例模式\r\n```js\r\nconst Instance = Symbol.for('instance')\r\nfunction singleton() {\r\n\tif (singleton[Instance]) {\r\n\t\treturn singleton[Instance]\r\n\t}\r\n\t\r\n\treturn singleton[Instance] = {}\r\n}\r\nconst a = singleton()\r\nconst b = singleton()\r\na === b // true\r\n```\r\n\r\n如果将上例中的Symbol替换成任意一个不规则字符串（Magic String）对逻辑的实现并无影响\r\n\r\n所以从这个角度看来，Symbol的出现更多的是对代码或者说程序层面上的提升，而不是函数性的提升\r\n\r\n```js\r\nconst o = {\r\n\tfoo: 1,\r\n\t[Symbol.for('bar')]: 2\r\n}\r\nObject.getOwnPropertyNames(o) // ['foo']\r\nObject.getOwnPropertySymbols(o) // [Symbol(for)]\r\nObject.keys(o) // ['foo']\r\nfor (let key in o ){\r\n\tconsole.log(key) // 'foo'\r\n}\r\n```\r\n\r\n可以看到，虽然Symbol作为Object的属性key不会被当作普通的键值被获取\r\n\r\n但是还是有特殊途径来获得，所以并不能试图通过Symbol把Object的部分属性隐藏(作为外部不可访问的私有属性)\r\n\r\n## Built-in Symbols\r\n个人感觉ES6自身提供的Built-in Symbols会是最常见的`Symbol`使用方式，例如`Symbol.iterator`:\r\n```js\r\nconst arr = [1, 2, 3]\r\narr[Symbol.iterator] // native function\r\nconst it = arr[Symbol.iterator]() // 获得数组arr的Iterator\r\n```\r\n值得一提的是这些内部的Symbol并不是像我们自定义的那样注册到全局库中\r\n\r\n而是作为Symbol构造函数的静态属性对外提供\r\n\r\n"},"./src/blogs/WebpackBaseConfig.md":function(n,r){n.exports="# Webpack(v3.8.1)\r\n```\r\nconst path = require('path')\r\nconst webpack = require('webpack')\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\r\nconst pkg = require(path.join(__dirname, 'package.json'))// package.json\r\n\r\n// 定义项目中的一些文件夹路径\r\nconst APP_PATH = path.resolve(__dirname, 'src')\r\n\r\nlet theme = {}\r\n// pkg.theme存的是项目中antd主题文件的路径\r\n// 这里是 ./antd-theme.js\r\nif (pkg.theme && typeof(pkg.theme) === 'string') {\r\n  theme = require(path.resolve(__dirname, pkg.theme))\r\n}\r\n\r\nmodule.exports = {\r\n  entry: path.resolve(APP_PATH, 'index.jsx'),\r\n  // 暂时本地开发环境的不配output好像影响不大\r\n  // 后期遇到问题再配\r\n  resolve: {\r\n    // 配置这个后引用node_modules中的依赖包不用加路径 直接import xx from ('antd')即可\r\n    modules: [\r\n      'node_modules'\r\n    ],\r\n    //后缀 配了这个就可以在import时 import xx from (./test) 而不用 import xx from (./test.jsx)\r\n    extensions: ['.js', '.jsx', '.json', '.scss']\r\n  },\r\n  module: {\r\n    rules: [{\r\n      test: /\\.js|\\.jsx$/,\r\n      use: [\r\n        'babel-loader',\r\n        'eslint-loader'\r\n      ],\r\n      exclude: /node_modules/\r\n    }, {\r\n      test: /\\.css$/,\r\n      use: ['css-loader']\r\n    }, {\r\n      test: /\\.less$/,\r\n      use: [{\r\n        loader: 'style-loader'\r\n      },{\r\n        loader: 'css-loader'\r\n      },{\r\n        loader: 'less-loader',\r\n        options: {\r\n          sourceMap: true,\r\n          modifyVars: theme // 用于自定义antd主题 覆盖其less变量\r\n        }\r\n      }],\r\n      include: path.resolve(__dirname, 'node_modules')\r\n    }, {\r\n      test: /\\.scss$/,\r\n      use: [\r\n        'style-loader',\r\n        'css-loader',\r\n        'sass-loader'\r\n      ],\r\n      include: APP_PATH\r\n    }, {\r\n      // 字体文件之类的需要这个loader支持\r\n      test: /\\.(eot|woff|woff2|svg|ttf)([\\?]?.*)$/,\r\n      use: ['file-loader'],\r\n      include: APP_PATH\r\n    }, {\r\n      test: /\\.(jpe?g|png|gif|svg)$/,\r\n      use: [{\r\n        loader: 'url-loader',\r\n        options: {\r\n          limit: 8192// 小于1kb的图片采用base64编码 并以DATAUrl的形式嵌入页面\r\n        }\r\n      }],\r\n      include: APP_PATH\r\n    }]\r\n  },\r\n  devServer: {\r\n    contentBase: './build',\r\n    historyApiFallback: true,\r\n    hot: true,// 开启HMR\r\n    inline: true,\r\n    compress: true,// 开启gzip\r\n    port: 8080\r\n  },\r\n  plugins: [\r\n    new webpack.NamedModulesPlugin(),// 用于确保多次build生成的bundle名称不变\r\n    new HtmlWebpackPlugin({\r\n      template: 'index.html'// 以根目录下的index.html为模版\r\n    }),\r\n    new webpack.HotModuleReplacementPlugin()// HMR所需\r\n  ],\r\n  devtool: 'cheap-module-eval-source-map'\r\n}\r\n\r\n```\r\n生产环境\r\n```\r\nconst path = require('path')\r\nconst webpack = require('webpack')\r\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\r\nconst CleanWebpackPlugin = require('clean-webpack-plugin')\r\nconst ROOT_PATH = path.resolve(__dirname)\r\nconst APP_PATH = path.resolve(ROOT_PATH, 'src')\r\n\r\nconst pkg = require(path.join(__dirname, 'package.json'))// package.json\r\nlet theme = {}\r\n// pkg.theme存的是项目中antd主题文件的路径\r\n// 这里是 ./antd-theme.js\r\nif (pkg.theme && typeof(pkg.theme) === 'string') {\r\n  theme = require(path.resolve(__dirname, pkg.theme))\r\n}\r\n// 用于提取自己写的css\r\nconst appExtract = new ExtractTextPlugin({filename: 'app.[contenthash].css', allChunks: true})\r\n// 用于提取依赖包的css(主要是Antd)\r\nconst vendorExtract = new ExtractTextPlugin({filename: 'vendor.css', allChunks: true})\r\n\r\nmodule.exports = {\r\n  entry: {\r\n    app: path.resolve(APP_PATH, 'index.jsx'),\r\n    vendor: ['react', 'axios']\r\n  },\r\n  output: {\r\n    path: path.resolve(__dirname, 'build'),\r\n    publicPath: '/',\r\n    filename: '[name].[chunkhash].js',\r\n    chunkFilename: '[name].[chunkhash:5].chunk.js',\r\n  },\r\n  resolve: {\r\n    // 配置这个后引用node_modules中的依赖包不用加路径 直接import xx from ('antd')即可\r\n    modules: [\r\n      'node_modules'\r\n    ],\r\n    //后缀 配了这个就可以在import时 import xx from (./test) 而不用 import xx from (./test.jsx)\r\n    extensions: ['.js', '.jsx', '.json', '.scss']\r\n  },\r\n  plugins: [\r\n    new webpack.optimize.UglifyJsPlugin({\r\n      compress: {\r\n        warnings: false\r\n      }\r\n    }),\r\n    // 与NamedModulesPlugin 但更适用于生成环境\r\n    new webpack.HashedModuleIdsPlugin(),\r\n    // 部分依赖包(React)会在非生产环境中包含一些提示、警告的代码来帮助开发者解决问题\r\n    // 在生产环境通过配置这个可以阻止生成这些代码 减小bundle的size\r\n    new webpack.DefinePlugin({ 'process.env.NODE_ENV': JSON.stringify('production') }),\r\n    // 变动频率小的外部依赖包\r\n    new webpack.optimize.CommonsChunkPlugin({\r\n      name: 'vendor'\r\n    }),\r\n    // webpack的运行环境所需\r\n    new webpack.optimize.CommonsChunkPlugin({\r\n      name: 'runtime'\r\n    }),\r\n    new HtmlWebpackPlugin({\r\n      template: 'index.html'// 以根目录下的index.html为模版\r\n    }),\r\n    new CleanWebpackPlugin('build'),\r\n    appExtract,\r\n    vendorExtract,\r\n  ],\r\n  module: {\r\n    rules: [{\r\n      test: /\\.js|\\.jsx$/,\r\n      use: [\r\n        'babel-loader',\r\n        'eslint-loader'\r\n      ],\r\n      exclude: /node_modules/\r\n    }, {\r\n      test: /\\.css$/,\r\n      use: vendorExtract.extract(['css-loader'])\r\n    }, {\r\n      test: /\\.less$/,\r\n      use: vendorExtract.extract({\r\n        fallback: 'style-loader',\r\n        use: [{\r\n          loader: 'css-loader'\r\n        },{\r\n          loader: 'less-loader',\r\n          options: {\r\n            sourceMap: true,\r\n            modifyVars: theme // 用于自定义antd主题 覆盖其less变量\r\n          }\r\n        }]\r\n      }),\r\n      include: path.resolve(__dirname, 'node_modules')\r\n    }, {\r\n      test: /\\.scss$/,\r\n      use: appExtract.extract({\r\n        fallback: 'style-loader',\r\n        use: ['css-loader','sass-loader']\r\n      }),\r\n      include: APP_PATH\r\n    }, {\r\n      // 字体文件之类的需要这个loader支持\r\n      test: /\\.(eot|woff|woff2|svg|ttf)([\\?]?.*)$/,\r\n      use: ['file-loader'],\r\n      include: APP_PATH\r\n    }, {\r\n      test: /\\.(jpe?g|png|gif|svg)$/,\r\n      use: [{\r\n        loader: 'url-loader',\r\n        options: {\r\n          outputPath: 'images/',// 将图片放入build/images/目录下\r\n          limit: 8192// 小于1kb的图片采用base64编码 并以DATAUrl的形式嵌入页面\r\n        }\r\n      }],\r\n      include: APP_PATH\r\n    }]\r\n  }\r\n};\r\n\r\n```\r\n"},"./src/blogs/WebpackV3ToV4.md":function(n,r){n.exports="# Webpack V3 升级至 V4\r\n## 序\r\n半年没关注，最近突然发现Webpack的版本已经升到4.16.2了，为了紧跟潮流的步伐，决定将项目中使用的3.10.0来个升级\r\n\r\n## 步骤\r\n1. 安装`webpack`以及`webpack-cli`\r\n2. 将项目中所有用到的`loader`以及`plugin`升级到最新\r\n3. 配置文件里新增 `mode: 'development'` or `mode: 'production'`\r\n4. 移除`webpack.optimize.UglifyJsPlugin`，现在webpack会在生产环境默认对js进行压缩\r\n5. 移除`extract-text-webpack-plugin`，v4推荐使用新的`mini-css-extract-plugin`来提取样式文件\r\n6. 引入`optimize-css-assets-webpack-plugin`以及`uglifyjs-webpack-plugin`，并在生产环境的配置文件下新增\r\n\r\n```js\r\nconst UglifyJsPlugin = require(\"uglifyjs-webpack-plugin\")\r\nconst OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\")\r\n\r\nmodule.exports = {\r\n\toptimization: {\r\n\t\tminimizer: [\r\n\t\t\t// 由于配置optimization会覆盖默认值 所以这里需要配一下UglifyJsPlugin\r\n\t\t\tnew UglifyJsPlugin({\r\n\t\t\t\tcache: true,\r\n\t\t\t\tparallel: true,\r\n\t\t\t}),\r\n\t\t\tnew OptimizeCSSAssetsPlugin({})\r\n\t\t]\r\n\t}\r\n}\r\n```\r\n7. 搞定\r\n\r\n## 总结\r\n升级过后打包和编译速度大概提升了15%左右（粗略比较）\r\n\r\n上述只是针对我之前项目配置的升级，并不完整，仅供参考\r\n\r\nWebpack官方有提供详细的迁移[文档](https://webpack.js.org/migrate/4/)\r\n\r\n遇到问题也可以通过报错信息很快定位到原因，再去相应的Github库上找一找解决办法，迁移过程还是比较顺利的\r\n"},"./src/components/Blog/index.jsx":function(n,r,t){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var e=function(){function n(n,r){for(var t=0;t<r.length;t++){var e=r[t];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(n,e.key,e)}}return function(r,t,e){return t&&n(r.prototype,t),e&&n(r,e),r}}(),o=m(t("./node_modules/react/index.js")),s=m(t("./src/components/Markdown/index.jsx")),l=m(t("./src/blogs/WebpackBaseConfig.md")),a=m(t("./src/blogs/GulpPlugin.md")),i=m(t("./src/blogs/Symbol.md")),u=m(t("./src/blogs/Iterator.md")),c=m(t("./src/blogs/WebpackV3ToV4.md")),d=m(t("./src/blogs/Generator.md"));function m(n){return n&&n.__esModule?n:{default:n}}t("./src/components/Blog/style.less");var p=[l.default,a.default,i.default,u.default,c.default,d.default],f=function(n){function r(){return function(n,r){if(!(n instanceof r))throw new TypeError("Cannot call a class as a function")}(this,r),function(n,r){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!r||"object"!=typeof r&&"function"!=typeof r?n:r}(this,(r.__proto__||Object.getPrototypeOf(r)).apply(this,arguments))}return function(n,r){if("function"!=typeof r&&null!==r)throw new TypeError("Super expression must either be null or a function, not "+typeof r);n.prototype=Object.create(r&&r.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),r&&(Object.setPrototypeOf?Object.setPrototypeOf(n,r):n.__proto__=r)}(r,o.default.Component),e(r,[{key:"render",value:function(){return o.default.createElement("div",{className:"blogs"},p.map(function(n,r){return o.default.createElement("div",{className:"blog",key:r},o.default.createElement(s.default,{data:n}))}))}}]),r}();r.default=f},"./src/components/Blog/style.less":function(n,r,t){},"./src/components/Markdown/index.jsx":function(n,r,t){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var e=s(t("./node_modules/react/index.js")),o=s(t("./node_modules/marked/lib/marked.js"));function s(n){return n&&n.__esModule?n:{default:n}}t("./node_modules/highlight.js/styles/atom-one-light.css"),t("./src/components/Markdown/style.less"),o.default.setOptions({highlight:function(n){return t("./node_modules/highlight.js/lib/index.js").highlightAuto(n).value}}),r.default=function(n){return e.default.createElement("div",{className:"my-md",dangerouslySetInnerHTML:{__html:(0,o.default)(n.data)}})}},"./src/components/Markdown/style.less":function(n,r,t){}}]);