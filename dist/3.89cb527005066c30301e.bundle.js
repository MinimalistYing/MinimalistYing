(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{"./src/components/Markdown/index.jsx":function(n,r,e){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var t=c(e("./node_modules/react/index.js")),o=c(e("./node_modules/marked/lib/marked.js")),s=c(e("./node_modules/highlight.js/lib/highlight.js")),a=c(e("./node_modules/highlight.js/lib/languages/javascript.js")),i=c(e("./node_modules/highlight.js/lib/languages/css.js")),l=c(e("./node_modules/highlight.js/lib/languages/xml.js"));function c(n){return n&&n.__esModule?n:{default:n}}e("./node_modules/highlight.js/styles/github.css"),e("./src/components/Markdown/style.less"),s.default.registerLanguage("javascript",a.default),s.default.registerLanguage("css",i.default),s.default.registerLanguage("xml",l.default),o.default.setOptions({highlight:function(n){return s.default.highlightAuto(n).value}}),r.default=function(n){return t.default.createElement("div",{className:"my-md",dangerouslySetInnerHTML:{__html:(0,o.default)(n.data)}})}},"./src/components/Markdown/style.less":function(n,r,e){},"./src/components/Memo/index.jsx":function(n,r,e){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var t=function(){function n(n,r){for(var e=0;e<r.length;e++){var t=r[e];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(n,t.key,t)}}return function(r,e,t){return e&&n(r.prototype,e),t&&n(r,t),r}}(),o=a(e("./node_modules/react/index.js")),s=a(e("./src/components/Markdown/index.jsx"));function a(n){return n&&n.__esModule?n:{default:n}}e("./src/components/Memo/style.less");var i=function(n){function r(){return function(n,r){if(!(n instanceof r))throw new TypeError("Cannot call a class as a function")}(this,r),function(n,r){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!r||"object"!=typeof r&&"function"!=typeof r?n:r}(this,(r.__proto__||Object.getPrototypeOf(r)).apply(this,arguments))}return function(n,r){if("function"!=typeof r&&null!==r)throw new TypeError("Super expression must either be null or a function, not "+typeof r);n.prototype=Object.create(r&&r.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),r&&(Object.setPrototypeOf?Object.setPrototypeOf(n,r):n.__proto__=r)}(r,o.default.Component),t(r,[{key:"render",value:function(){return o.default.createElement("div",{className:"memo"},o.default.createElement(s.default,{data:this.props.data}))}}]),r}();r.default=i},"./src/components/Memo/style.less":function(n,r,e){},"./src/components/Memos/index.jsx":function(n,r,e){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var t=function(){function n(n,r){for(var e=0;e<r.length;e++){var t=r[e];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(n,t.key,t)}}return function(r,e,t){return e&&n(r.prototype,e),t&&n(r,t),r}}(),o=i(e("./node_modules/react/index.js")),s=i(e("./src/components/Memo/index.jsx")),a=function(n){if(n&&n.__esModule)return n;var r={};if(null!=n)for(var e in n)Object.prototype.hasOwnProperty.call(n,e)&&(r[e]=n[e]);return r.default=n,r}(e("./src/memos/index.js"));function i(n){return n&&n.__esModule?n:{default:n}}function l(n){if(Array.isArray(n)){for(var r=0,e=Array(n.length);r<n.length;r++)e[r]=n[r];return e}return Array.from(n)}e("./src/components/Memos/index.less");var c=a.compability,u=a.css,p=a.http,d=a.jquery,m=a.js,f=a.other,h=a.react,b=a.vue,g=a.webpack,y=[].concat(l(c.split("---")),l(u.split("---")),l(p.split("---")),l(d.split("---")),l(m.split("---")),l(f.split("---")),l(h.split("---")),l(b.split("---")),l(g.split("---")));y.sort(function(n,r){return n.length-r.length});var v=function(n){function r(){return function(n,r){if(!(n instanceof r))throw new TypeError("Cannot call a class as a function")}(this,r),function(n,r){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!r||"object"!=typeof r&&"function"!=typeof r?n:r}(this,(r.__proto__||Object.getPrototypeOf(r)).apply(this,arguments))}return function(n,r){if("function"!=typeof r&&null!==r)throw new TypeError("Super expression must either be null or a function, not "+typeof r);n.prototype=Object.create(r&&r.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),r&&(Object.setPrototypeOf?Object.setPrototypeOf(n,r):n.__proto__=r)}(r,o.default.Component),t(r,[{key:"render",value:function(){return o.default.createElement("main",{className:"memos"},o.default.createElement("section",{className:"memo-wrap"},y.map(function(n,r){return o.default.createElement(s.default,{key:r,data:n})})))}}]),r}();r.default=v},"./src/components/Memos/index.less":function(n,r,e){},"./src/memos/compability.md":function(n,r){n.exports='为了使\r\n```css\r\ndisplay: inline-block\r\n```\r\n在IE8中起作用，必须在文档开头加上\r\n```html\r\n<!DOCTYPE html>\r\n<meta http-equiv="X-UA-Compatible" content="IE=edge">\r\n```\r\n\r\n---\r\n\r\nIE8 中的伪元素只支持类似 `:after` 的写法，不支持 `::after` 的写法\r\n\r\n---\r\n\r\nIE8 切换为兼容性视图模式时会将原 User-Agent 中包含的 `MSIE8.0` 转变为 `MSIE7.0`  \r\n所以在通过 UA 来判断 IE 版本时尤其要注意\r\n\r\n---\r\n\r\n可以通过\r\n```css\r\nfilter: Alpha(opacity = ?)\r\n```\r\n来在 IE7-8 中兼容 CSS3 的 `opacity` 属性\r\n\r\n---\r\n\r\n在 IE8 下如果在 `table-layout: auto` 的表格中为单元格设置\r\n```css\r\nwhite-space: nowrap;\r\noverflow: hidden;\r\ntext-overflow: ellipsis;\r\n```\r\n想实现单元格内文字过长时出现...并截断多余内容会发现无效，反而表格会被内容撑宽，破坏原有布局。\r\n要想实现这种效果，只能将表格设为 \r\n```css\r\ntable-layout: fixed\r\n```\r\n\r\n---\r\n\r\nEdge / IE11 / Safari 好像会试图去识别页面上的数字是否像电话号码  \r\n如果像的话会在这些数字下加一个下划线，并使其可点击打开Skype之类的应用拨号(有些邮箱以及地址也同理)  \r\n想禁用这一特性可在 `<head>` 中加上\r\n```html\r\n<meta\r\n\tname="format-detection"\r\n\tcontent="telephone=no,email=no,address=no"\r\n>\r\n```\r\n\r\n---\r\n\r\n关于\r\n```html\r\n<meta http-equiv="X-UA-Compatible" content="IE=edge">\r\n```\r\n详情参看[这个回答](https://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do)\r\n\r\n---\r\n\r\n通过 ES5shim 和 Babel 使用新特性 Class 时如果类并没有继承却在 `contructor()` 中调用了 `super()`\r\n会导致在 IE8 下报错 Stackoverflow。谨记如果没有继承关系则不应该调用 `super()` 方法\r\n\r\n---\r\n\r\nIE8下可采用\r\n```css\r\nfilter:\r\nprogid:DXImageTransform\r\n.Microsoft\r\n.gradient(startColorstr=xxx,endColorstr=xxx);\r\n```\r\n来兼容 `rgba()`\r\n\r\n---\r\n\r\nAndriod 中调用 WebView 来访问 H5 页面时 HTML5 的 DOMStorage 也就是  \r\n`localStorage|sessionStorage` 默认是关闭的  \r\n需要通过 `settings.setDomStorageEnabled(true)` 来开启  \r\n未开启的话会碰到在 H5 中读取 localStorage 为 null 的问题\r\n\r\n---\r\n\r\nAndriod 部分机型的 WebView 不支持通过\r\n```js\r\nwindow.location.replace()\r\n```\r\n来实现无法返回的页面中转操作，\r\n因此建议优先考虑采用 History API 来实现相应功能\r\n```js\r\nwindow.history.replaceState({}, title, url)\r\n```\r\n\r\n---\r\n\r\n手机端的 H5 页面长按会弹出复制分享的菜单，如果想要禁用 IOS 可以通过\r\n```css\r\n// 这个属性会导致IOS上的input能唤起浏览器键盘 但无法聚焦input框\r\n// 最终结果就是无法正常输入!!!\r\n// 感觉这种禁用需求应该直接予以否决\r\nuser-select: none; \r\n-webkit-touch-callout: none;\r\n```\r\nAndriod 通过\r\n```js\r\nwindow.oncontextmenu = e => e.preventDefault()\r\n```\r\n\r\n---\r\n\r\n在联调 Andriod WebView 内嵌 H5 页面时发现一个问题，页面的 `font-size|line-height`  会随着系统字体大小的调整而缩放导致布局错位  \r\n比如设置一个div的`font-size: 14px`当手机字体设为超小时  \r\n通过 Chrome inspect WebView 可能会发现 Computed Style 中显示的实际 `font-size` 为 `14*0.86=12.04px`  \r\n在Andriod端通过`webview.getSettings().setTextZoom(100)`可完美解决问题\r\n\r\n---\r\n\r\n部分 Andriod 4.4.4 版本的机型 WebView 不支持 CSS3 的 `transform` 加了前缀 `-webkit-transform` 也不行  \r\n但是手机自带的浏览器应该是支持带前缀的形式的，只是 WebView 中不支持  \r\n询问 Andriod 的同学得知 WebView 采用的浏览器内核和手机自带浏览器的内核还是有差别的\r\n\r\n---\r\n\r\n在用 Vue 开发 IOS WebView 内嵌 H5 SPA 页面时碰到点击APP返回上一页时出现页面白屏的问题    \r\n需要滑动一下页面，内容才会显示  \r\n具体问题以及解决方式可以参考[issue](https://github.com/vuejs/vue/issues/5533#issuecomment-343864468)  \r\n导致这个问题的主要原因应该还是在返回时仍去异步加载数据，最佳解决方式应该是缓存相应的异步请求数据\r\n\r\n---\r\n\r\n在各类 Dom 事件中可以通过\r\n```js\r\n// e.path Chrome采用 非标准属性\r\n// e.composedPath() 标准属性 最新的 FF Chrome Safari都兼容\r\nconst path = e.path || (e.composedPath && e.composedPath())\r\n\r\n// 如果需要兼容更低版本的浏览器 可以自己去遍历\r\nfunction getPath(e) {\r\n\tconst path = []\r\n\tlet dom = e.target || e.srcElement\r\n\twhile (dom) {\r\n\t\tpath.push(dom)\r\n\t\t\r\n\t\t// 为了和composedPath()行为一致\r\n\t\tif (dom.tagName === \'HTML\') {\r\n            path.push(document)\r\n            path.push(window)\r\n\r\n            return path\r\n       }\r\n\r\n\t\tdom = dom.parentNode\r\n\t}\r\n}\r\n```\r\n去获取这个事件从触发事件的 Dom 节点开始到 Window 的 Dom 路径\r\n\r\n---\r\n\r\nHTML 中的类名 / ID等都建议以字母开头  \r\n虽然有少部分浏览器兼容数字或下划线开头  \r\n但还是有不少浏览器不支持以数字或下划线开头的CSS选择器  \r\n并且通过 `document.querySelector()` 查找节点时  \r\n部分浏览器会报错 `Failed to execute \'querySelector\' on \'Document\': xxx is not a valid selector.`'},"./src/memos/css.md":function(n,r){n.exports='为了实现隐藏一个元素的滚动条但仍可以在鼠标移入其中时进行滚动操作，\r\n可以通过将其用父元素包裹，并将父元素设为\r\n```css\r\noverflow: hidden;\r\n```\r\n同时将其向右偏移或者增宽，这样可以使得其滚动条隐藏在父元素之下，类似\r\n```html\r\n<div calss="wrapper" style="overflow: hidden; width: 200px">\r\n\t<div class="inner" style="max-height: 10px; overflow: scroll; width: 220px"></div>\r\n</div>\r\n```\r\n的写法\r\n\r\n---\r\n\r\n`::selection`可用于改变文字选中时的字体颜色和背景色，IE9及以上和现代浏览器兼容\r\n\r\n---\r\n\r\n想实现鼠标悬浮在一个父元素上能触发其子元素在 `:hover` 下的样式，\r\n之前的思路是通过借助jQuery `$(parent).hover(() => $(son).hover())`来实现，\r\n今天突然发现原来的方法太复杂，其实只需要几行CSS即可实现想要的效果，类似 \r\n```css\r\n.parent:hover .son {\r\n\t// 这里是鼠标悬浮在父元素上时子元素的样式\r\n}\r\n```\r\n先前的思路在使用原生的Javascript时更难实现，因为原生的规范中并没有hover事件，\r\n与之相关的是鼠标的 `mouseenter/mouseleave/mousemove` 事件，\r\n而即使是在代码中触发了这些事件也是无法触发CSS的 `:hover` 状态的\r\n\r\n---\r\n\r\n当一个\r\n```css\r\ndisplay: inline-block\r\n```\r\n元素的overflow被设为visible以外的值时，它的baseline位置会被从默认的字符x的底线位置修改为下外边沿，\r\n与此同时同一包含块的其它\r\n```css\r\ndisplay : inline-block\r\n```\r\n元素会被迫向下偏移来和这个元素对齐，遵循IFC(Inline Formatting Contexts)原则\r\n\r\n---\r\n\r\n当一个 `position: absolute` 的绝对定位元素的父元素的 `overflow` 值被设为非 `visible` 时，\r\n会出现该定位元素超出父元素的部分会被遮盖掉无法显示的情况，\r\n暂时对这种问题的解决方式只知道将父元素改为 `overflow: visible` 或者尽量保证定位元素不会超出父元素的边界\r\n\r\n---\r\n\r\n当一个元素被设为 `display: flex` 时，它会被当作一个Flex Container，\r\n而它的所有子元素都会被当作Flex Item，并且这时候在其子元素上设置 `float | clear | vertical-align` \r\n的值都是无效的\r\n\r\n---\r\n\r\n一种将全部元素reset为 `box-sizing: border-box` 的方法\r\n```css\r\n{\r\n\tbox-sizing: border-box;\r\n}\r\n*, *:before, *:after {\r\n\tbox-sizing: inherit;\r\n}\r\n```\r\n可能会有更好的方法？详情可见[这篇文章](https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/)\r\n\r\n---\r\n\r\n可以通过给锚点设置一个向上的负偏移量来实现调至锚点位置时不会将锚点至于页面最顶部(避免被顶部所固定的Header遮挡)，\r\n类似: \r\n```css\r\na {\r\n\tposition: relative;\r\n\ttop: -66px;\r\n}\r\n```\r\n\r\n---\r\n\r\n一种提高使用transform以及opacity来做过度效果性能的思路[FLIP](https://aerotwist.com/blog/flip-your-animations/)\r\n\r\n---\r\n\r\n关于实现背景透明但文字不透明的效果，首先考虑的是使用 `opacity` 但其子元素都会继承这个属性，\r\n且无法单独为其子元素设置一个值，所以不可行。如果只是背景色透明的话，\r\n使用 `rgba()` 来设置透明 `background-color` 是一种不错的方法，兼容至IE9。\r\n\r\n---\r\n\r\n关于 \'box-sizing: content-box\' 以及 \'box-sizing: border-box\' 前者其实是W3C提出，\r\n后者是早期IE6、7quirk mode下的盒模型实现。但后来人们发现其实后者更符合人的逻辑，所以加了这个属性。\r\n对于 `content-box` 盒子宽度等于 `width` + `padding` + `border` \r\n对于 `border-box` 盒子宽度就等于所设的 `width`  减去 `padding` 以及 `border` 才是真正展示内容的宽度\r\n\r\n---\r\n\r\n实现文字模糊效果\r\n```css\r\n{\r\n\tcolor: transparent;\r\n\ttext-shadow: #111 0 0 5px;\r\n}\r\n```\r\n\r\n---\r\n\r\n当 `display: inline-block` 的元素间有换行时，浏览器的渲染结果会带有间隙。\r\n这是由于浏览器会将这个换行符当作字符，所以会占有一个的字符大小的宽度。\r\n解决方法有很多，个人较喜欢 `font-size：0`。\r\n\r\n---\r\n\r\n通过CSS3的 `vh(当前视窗高度百分比)`  `vw(当前视窗宽度百分比)`  `vmin`  `vmax` \r\n这几个熟悉来实现基于浏览器视窗高度的布局，例如全屏遮罩，左侧导航100%自适应当前视窗高度等\r\n\r\n---\r\n\r\n类似 `input/img/iframe` 等内部无法容纳其它内容的元素，\r\n无法利用伪元素 `::after/::before` 来实现特定样式\r\n\r\n---\r\n\r\n可以通过mask属性来实现对一块区域的遮罩效果\r\n兼容性不佳，目前只有webkit内核支持\r\nPs:知乎在内容收起时的渐变透明文字遮罩的实现方式\r\n```css\r\n-webkit-mask-image: linear-gradient(#1a1a1a calc(100% - 8rem),transparent calc(100% - 2.8rem));\r\n-webkit-mask-size: 100% 100%;\r\n```\r\n\r\n---\r\n\r\n在Less 1.x和2.x的版本中会默认的对calc中的数值进行计算，从而导致一些意外的结果，例如  \r\n`height: calc(100vh - 20px)`经less编译后的结果是80vh，很明显与我们想要的不符  \r\n为了避免这个问题需要采用`height: calc(~"100vh - 20px")`这样的写法(Ps: Less 3.x版本已修复这个问题)\r\n\r\n---\r\n\r\nCSS 中如下几个伪类选择器中 n 的值不止支持数字类型还支持关键字 (odd / even) 以及公式 (an + b)\r\n* nth-child(n)\r\n* nth-last-child(n)\r\n* nth-of-type(n)\r\n* nth-last-of-type(n)\r\n\r\n例如 `p:nth-child(even)` 可以选择所有父元素中下标为偶数的 `<p>` 元素  \r\n又例如 `p:nth-child(3n+1)` 可以选择所有父元素中下标为 3 的倍数加 1 的 `<p>` 元素\r\n'},"./src/memos/http.md":function(n,r){n.exports="HTTP中的URL中没有具体表明端口号时，默认访问80端口，而HTTPS中的默认端口号为443\r\n\r\n---\r\n\r\n关于URI/URL/URN，URL和URM其实是URI(Uniform Resource Identifier)统一资源定位符的子集。\r\nURL不止指定了资源的地址，同时还指定了获取资源的方式（协议/方法等等）。\r\n而URN则只通过特定的命名空间标识资源，不关注操作获取资源的方式。\r\n\r\n---\r\n\r\nHTTP的版本号不会被当作小数来比较，而是每个数字都单独处理，\r\n所以假设将来有这么俩个版本HTTP/2.22和HTTP/2.3，\r\n前者的版本更高\r\n\r\n---\r\n\r\n由于TCP具有慢启动特性（不能在连接的开始就将所有的IP分组一次发出，\r\n而是只有在一个分组成功确认后才有发出其它俩个分组的权限），\r\n所以新连接的速度一般会比已建立好的连接要慢\r\n\r\n---\r\n\r\n源IP地址、目标IP地址、源端口号、目标端口号这四个值一起唯一地定义了一个TCP连接\r\n\r\n---\r\n\r\nWeb服务器也可以接受一个目录的URL请求，类似 `/dir/` 通过配置服务器可以指定不同的返回形式，\r\n可以返回一个错误，可以默认的去搜索该目录下的index.html并返回，\r\n可以扫描目录返回包含目录内容的html页面(通常这是不安全的，因为这样会把站点的目录结构暴露出来)\r\n\r\n---\r\n\r\n通常Web服务器的文件系统会有一个根目录(Document Root)来专门用于存放Web内容，\r\n当服务器收到一个对静态资源的请求时会获取其URI并附加在根目录后去寻找相应的文件，\r\n例如服务器的根目录为 `/usr/home` 请求为 `/test/haha.gif` \r\n服务器会在文件系统的 `/usr/home/test/haha.gif` 目录下去寻找被请求的资源文件。\r\n要注意的是，一个服务器也可能同时提供多个Web站点，它可以通过不同的请求Host或者IP来访问不同的根目录\r\n\r\n---\r\n\r\nHTTP响应中的Date首部应该表示原始服务器最初产生这个对象的日期\r\n\r\n---\r\n\r\n`Cache-Control : no-store` 禁止代理缓存 `Cache-Control : no-cache  Pragma : no-cache// 兼容HTTP/1.0` \r\n允许缓存，但必须先与服务器进行新鲜度验证，之后才能将内容返回给客户端\r\n`Cache-Control : max-age:66,must-revalidate` 允许缓存，\r\n并且只有在内容过期后才必须进行新鲜度验证（在缓存过期时即使服务器错误也不会将这个陈旧的缓存返回给客户端）\r\n\r\n---\r\n\r\nHTTP常见状态码\r\n* 200 => 请求成功\r\n* 301 => 资源永久迁移\r\n* 302 => 资源临时迁移\r\n* 303 =>需要去另一个地址获取资源\r\n* 304 => 资源未发生变化\r\n* 400 => 请求异常\r\n* 401 => 未授权\r\n* 403 => 服务器拒绝请求\r\n* 404 => 未找到\r\n* 405 => 不支持的请求方法\r\n* 408 => 请求超时\r\n* 414 => 请求URL过长\r\n* 500 => 服务器错误\r\n* 502 => 网关故障\r\n* 504 => 网关超时\r\n\r\n---\r\n\r\nHTTP协议其实并未对url的长度做过多的限制，但各实际中各浏览器的实现都有着不同的长度限制，\r\nRFC2616建议不应超过255 bytes也就是2040bit，实际中是IE浏览器最为严格url最长为2083个字符。\r\n所以关于在get请求中传数组这种操作还需慎重考虑。\r\n\r\n---\r\n\r\n关于浏览器的同源策略:域名（需各级域名完全相同）、协议、端口号都相同称谓同源，非同源的请求会存在跨域问题\r\n\r\n---\r\n\r\n通过在Response Header中配置 `Strict-Transport-Security` 可以实现将请求的页面强制重定向至HTTPS协议访问"},"./src/memos/index.js":function(n,r,e){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var t=e("./src/memos/compability.md");Object.defineProperty(r,"compability",{enumerable:!0,get:function(){return d(t).default}});var o=e("./src/memos/css.md");Object.defineProperty(r,"css",{enumerable:!0,get:function(){return d(o).default}});var s=e("./src/memos/http.md");Object.defineProperty(r,"http",{enumerable:!0,get:function(){return d(s).default}});var a=e("./src/memos/jquery.md");Object.defineProperty(r,"jquery",{enumerable:!0,get:function(){return d(a).default}});var i=e("./src/memos/javascript.md");Object.defineProperty(r,"js",{enumerable:!0,get:function(){return d(i).default}});var l=e("./src/memos/other.md");Object.defineProperty(r,"other",{enumerable:!0,get:function(){return d(l).default}});var c=e("./src/memos/react.md");Object.defineProperty(r,"react",{enumerable:!0,get:function(){return d(c).default}});var u=e("./src/memos/vue.md");Object.defineProperty(r,"vue",{enumerable:!0,get:function(){return d(u).default}});var p=e("./src/memos/webpack.md");function d(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(r,"webpack",{enumerable:!0,get:function(){return d(p).default}})},"./src/memos/javascript.md":function(n,r){n.exports="判断一个值是否为 `NaN` 一定要通过 `isNaN()` 而不是通过等号比较  \r\n因为 `NaN !== NaN`\r\n\r\n---\r\n\r\n在 Javascript 中进行浮点数运算是不可靠的，遵循IEEE 754标准，二进制的浮点数运算不能正确的处理十进制小数  \r\n例如典型的 `0.1 + 0.2 !== 0.3` 在一定的精度范围内可通过将小数转化为整数再进行比较来解决这个问题\r\n\r\n---\r\n\r\n通过Javascript\r\n```js\r\nelement.scrollTop = value\r\n$(dom).scrollTop(value)\r\n```\r\n去设置滚动条滚动位置时，注意所选取的元素就是设置了\r\n```css\r\noverflow-y: scroll\r\n```\r\n的元素\r\n\r\n---\r\n\r\n在使用Javascript的 `parseInt()` 时，最好显示的指明进制，因为 `parseInt('0x16') === 22`  \r\n而你可能期望的结果是 `parseInt('0x16') === 0` 所以显示的指定进制才能做到真正的结果可控 \r\n```js\r\nparseInt('0x16', 16) === 22\r\nparseInt('0x16', 10) === 0\r\n```\r\n\r\n---\r\n\r\n实现类似改变一个DOM元素的滚动条位置但不触发绑定在上面的onscroll函数  \r\n或者改变一个input元素的值不触发绑定在上面的onchange函数的一种思路：在改变值之前先将其绑定的事件函数解绑  \r\n改变完成后再将原有函数绑定回元素上注意如果值的改变如果是连续的，也就是这个过程会短时间内重复多次执行时  \r\n需要将解绑和绑定操作放在延时函数中执行，避免反复多次的绑定事件和解绑事件消耗过多资源，导致浏览器卡顿\r\n\r\n---\r\n\r\n判断点击是否在某个DOM外部发生的思路，判断 `event.srcElement(IE) || event.target(FF)`  \r\n是否是这个DOM节点本身或者是其子元素,这里要注意在内部元素有特殊定位的情况下可能这个思路会有问题\r\n\r\n---\r\n\r\nJavascript中字符串替换API\r\n```js\r\nconst replacement = (match, $1, $2, offset, string) =>{}\r\n// 其中的replacement可以是一个回调函数\r\nString.replace(reg, replacement)\r\n```\r\n通过种方法可以实现将被匹配的文本做特殊的转化后再替换的功能  \r\n具体参数意义以及接口可见[这篇文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace)\r\n\r\n---\r\n\r\n用于监听CSS3动画结束的事件\r\n* webkitAnimationEnd// Chrome Safari\r\n* mozAnimationEnd\r\n* MSAnimationEnd// IE10\r\n* oanimationend// Opera\r\n* animationend\r\n\r\n---\r\n\r\nJavascript中的假值( falsy values )\r\n* false\r\n* null\r\n* undefined\r\n* 空字符串''\r\n* 0\r\n* NaN\r\n\r\n其它值都为 true\r\n\r\n---\r\n\r\n利用原生的JS即可输出格式化后的JSON字符串\r\n```js\r\nJSON.stringify(value[, replacer[, space]])\r\n// space即是缩进数，默认无缩进，最大为10\r\n// replacer可以是一个过滤函数，用来筛选或替换最后的输出结果\r\n```\r\n具体参数意义以及接口可见[这篇文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\r\n\r\n---\r\n\r\nJavascript中的原型是一种动态关系，改变原型的属性会立即对所有该原型链下的对象可见\r\n```js\r\nvar a = {}\r\n// a.test => undefined\r\nObject.prototype.test = 'Hello'\r\n// a.test => Hello\r\n```\r\n\r\n---\r\n\r\n可以使用Object的 `hasOwnProperty()` 方法来检测一个属性是该对象独有还是由原型链继承而来\r\n\r\n---\r\n\r\nJavascript中的Array其实是一种类数组的对象，效率比真正的数组要低，所以会有如下一些奇怪的行为\r\n```js\r\nvar arr = [1,2,3]\r\n// arr[0] => 1\r\n// arr['0'] => 1\r\narr.name = 'Hello'\r\n// arr.name => 'Hello'\r\narr[10] = 10\r\n// arr[6] => undefined\r\narr.length = 1\r\n// arr => [1]\r\n```\r\n\r\n---\r\n\r\n在Javascript中尝试去获取对象的某个属性值时，如果该对象没有该属性  \r\n则会继续在其原型链上查找直至 `Object.prototype` ,如果都没有找到才会返回 `undefined`\r\n\r\n---\r\n\r\n判断是否是数组的方法，IE9+直接用原生的 `Array.isArray()` 如果要向下兼容的话\r\n```js\r\nObject.prototype.toString.call(arg) === '[object Array]'\r\n```\r\nPs:jQuery的 `$.isArray()` 亦是采用这种方式\r\n\r\n---\r\n\r\nJavascript的 `setTimeout()` 和 `setInterval()` 都可以接受字符串参数，并类似eval()将其执行  \r\n不安全并且效率低下，最好不要使用  \r\n具体可见[这篇文档](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)\r\n\r\n---\r\n\r\n`Array.prototype.sort()` 可传入比较函数 `comparefn(a, b)` 来排序  \r\n希望a排在前该函数需返回一个负数，反之返回正数，俩者相等则返回0。\r\n\r\n---\r\n\r\n关于\r\n```js\r\nString.prototype.split([separator[, limit]])\r\n// 'abc'.split() => ['abc']\r\n// 'abc'.split('') => ['a','b','c']\r\n// 'a,b'.split(/(,)/) => ['a', ',', 'b']\r\n'abc'.split('').reverse().join('') // 字符串倒序\r\n```\r\n\r\n---\r\n\r\nJavascript的变量名允许使用Unicode字符集中的所有字母和数字，所以类似 `var 变量 = 1` 也是合法的\r\n\r\n---\r\n\r\n使用Javascript时如果选择在行尾不加上 `;` 是比较危险的行为，例如\r\n```js\r\nvar arr = [1,2,3]\r\nvar b = arr\r\n[2].toString()\r\nconsole.info(b)\r\n```\r\n的结果可能会出人意料，自动加分号的结果是\r\n```js\r\nvar arr = [1,2,3];\r\nvar b = arr[2].toString();\r\nconsole.info(b);\r\n```\r\n再第二行以 `( [ + -` 开头时都需要注意避免以上情况\r\n\r\n---\r\n\r\n使用 `String.prototype.length()` 来判断字符串长度在某些特殊场景下存在问题，例如 `'𝒜'.length === 2` \r\n因为这个方法判断的是给定字符串用了几个UTF-16（16bit）来编码，而有些特殊字符需要32bit来编码  \r\n这时候这个方法计算一个字符的长度是2，判断方法可见[这篇Blog](http://ife.baidu.com/note/detail/id/583)\r\n\r\n---\r\n\r\n```js\r\n//  函数表达式\r\nvar f = function (){ return 1 }\r\n// 函数表达式\r\nvar f = function g(){ return 1 }\r\n// 函数声明\r\nfunction g(){ return 1 }\r\n```\r\n在混合时其实也是函数表达式，所以此时的 `g` 在函数外部是不可见的，试图执行 `g()` 会报错  \r\n关于函数表达式以及函数声明的具体差别可见[这篇文章](http://kangax.github.io/nfe/)  \r\nPs:函数申明会存在函数提升的情况而函数表达式不会\r\n\r\n---\r\n\r\n关于 `Date` 对象有几点需要注意 `new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]])`\r\n使用这个构造函数时 `month` 参数0代表一月，11代表十二月，\r\n同理 `dateObj.getMonth()` 一月返回0，十二月返回11`dateObj.getDay()` 0代表周日，6代表周一`\r\n}, {\r\n\tdate: `2017/11/22`,\r\n\tcontent: `\r\n关于 `typeof` 一共有六种可能结果\r\n* number\r\n* string\r\n* boolean\r\n* undefined\r\n* function\r\n* object\r\n* symbol // ES6新增\r\n\r\n其中有一种较怪异的行为需注意`typeof null // 'object'`\r\n\r\n---\r\n\r\nJavascript中的整数在超过9007199254740992也就是 `Math.pow(2, 53)` 时精度无法精确至个位  \r\n会出现 `Math.pow(2, 53) + 1 === Math.pow(2, 53)` 的情况  \r\n关于其它数字过大时存在的问题可见[这篇Blog](http://www.plqblog.com/views/article.php?id=29)\r\n\r\n---\r\n\r\n小技巧，可以通过俩次位运算来将 `string` 形式的数字转为(效率比parseInt等高) `number`   \r\n类似 `~~'123'// 123` ,Ps: 处理数字的上限是 `Math.pow(2,31) - 1` 对超出该值的数字无法正确转化\r\n\r\n---\r\n\r\n获取浏览器当前滚动条位置可通过 `window.scrollY(Chrome Safari FF)||window.pageYOffset(IE9+)`   \r\n横向位置则通过 `window.scrollX||window.pageXOffset`\r\n\r\n---\r\n\r\n通过 `Element.requestFullscreen()` 以及 `Document.exitFullscreen()`   \r\n可以将页面上的内容进行全屏展示以及取消全屏展示\r\n\r\n---\r\n\r\n在Javascript中 `Object` 是 `truthy value`  \r\n所以哪怕是 `new Boolean(false)` 也会在类型转化时被判断为true\r\n```js\r\nfalse && console.log(1) // false\r\nnew Boolean(false) && console.log(1) // 1\r\n```\r\n\r\n---\r\n\r\nES6的 `import` 除了通常的 `import xx from 'lib'` 外，还可以采用 `import 'lib'`   \r\n将依赖全部引入但不将其赋值给任何变量。在使用webpack引入样式文件时有一些作用  \r\n我们可以 `import 'xx.less'` 而不需要繁琐的 `import Style from 'xx.less'`\r\n\r\n---\r\n\r\n关于`encodeURI|decodeURI`以及`encodeURIComponent|decodeURIComponent`，俩者都是用于对URI进行编解码操作  \r\n区别在于前者默认接受的是一个完整的URL所以不会对所有的字符进行编解码  \r\n而后者会对所有需要被编解码的字符进行编解码，例如对`http://www.a.com?a=1+1`进行`encodeURI`  \r\n不会发生任何变化而进行`encodeURIComponent`的结果是`http%3A%2F%2Fwww.a.com%3Fa%3D1%2B1`\r\n\r\n---\r\n\r\n关于 `location.href = 'xx' || location.assign('xx')` 与 `location.replace('xx')` \r\n俩者的区别在于采用前者当前的地址会被计入History中而后者不会，所以通过后者跳转到新页面后无法通过后退返回，\r\n这点在实现某些中间页面跳转页面是会很有用\r\n\r\n---\r\n\r\n在使用ES6的Default Parameter时需要注意  \r\n调用函数时如果希望传入空参数应该传 `undefined` 而不是 `null`  \r\n例如 `foo(undefined, 66)`\r\n\r\n---\r\n\r\n返回一个只能执行一次的函数\r\n```js\r\nfunction once(fn) {\r\n\tlet isCalled = false\r\n\treturn () => {\r\n\t\tif (!isCalled) {\r\n\t\t\tisCalled = true\r\n\t\t\tfn.apply(this, arguments)\r\n\t\t}\r\n\t}\r\n```\r\n\r\n---\r\n\r\n在使用ES6的Concise Methods时要注意\r\n```js\r\nconst o = {\r\n\tf() {\r\n\t\t// ....\r\n\t\tf() // Error: f is not a function\r\n\t}\r\n}\r\n```\r\n其实等同于\r\n```js\r\nconst o = {\r\n\tf: function() {\r\n\t\t// ...\r\n\t\tf() // Error: f is not a function\r\n\t}\r\n}\r\n```\r\n所以如果想要在函数`f()`通过`f()`来递归调用函数会导致报错，因为`f()`其实是一个匿名函数\r\n\r\n---\r\n\r\n关于ES6的Object super关键字\r\n```js\r\nconst o1 = {\r\n\tfoo() { console.log(1) }\r\n}\r\nconst o2 = {\r\n\tfoo() {\r\n\t\t// 只能在Object concise methods 中使用\r\n\t\t// 且只能以super.XXX这种形式调用\r\n\t\tsuper.foo()\r\n\t\tconsole.log(2)\r\n\t}\r\n}\r\nObject.setPrototypeOf(o2, o1)\r\no2.foo() // 1 2\r\n```\r\n\r\n---\r\n\r\n箭头函数都是匿名的函数表达式(function expression)\r\n\r\n---\r\n\r\n关于ES6 Module\r\n* 基于文件，每个文件为一个Module，不可能一个文件中包含多个Module\r\n* 静态，不能动态的去修改一个Module对外export的API\r\n* 单例，所有的import都是指向同一实例\r\n* import和export只能出现在一个Module的最顶层，也就是说不能出现在任何块中或函数中\r\n\r\n---\r\n\r\n对比`let o1 = {}`以及`let o2 = Object.create(null)`可以发现  \r\n在o2并没有从Object.prototype上继承任何属性`o2.__proto__ === undefined`，是一个干净的空对象  \r\n通过`{}`创建对象等同于`Object.create(Object.prototype)`\r\n\r\n---\r\n\r\nES7移入了新的指数计算操作符`**`  \r\n可以用于替代以往使用的`Math.pow()`  \r\n```js\r\nMath.pow(2, 3) // 4\r\n2 ** 3 //8\r\n```\r\n\r\n---\r\n\r\n可以借助`\\`来实现跨行书写单行字符串  \r\nES6的Template String也支持这种写法\r\n```js\r\nconst str = 'a\\\r\nb\\\r\nc'\r\n\r\nconsole.log(str) // => 'abc'\r\n```\r\n\r\n---\r\n\r\n在WebView中动态设置title\r\n```js\r\nsetTimeout(() => {\r\n\t// 利用iframe的onload事件刷新页面\r\n\tdocument.title = 'xxxxxxxx'\r\n\tconst iframe = document.createElement('iframe')\r\n\tiframe.style.visibility = 'hidden'\r\n\tiframe.style.width = '1px'\r\n\tiframe.style.height = '1px'\r\n\tiframe.onload = () => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tdocument.body.removeChild(iframe)\r\n\t\t}, 0)\r\n\t}\r\n\tdocument.body.appendChild(iframe)\r\n}, 0)\r\n```\r\n\r\n---\r\n\r\n关于`Object.keys()`以及`Object.getOwnPropertyNames()`的区别  \r\n相同的是俩者都不会列出从原型上继承的属性key值  \r\n区别在于前者只会列出所有可枚举属性的key值，而后者会列出所有属性的key值，包括不可枚举的  \r\n所谓不可枚举的属性，即是通过类似  \r\n`Object.defineProperty(o, 'a', { enumerable: false, value: 0 })`定义的属性\r\n\r\n---\r\n\r\nJavascript 中一共有六种种原始类型( primitive type )  \r\nstring/boolean/number/null/undefined/symbol( ES6 新增 )\r\n\r\n---\r\n\r\n严格模式下函数中的`arguments`会被禁用\r\n\r\n---\r\n\r\nIE10+ 以及各现代浏览器提供了原生的方法 `btoa` 以及 `atob` 支持对字符串进行 Base64 编解码  \r\n```js\r\n// Binary to ASCII 编码\r\nwindow.btoa('a') // \"YQ==\"\r\n// ASCII to Binary 解码\r\nwindow.atob('YQ==') // \"a\"\r\n```\r\n\r\n---\r\n\r\nJavascript `catch` 块中申明的变量具有块级作用域（小技巧 应该用不到）\r\n```js\r\ntry {\r\n\tthrow undefined\r\n} catch(a) {// 这里的a具有块级作用域\r\n\ta = 1\r\n  console.log(a)\r\n}\r\nconsole.log(a)// Uncaught ReferenceError: a is not defined\r\n```\r\n\r\n---\r\n\r\n关于 Closure 的几个代码片段\r\n\r\n```js\r\n// var let const 不会影响Closure\r\nfunction foo() {\r\n\tvar a = 1\r\n\tlet b = 2\r\n\tconst c = 3\r\n\tfunction bar() {\r\n\t\tconsole.log(a, b, c)\r\n\t}\r\n  \r\n\treturn bar\r\n}\r\n\r\nfoo()()\r\n\r\n// Arrow Function不会影响Closure\r\nvar foo = () => {\r\n\tvar a = 1\r\n\tlet b = 2\r\n\tconst c = 3\r\n\treturn () => console.log(a, b, c)\r\n}\r\n\r\nfoo()()\r\n\r\n// setTimeout会创建一个Closure\r\nfunction wait(message) {\r\n\tsetTimeout(() => {\r\n\t\tconsole.log(message)\r\n\t}, 1000)\r\n}\r\n\r\nwait('hi')\r\n```\r\n\r\n---\r\n\r\n在条件语句中申明函数会出现的情况\r\n\r\n```js\r\n// 不建议使用这种形式\r\n// 估计许多语法校验工具会视这种写法为错误写法\r\n\r\n// 按照ES6的  Block-Scoped Function\r\n// 理论上调用a()和b()时应该报错\r\nif (true) {\r\n\tfunction a(){\r\n\t\tconsole.log('1')\r\n\t}\r\n} else {\r\n\tfunction a(){\r\n\t\tconsole.log('2')\r\n\t}\r\n} \r\na() // 1\r\n\r\nif (false) {\r\n\tfunction b(){\r\n\t\tconsole.log('1')\r\n\t}\r\n} else {\r\n\tfunction b(){\r\n\t\tconsole.log('2')\r\n\t}\r\n} \r\nb() // 2\r\n```\r\n\r\n---\r\n\r\n一种特殊的数组去重方法，不考虑兼容性的话最好直接使用 `Array.from(new Set(originArr))` \r\n\r\n```js\r\n// 该方法有个缺陷\r\n// 不能兼容一些特殊情况 因为JSON.stringify()方法有一些特例\r\nfunction unique(arr) {\r\n\tlet obj = {}\r\n  \r\n  arr.map(item => {\r\n  \tlet key = JSON.stringify(item) + typeof item // 避免基本类型 类似 1与'1' stringify后作为key相同\r\n    \r\n    obj[key] = item// 利用JS对象的key不能重复的特性\r\n  })\r\n  \r\n  console.log(Object.values(obj))// 打印结果数组\r\n}\r\n// 注意以下特例\r\nunique([undefined,'undefined',null,'null',NaN,'NaN',Infinity,'Infinity',-Infinity,'-Infinity'])\r\n// 无法进行深度比较 也就无法区分 [1,2,3] 和 [1,2,3] 类似这样的引用类型\r\nfunction uniqueBySet(arr) {\r\n\tconsole.log(Array.from(new Set(arr)))\r\n}\r\n\r\nlet test1 = [1,'1',1,true,true,'true']\r\nunique(test1)\r\nuniqueBySet(test1)\r\nlet test2 = [[1,2,3], [1,2,3], {a : 1}, {a : '1'}, {b : 1}, {b : 1}]\r\nunique(test2)\r\nuniqueBySet(test2)\r\nlet test3 = [undefined, 'undefined', undefined, null, 'null']\r\nunique(test3)\r\nuniqueBySet(test3)\r\nlet a = {a : 1}\r\nlet test4 = [a , a,  {a:1}]\r\nunique(test4)\r\nuniqueBySet(test4)\r\n```\r\n\r\n---\r\n\r\n一些有关 Javascript 变量提升的实例\r\n\r\n```js\r\n(function() {\r\n  var a = b = 1;// var 声明的是a 导致b其实是一个全局变量\r\n})();\r\n\r\nconsole.log(b)// 1\r\nconsole.log(typeof a)//undefined 注意 如果直接试图使用a变量会抛出错误 但在typeof操作符后就不会\r\nconsole.log(a)// Uncaught ReferenceError: a is not defined\r\n\r\n\r\n(function() {\r\n\t'use strict'// 严格模式下不加var声明会直接报错\r\n\tvar a = b = 1;// Uncaught ReferenceError: b is not defined\r\n})();\r\n\r\n\r\n// 函数声明会提升 函数表达式不会\r\n(function test() {\r\n   console.log(a);// undefined\r\n   console.log(foo());// 2\r\n   console.log(bar());// Uncaught TypeError: bar is not a function\r\n   var a = 1;\r\n   function foo() {// 函数声明\r\n      return 2;\r\n   }\r\n   var bar = function () {// 函数表达式\r\n   \t\treturn 2;\r\n   }\r\n})()\r\n\r\n\r\n/*\r\n相当于\r\nvar a\r\nfunction a(){ return 1 }\r\na=123\r\nconsole.log(a)\r\n*/\r\nvar a=123;\r\nfunction a(){ return 1 }\r\nconsole.log(a);//123 \r\n\r\n\r\n/*\r\n相当于\r\nvar a\r\nfunction a(){ return 1 }\r\na()\r\n*/\r\nfunction a(){ return 1 }\r\nvar a;\r\na();// 1\r\n\r\n/**\r\nconst和let不会申明提升？\r\n*/\r\ntypeof a; var a=1;\r\ntypeof a; const a=1; //Uncaught ReferenceError: a is not defined\r\ntypeof a; let a=1; //Uncaught ReferenceError: a is not defined\r\n\r\n\r\n```\r\n\r\n---\r\n\r\n利用解构实现交换俩个变量的值，并且无需中间变量\r\n```js\r\nvar x = 1, y = 2;\r\n[ y, x ] = [ x, y ];\r\n```\r\n\r\n---\r\n\r\n利用Function.prototype更快捷的创建一个空函数\r\n\r\n```js\r\nvar cb = Function.prototype; // 相当于 var cb = function(){}\r\n```\r\n\r\n---\r\n\r\n关于函数参数同时采用解构以及默认参数时的细微不同\r\n\r\n```js\r\nfunction test( { x = 1 } = {}, { y } = { y: 1 }) {\r\n\tconsole.log(x,y)\r\n}\r\ntest() // 1,1\r\ntest({}, {}) // 1,undefined\r\n```\r\n\r\n---\r\n\r\n在 ES6 的对象方法中使用 `super` \r\n```js\r\n// 注意只能在采用简写的函数中使用且只能用super,xx()的形式不能用super()的形式\r\nvar parent = {\r\n\tfoo() {\r\n  \tconsole.log('parent')\r\n  }\r\n}\r\n\r\nvar son = {\r\n\tfoo() {\r\n  \tsuper.foo()\r\n    console.log('son')\r\n  }\r\n}\r\n\r\nObject.setPrototypeOf(son, parent)\r\nson.foo() // parent son\r\n```\r\n\r\n---\r\n\r\nJavaScript 实现大数相加\r\n```js\r\n/**\r\n*\t在JS中超出Math.pow(2,53) 也就是 9007199254740992 的整数会失去精度\r\n* \t包括通过parseInt()无法正确转化 在console中无法直接输出等 只能通过字符串的形式进行操作或传输\r\n**/\r\n// 入参 字符串形式的大数a和b\r\nfunction sum(a, b) {\r\n\ta = a.split('')\r\n  b = b.split('')\r\n  let c = 0\r\n  let result = ''\r\n  while (a.length || b.length || c > 0) {\r\n  \tc += ~~a.pop() + ~~b.pop() //各位对应相加 结果可能是0~18\r\n    result = c%10 + result\r\n    c = c>9 ? ~~(c/10) : 0 // 处理可能的进位\r\n  }\r\n  \r\n  return result.replace(/^0+/,'') // 处理以0开头的数字\r\n}\r\n\r\nconsole.log(sum('9007199254740992', '1007199254740992'))\r\n```\r\n\r\n---\r\n\r\n关于 ES6 新引入的 Regexp Sticky Mode (适用于匹配一串以一定规则重复的字符串)\r\n```js\r\nvar reg = /foo/\r\nvar regSticky = /foo/y\r\nvar str = '***foo***'\r\n\r\nreg.test(str) // true\r\nreg.lastIndex = 4\r\nreg.test(str) // true\r\n\r\nregSticky.test(str) // false\r\nregSticky.lastIndex = 3 // 只有在lastIndex处完全匹配 才算做匹配成功\r\nregSticky.test(str) // true\r\nconsole.log(regSticky.lastIndex) // 6 匹配成功会将lastIndex移动至匹配结果后紧接着的index\r\nregSticky.test(str) // false\r\nconsole.log(regSticky.lastIndex) // 0 匹配失败会将lastIndex重置为0\r\n```\r\n\r\n---\r\n\r\nIterator 实现斐波那契数列\r\n```js\r\nconst febonacci = {\r\n\t[Symbol.iterator]() {\r\n  \tlet a = 1\r\n    let b = 1\r\n    return {\r\n    \tnext() {\r\n      \tconst value = b\r\n        let done = b >= 1000 // 超过1000结束迭代\r\n        b = a\r\n        a = value + a       \r\n        \r\n        return {\r\n        \tvalue,\r\n          done\r\n        }\r\n      },\r\n      return() {\r\n      \tconsole.log('Stop iterate')\r\n      \treturn { done: true }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfor (let i of febonacci) {\r\n\tconsole.log(i)\r\n  if (i > 500) {\r\n  \tbreak;\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\nJavaScript 实现数组乱序\r\n```js\r\nconst arr = [1,2,3,4,5,6,7,8,9,10]\r\n\r\n// 错误的方法 以下代码并不能做到真正乱序\r\n// 由于Array.sort()内部的实现方式导致\r\n// Array.prototype.sort(comparefn)\r\n// Calling comparefn(a,b) always returns the same value v when given a specific pair of values a and b as its two arguments.\r\narr.sort(() => Math.random() - 0.5)\r\n\r\n// 进阶班 保证对于相同的a,b arr.sort()比较产生的结果相同\r\nconst random = arr.map(Math.random);\r\narr.sort((a, b) => random[a] - random[b]);\r\n\r\n// Fisher–Yates shuffle\r\nlet i = arr.length\r\nwhile(i) {\r\n\tconst random = Math.floor(Math.random()*i);\r\n  i--;\r\n  [arr[i], arr[random]] = [arr[random], arr[i]]\r\n}\r\n```\r\n\r\n---\r\n\r\n最新的 ES 提案在 `Class` 内可以通过 `#` 申明私有属性\r\n```js\r\nclass Foo {\r\n\t#foo = 5\r\n\t#bar = 6\r\n\ttest() {\r\n\t\tconsole.log(this.#foo, this.#bar)\r\n\t}\r\n}\r\n```\r\n\r\n---\r\n\r\n给定一组数 `1 2 3 4 5 6 7 8 9` 在其间隔处任意加上 `+ - * / 空白` 五种操作符  \r\n列出其所有计算结果为 `100` 的组合\r\n```js\r\nconst num = [2, 3, 4, 5, 6, 7, 8, 9]\r\nconst operators = ['', '+', '-' , '*', '/']\r\n\r\nfunction recursive(t, i) {\r\n\tlet str\r\n\tfor (let operator of operators) {\r\n\t\tstr = t + operator + num[i]\r\n\t\tif (i >= 7) {\r\n\t\t\tif (eval(str) === 100) console.log(str, eval(str))\r\n\t\t} else {\r\n\t\t\trecursive(str, i+1)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// 以 1 为起始进行递归\r\nrecursive('1', 0)\r\n\r\n```\r\n\r\n---\r\n\r\n关于 JavaScript 中的 Timer `setTimeout` 以及 `setInterval`\r\n* 每次调用会返回一个自增的 ID 用于传入 `clearTimeout` 以及`clearInterval` 来清除计时器\r\n* 由于 JavacScript 是单线程的，所以这俩个函数并不能确保一定会在指定时间到达后立即执行  \r\n\r\n```js\r\n// 超出 100ms 一段时间后才会输出\r\n// 因为线程被循环阻塞\r\nconsole.time('执行间隔')\r\nsetTimeout(() => console.timeEnd('执行间隔'), 100)\r\n\r\nfor (let i=0; i<1000000000; i++){}\r\n```\r\n* 不传入延时参数时默认为 0ms，哪怕延时 0ms 也是异步，只有主线程空闲时才执行\r\n\r\n```js\r\n// 输出顺序为 2 1\r\n// 并不会按正常执行顺序输出\r\nsetTimeout(() => console.log(1))\r\n\r\nconsole.log(2)\r\n```\r\n* `setInterval` 所指的间隔并不是指多长时间执行一次，而是多长时间将该函数放到执行队列中一次  \r\n所以当传入其中的函数执行时间超过所设的间隔时间时，函数真实的执行间隔可能为 0ms\r\n\r\n```js\r\nlet i = 0;\r\nconst start = Date.now();\r\nconst timer = setInterval(() => {\r\n    i++;\r\n    i === 5 && clearInterval(timer);\r\n    console.log(`第${i}次开始`, Date.now() - start);\r\n    for(let i = 0; i < 100000000; i++) {}\r\n    console.log(`第${i}次结束`, Date.now() - start);\r\n}, 100);\r\n```\r\n\r\nPs: 还有一个 IE 专属的 `setImmediate` 可以理解为 `setTimeout(0)` 的替代，在此不做展开\r\n\r\n---\r\n\r\n项目中开发接入支付宝跳转流程时碰到了一个问题  \r\n需要通过 Ajax 向后台请求跳转 URL 并通过 `window.open()` 在新窗口中打开  \r\n由于浏览器限制只允许在 Dom 事件处理函数中通过 `window.open()` 来打开新页面  \r\n所以如果直接在请求成功的回调函数中进行操作会发现打开新窗口的操作被浏览器拦截  \r\n需要用户确认允许该页面弹窗才能正常跳转  \r\n该问题的最终解决方案如下\r\n```js\r\nfunction onClick() {\r\n\t// 先在点击事件中打开原项目的中转页\r\n\tconst newWindow = window.open('redirect.html', '_blank')\r\n\taxios.post('xxx')\r\n\t.then(url => newWindow.location.href = url) // 请求成功 将新页面的地址修改为后台返回的 URL\r\n\t.catch(err => newWindow.close()) // 请求失败 关闭新开的窗口\r\n}\r\n```\r\n\r\n---\r\n如何判断一个函数是正常被调用还是通过 `new` 当作构造函数调用\r\n```js\r\nfunction Foo() {\r\n\t// 严格模式下 this 为 undefined\r\n\tif (this === window || typeof this === undefined) {\r\n\t\tconsole.log('普通调用')\r\n\t}\r\n\t\r\n\t// 构造函数中的 this 指向新创建的实例\r\n\tif (this instanceof Foo) {\r\n\t\tconsole.log('构造函数调用')\r\n\t}\t\r\n}\r\n```\r\n"},"./src/memos/jquery.md":function(n,r){n.exports="利用好jQuery的事件命名空间可以减少很多需要在一个Dom元素的同一事件上绑定多个不同回调函数时会碰到的问题，例如\r\n```js\r\n$(dom).on('click.a', () => {})\r\n$(dom).on('click.b', () => {})\r\n```\r\n当出于某种原因需要解绑第一个函数时，只需要`$(dom).off('.a')` 即可实现，\r\n同时也不会对b命名空间下的绑定事件有任何影响。如果想触发某个特定空间下的事件，\r\n可以通过 `$(dom).trigger('click.b')` 来实现\r\n\r\n---\r\n\r\njQuery可以通过 `$(':visible')/$(':hidden')` 来查找可见/不可见的Dom元素\r\n(通过判断元素的height和width是否大于0，所以\r\n```css\r\nopacity:0;\r\nvisibility: hidden;\r\n```\r\n的元素会被认为是可见的)。\r\n这俩种选择器会带来性能上的问题，尽量避免使用，\r\n一定要使用的话也应该先通过纯CSS选择器将目标选出再通过 `$(dom).is(':visible')` 或 `$(dom).is(':hidden')` 判断，\r\n或者通过 `$(dom).filter(':visible')` 或 `$(dom).filter(':hidden')` 过滤\r\n\r\n---\r\n\r\njQuery核心函数的几种重载形式：\r\n```js\r\n$(($) => {  //文档加载完毕  //相当于$( document ).ready()  })\r\n$('selector') // 选择器\r\n$('selector', parentDom) // 选择器(在父元素的范围下)\r\n$(dom) // 将Dom对象包装成jQuery对象\r\n$(domArray) // 将Dom对象的数组包装成jQuery对象\r\n$() // 1.4以后返回空的jQuery对象\r\n$('<div></div>') // 将Html字符串包装成jQuery对象\r\n$('<div>', {'class': 'a'}) // 生成一个标签并包装成jQuery对象\r\n```\r\n\r\n---\r\n\r\n使用 `$(dom).html('...')` 时需注意防范脚本注入攻击，如果传入的字符串中包含可由用户填写的字段需要先进行转义，\r\n更好的办法是尽量使用 `$(dom).text('...')`\r\n\r\n---\r\n\r\njQuery部分版本(1.10.X 1.8.X 可能还有其它)存在一个很奇怪的Bug，\r\n在HTML标签中使用nodeName作为ID(或者input的name)会导致页面报错 `a.nodeName.toLowerCase is not a function` \r\n使用nodeType作为ID会导致$(window)发生变化并且绑定在上面的resize事件会失效。\r\n综上所述，以后谨记不要使用nodeName/nodeType/nodeValue作为HEML标签的ID或者name。\r\n\r\n---\r\n\r\n关于 `$.trim()` IE9+应该已经实现了原生的 `String.prototype.trim()` \r\n低版本浏览器可以使用jQuery的方式来实现Polyfill\r\n```js\r\nfunction( text ) {\r\n\treturn text == null ?\r\n\t\t''\r\n\t\t:\r\n\t\t( text + '' ).replace( /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '' )\r\n}\r\n```\r\n其正则中的 `\\xA0` 代表全角空格 `\\uFEFF` 代表BOM头"},"./src/memos/other.md":function(n,r){n.exports="在自测与后台有交互，会发送请求的地方时一定要注意在Chrome的Network中观察发送请求的URL、参数等是否符合预期，\r\n同时也要注意考虑请求返回失败或返回空结果时页面UI的展示\r\n\r\n---\r\n\r\n关于采集站点的PV、UV数据，传统的做法是当页面load完成后像后台发送数据，\r\n当作一次PV但在SPA(Single Page App)以及PWA(Progressive Web App)的情景下，这样的断定方式显得不那么合理，\r\n用户有可能一天中只Load一次页面然后在一天的任意时间段在这个应用中活动\r\n而不需要再一次Load页面考虑用更新的方式进行统计可能比较合理，\r\n例如借助[Page Visibility API](https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API)\r\n在用户初次打开应用浏览以及过去合理的一段时间后(可以用Session持续的最长时间来判断)后\r\n从其它再次切换到这个Tab页都作为一次PV\r\n详情可见这篇[Blog](https://philipwalton.com/articles/how-we-track-pageviews-is-all-wrong/)\r\n\r\n---\r\n\r\nHTML5新增了 `input` 事件来监听文本框的输入变化，但在IE9下存在用户删除输入或剪切文本时不会触发该事件的Bug,\r\n并且IE8下没有该事件，需同时监听 `propertychange` 来实现兼容IE8\r\n\r\n---\r\n\r\n正则表达式中的 `.` 可以用于匹配除换行符外的所有字符,如果想匹配含换行符在内的所有字符可以使用 `[\\s\\S]`\r\n\r\n---\r\n\r\n在新的HTML5规范中，如果一个元素拥有ID属性，那么ID属性的属性值就会成为window对象的属性名，\r\n属性值就是ID对应的元素。如果下列标签中的元素拥有name属性\r\n* `<a>`\r\n* `<applet>`\r\n* `<area>`\r\n* `<embed>`\r\n* `<form>`\r\n* `<frame>`\r\n* `<frameset>`\r\n* `<iframe>`\r\n* `<img>`\r\n* `<object>`\r\n\r\n那么name属性的属性值就会成为window对象的属性名。\r\n例如页面上有这么一个元素\r\n```html\r\n<div id='a'></div>\r\n`\r\n在script中\r\n```js\r\nconsole.info(a)  //结果为<div id='a'></div>\r\n```\r\n\r\n---\r\n\r\n阅读垠神博客有感\r\n* 会写程序不是一件很了不起的事情，不要自负\r\n* 语言、框架都只是工具，会用即可，不必过于推崇，重要的是我们脑海里的思想\r\n* 开发软件也是一种工程，一定要极力避免Bug，这才是一个工程师该做的\r\n* 面对同事、新人的提问请耐心解答，不要动不动就让提问者自行Google\r\n* 不要觉得向他人提问是什么难为情的事，世界上总有东西是你不清楚的，哪怕是你日常工作所用的东西\r\n* 复杂的代码不是显示能力的途径，简单易懂的才是\r\n\r\n---\r\n\r\n在HTML中属性可以用双引号、单引号、甚至不用引号包围，浏览器都是支持的。\r\n所以Google为了节省字节会采用不用引号的风格，大概对访问量极大的网站这也是一种省钱的方式吧\r\n\r\n---\r\n\r\n```html\r\n<meta http-equiv=\"Content-Type\"\r\n\tcontent=\"text/html; charset=utf-8\">\r\n<meta charset=\"utf-8\">\r\n```\r\n在HTML中俩者都可用来表明页面所采用的字符集，各浏览器的兼容性良好，但后者更短建议采用后者\r\n\r\n---\r\n\r\n当页面的UI需要在后台数据返回后进行刷新时，一定要考虑到网络极差的情况下，请求会延迟很久后返回。\r\n这期间UI要怎样展示，或者用户能否进行操作，会不会有遗留的表单数据等等。\r\n\r\n---\r\n\r\n关于HTML中的相对路径 `./` 是文档相对路径，也就是当前访问页面的路径 `/` 是基于站点根目录的相对路径，\r\n举例说明访问网址http://0.0.0.0/1/2/son.html\r\n* ./test.js => http://0.0.0.0/1/2/test.js\r\n* /test.js => http://0.0.0.0/test.js\r\n\r\n---\r\n\r\n关于正则表达式量词(Regexp Quantifier)\r\n* ?  => {0,1}\r\n* \\\\+ => {1,}\r\n* \\\\*  => {0,}\r\n\r\n如果只有一个量词则为贪婪匹配，会尽可能的匹配更多结果。如果量词后附加后缀?则进行非贪婪匹配。\r\n\r\n---\r\n\r\n匹配中文字符（简繁体都包含）的正则 `/^[\\u4e00-\\u9fa5]+$/` 暂时无法确认其是否完全正确\r\n\r\n---\r\n\r\nnpm安装node-sass报错 `%1 is not a valid Win32 application` 看了看报错信息大概是说什么东西下载失败导致的，\r\n切换成淘宝镜像用cnmp安装就好了 `npm install -g cnpm --registry=https://registry.npm.taobao.org`\r\n\r\n---\r\n\r\n由于node有许多底层依赖包需要依靠c++,所以需要额外安装 `node-gyp` 提供跨平台的编译支持，\r\n安装之前需要先装好相应的python/c++等环境，\r\n根据官方文档 `npm install --global --production windows-build-tools` 即可\r\n（很多情况下的npm安装失败可能都是因为这个没装好）\r\n\r\n---\r\n\r\n页面上引用静态资源时的相对路径与绝对路径的区别，\r\n* `src='xx.js'` 相对于当前页面的路径，\r\n* `src='./xx.js'` 相对于当前页面的路径，\r\n* `src='../xx.js'` 相对与当前页面的上级路径，\r\n* `src='/xx.js'` 相对于根目录路径，\r\n* `src='http//:xx.com/xx.js'` 绝对路径\r\n\r\n---\r\n\r\n避免浏览器缓存HTML页面可以在head中加上标签\r\n```html\r\n<meta http-equiv='Cache-Control' content='no-store'>\r\n```\r\n通常会采用 `no-cache` 的策略，只有在服务器的资源发生变化时才去再重新拉取，否则返回304采用缓存的资源\r\nPs: 这种方式好像不可靠，不能保证浏览器一定会按照这个规则来执行，最好还是去配置提供静态资源的服务端容器\r\n\r\n---\r\n\r\nGulp确保任务按一定顺序执行\r\n```js\r\ngulp.task('second', ['first'], () => {})\r\n``` \r\nGulp在匹配的文件列表中剔除指定文件\r\n```js\r\ngulp.src(['asset/*.js', '!asset/exclude.js'], () => {})\r\n```\r\n上述代码会匹配asset目录下除去exclude.js的所有以.js结尾的文件\r\n\r\n---\r\n\r\nGulp在文件变化时触发回调函数\r\n```js\r\ngulp.watch('...', (event) => {})\r\n// event.path 发生变化文件的路径\r\n// event.type added|changed|deleted|renamed\r\n```\r\n\r\n---\r\n\r\n在使用\r\n```js\r\ngulp.src(...).pipe(...).pipe(...)\r\n```\r\n的过程中会发现当出错时控制台中报出的错误信息很难看懂,这是由于在Node.js中stream出错时会抛出error事件，\r\n而上述代码里没有写有关错误事件的处理函数，所以Node会默认的报出堆栈跟踪信息作为错误信息。\r\n如果采取如下捕获异常事件的方式来处理错误\r\n```js\r\ngulp.src().pipe().on('err', () => {})\r\n```\r\n会使代码变得很复杂，推荐使用Pump的方式来进行处理\r\n```js\r\nvar pump = require('pump')\r\npump([gulp.src(), uglify(), concat()], cb)\r\n```\r\n\r\n---\r\n\r\n当页面有大量图片需要展示时可以考虑采用Google提出的[webp](https://developers.google.com/speed/webp/)来进行优化  \r\n由于兼容性还欠佳所以仍需要做一些降级工作，在浏览器不支持时降级为其它图片格式\r\n相关细节可以看[这篇Blog](https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html)\r\n\r\n---\r\n\r\n算法题中经常出现要求输出modulo 10^9+7后的结果  \r\n是因为当数字过大时，程序需要特定的算法才能精确的计算  \r\n而通过模计算，可以使得不需要实现大数计算的算法便可比较结果的正确性\r\n[Stackoverflow](https://stackoverflow.com/questions/25689186/what-is-the-significance-of-modulo-1097-used-in-codechef-and-spoj-problems)\r\n\r\n---\r\n\r\n众所周知，页面的加载顺序是从上至下的，并且浏览器中的 JavaScript 为单线程执行    \r\n所以当碰到 `<script src=\"xxx\"><\/script>` 时，浏览器会等待脚本下载并执行完才继续渲染页面  \r\n如果脚本文件很大或者网络较慢就会导致浏览器长时间处于白屏状态，不那么耐心的用户可能会选择直接关闭网页  \r\n起初开发者想到的优化办法是尽可能的把 `<script>` 放到页面底部（也就是 `</body>` 前）  \r\n这样脚本加载便不会影响到页面最初的渲染效率了  \r\nHTML5 新引入了 `defer` 以及 `async` 来优化这个过程  \r\n* `<script defer src=\"xxx\"><\/script>`  会使脚本的下载与页面渲染并行进行  \r\n当页面渲染完毕后才去依次执行下载完的脚本文件\r\n* `<script async src=\"xxx\"><\/script>`  也会使脚本的下载与页面渲染并行进行  \r\n与 `defer` 的区别在于一等到脚本下载完成浏览器便会暂停渲染并执行相应的脚本  \r\n\r\n[点击看图](https://segmentfault.com/q/1010000000640869)\r\n\r\n---\r\n\r\n读完 [Dan Abramov 的 Blog](https://overreacted.io/things-i-dont-know-as-of-2018/) 的感想\r\n* 即使是一名经验再丰厚的开发者也不是什么都会  \r\n不应该期望一个开发者能熟练的掌握所有技能\r\n* 但是开发者应该有着各自擅长的专业方向  \r\n并且具备快速学习新技术的能力\r\n* 开发者需要更深入的去学习理解自己的专精技能  \r\n并且对其充满自信，总有一些方面那些更有经验的开发者也没有你理解的透彻\r\n\r\n"},"./src/memos/react.md":function(n,r){n.exports="React组件中的HTML标签必须闭合，否则会编译报错，例如 `<img>` 必须写作 `<img/>`\r\n\r\n---\r\n\r\n如果确定一个Component再初始化后不需要重新render，可以在组件中声明\r\n```js\r\nshouldComponentUpdate (nextProps, nextState) {return false;}\r\n```\r\n这会使React跳过对该组件是否需要重绘的检查，并且跳过调用\r\n* componentWillUpdate()\r\n* render()\r\n* componentDidUpdate()\r\n获得性能上的提升。\r\n还有一种情况下，如果你希望只有在组件的部分属性发生变化时才检查，可以通过在上述方法中比较\r\n`nextProps` 和 `nextState` 中的指定值是否发生变化来实现。\r\n还可以通过继承React提供的 `React.PureComponent` 来方便的实现上述需求，\r\nPureComponent只会对属性进行浅比较，当属性的数据结构复杂，层级较深时比较可能会失败\r\n从而一直返回false导致组件不会发生更新\r\n就最近的经验来看，把一些展示型的组件设为PureComponent可以获得较为明显的性能提升\r\n\r\n---\r\n\r\n关于React中的Event Handlers传参数有一下俩种方式\r\n```html\r\n<button onClick={(e) => this.func(id, e)}>click</button>\r\n```\r\n或者\r\n```html\r\n<button onClick={this.func.bind(this, id)}>click</button>\r\n```\r\n第二种方式下的 `e` 会默认作为最后一个参数传递\r\n\r\n---\r\n\r\n使用React-Router(3.x版本 其它版本估计也一样)，如果在 `<Router history={xxx}>` 上不配置 `history`\r\n会报错 `Uncaught TypeError: Cannot read property 'getCurrentLocation' of undefined` 所以这个属性是SPA必配？\r\n\r\n---\r\n\r\n关于React-Router中 `browserHisory` 和 `hashHistory` 的区别，\r\n前者的URL类似 `xx/xx` 后者是 `/#/xx` 由于HTTP协议的约定，URL中 `#` 后作为片段(frag)不会随请求发送至后台，\r\n所以不需要服务器进行特殊配置，而前者是借助浏览器下的 `history` API实现，\r\n在IE8/9下会导致跳页时Full Load，并且需要服务器配置接受所有请求都返回 `index.html` 。\r\n优点时使得站点有清晰干净的URL，并且服务器端渲染只能通过这种方式实现，固推荐使用 `browserHistory`\r\n\r\n---\r\n\r\n如果希望在React组件内部进行路由、页面跳转，可以借助React-Router提供的 `withRouter(comp)` \r\n之后便可在组件内部通过 `this.props.router` 来进行跳转。但有时候我们希望在组件外部来跳转，\r\n这就需要借助history来实现\r\n```js\r\nimport {browserHistory} from 'react-router'\r\nbrowserHistory.goBack()\r\nbrowserHistory.push()\r\n```\r\n\r\n---\r\n\r\nReact-Router采用动态路由的形式时页面报错 `The root route must render a single element`\r\n可能是因为React组件是采用ES6的 `export default` 导出，\r\n而React-Router是采用CommonJS来 `require` 所以需要在导出的组件后加上 `.default` \r\n类似 `require('components/Comp')).default`\r\n\r\n---\r\n\r\n初学者在 React 中处理事件时会碰到 `this` 指向为 `undefined` 的问题\r\n```js\r\nclass Button extends React.Component {\r\n\thandleClick() {\r\n\t\tconsole.log(this)\r\n\t}\r\n\t\r\n\trender () {\r\n\t\treturn <button onClick=\"this.handleClick\"></button>\r\n\t}\r\n}\r\n```\r\n如果在页面上点击上述组件会发现打印出来的是 `undefined`  \r\n当我们想要在函数中通过 `this.setState()` 去改变组件状态时会报错  \r\n解决这个问题可以通过下面三种方式\r\n```js\r\nclass Button extends React.Component {\r\n\tconstructor() {\r\n\t\t// 借助 Function.prototype.bind\r\n\t\tthis.handleClick = this.handleClick.bind(this)\r\n\t}\r\n\thandleClick() {\r\n\t\tconsole.log(this)\r\n\t}\r\n\t\r\n\trender() {\r\n\t\treturn <button onClick={this.handleClick}></button>\r\n\t}\r\n}\r\n```\r\n```js\r\nclass Button extends React.Component {\r\n\t// 使用 public class fields syntax 来声明函数\r\n\thandleClick = () => {\r\n\t\tconsole.log(this)\r\n\t}\r\n\t\r\n\trender() {\r\n\t\treturn <button onClick={this.handleClick}></button>\r\n\t}\r\n}\r\n```\r\n```js\r\nclass Button extends React.Component {\r\n\thandleClick() {\r\n\t\tconsole.log(this)\r\n\t}\r\n\t\r\n\t// 借助箭头函数\r\n\t// 这种方式的缺点是每次 Button 组件的重绘都需要生成一个新函数\r\n\t// 当这个函数被当作 props 传入子组件时 可能会导致不必要的重绘\r\n\t// 所以更推荐采用先前的俩种方式\r\n\trender() {\r\n\t\treturn <button onClick={e => this.handleClick(e)}></button>\r\n\t}\r\n}\r\n```\r\n"},"./src/memos/vue.md":function(n,r){n.exports="Vue中对进行双向绑定的数据需进行初始化(包括向组件中传递的数据)，否则会导致双向绑定失效\r\n\r\n---\r\n\r\n在Vue中使用Scoped Style时最好采用类选择器或Id选择器，这样会使与属性选择器连用\r\n(PostCSS实现Scoped Style的方式)时造成的性能损失最小\r\n\r\n---\r\n\r\n利用`Webpack`的Code Splitting特性以及Vue的Async Component特性可以很容易的做到按需加载\r\n```js\r\nconst Com = () => import('./my-async-compnent')\r\n```\r\n\r\n---\r\n\r\nVue-Router中路由配置的`redirect`和`alias`区别在于前者会将地址栏到URL重定向到新的而后者不改变URL，\r\n使得不同的URL也可以绘制同样的组件\r\n"},"./src/memos/webpack.md":function(n,r){n.exports="在开启Webpack `devServer` 遇到问题时可以路由至URL `/webpack-dev-server` \r\n来观察打包出来的bundle文件详情来Debug\r\n\r\n---\r\n\r\nWebpack中的 `url-loader` 和 `file-loader` 都是用于打包一些图片字体之类的静态资源文件，\r\n区别在于 `url-loader` 会对一定大小限制内的图片进行Base64编码并采用DataUrl的形式嵌入页面或css，\r\n这些编码后的图片不会占用HTTP请求。但在图片过大的情况下会增加文件的大小，得不偿失，\r\n更适用于处理一些项目中多处用到的小图片（1kb以下）\r\n\r\n---\r\n\r\n关于webpack devServer 的 `historyApiFallback` 在使用 类似 `vue-router` 或 `react-router` 来开发SPA时，\r\n如果将模式设为history模式需要将此项设为 `true` \r\n为了将404的页面请求重定向至index.html以显示相应的404错误提示页面\r\n\r\n---\r\n\r\nwebpack配置中的 `optput.publicPath` 也会同时影响到webpack-dev-server去何处读取静态资源，\r\n如果配置错误会导致页面或静态资源无法加载，页面报错404或 `Cannot get /index.html`\r\n\r\n---\r\n\r\n通过webpack引入相关polyfill时要留意，polyfill需要确保在所有bundle之前引入，\r\n而webpack并不会确保主entry中的\r\n```js\r\nimport xx from xx\r\n```\r\n会按顺序引入，所以需要采取在entry中进行类似\r\n```js\r\napp: ['babel-polyfill', './app.js']\r\n```\r\n这样的形式确保依赖顺序。\r\n详情可参见 `React` 的[Issue](https://github.com/facebook/react/issues/8379)\r\n\r\n---\r\n\r\n`moment`的国际化资源文件很大，所以在生产环境打包时要留意不要将不必要的国际化文件也包含进来\r\n可以通过在webpack生产环境的配置文件中新增如下插件来解决这个问题\r\n```js\r\nplugins: [\r\n\t// 以下的配置会使打包出来的文件只包含简体以及繁体中文的国际化\r\n\tnew webpack.ContextReplacementPlugin(/moment[\\/\\\\]locale$/, /zh-cn|zh-tw/)\r\n]\r\n```\r\n\r\n---\r\n\r\n在使用webpack提供的alias特性时，如果配置了eslint的import/no-unresolved规则  \r\n会发现eslint并不会识别alias，然后当你使用alias时会报错  \r\n这时需要借助[eslint-import-resolver-webpack](https://github.com/benmosher/eslint-plugin-import/tree/master/resolvers/webpack)  \r\n然后再.eslintrc文件中增加配置项  \r\n```js\r\n{\r\n\tsettings: {\r\n\t\t'import/resolver': {\r\n\t\t\twebpack: {\r\n\t\t\t\t// 配置alias的文件路径\r\n\t\t\t\tconfig: './webpack.base.js'\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n---\r\n\r\n关于 Webpack output 配置中的 [hash]/[chunkhash]/[contenthash]  \r\n[hash] 会在每一构建时都重新生成一个唯一的哈希值，会导致所有的静态资源文件都不会被浏览器缓存  \r\n[chunkhash] 会根据不同的 entry 来计算hash值,如果一个 entry 中的文件被修改过则会产生不同的哈希值  \r\n缺点在于假设有一个 Css 以及 JS 文件都来自同一 entry 会导致输出中的这俩个文件名包含的哈希值相同  \r\n也就是说，如果只变动了 Css 文件也会同时影响到 JS 文件的缓存  \r\n[contenthash] 会根据每个输出文件的内容来计算哈希值，只要有过改动则会产生不同的值，推荐使用这个\r\n\r\n---\r\n\r\nWebpack 中 `resolve.extensions` 的默认值为 `['.wasm', '.mjs', '.js', '.json']`  \r\n当我们自定义这个值时，会把默认规则覆盖  \r\n为了确保默认值仍可使用，可以把默认值也加入新定义的规则中  \r\n例如  `['.vue', '.wasm', '.mjs', '.js', '.json']` \r\n\r\n---\r\n\r\n`UslifyJs` 不支持压缩 ES6 的代码，所以当我们想不经过 `Babel` 编译直接压缩混淆 ES6 代码时  \r\n需要使用 [TerserWebpackPlugin](https://webpack.js.org/plugins/terser-webpack-plugin/)  \r\n而不是通常用的 [UglifyjsWebpackPlugin](https://webpack.js.org/plugins/uglifyjs-webpack-plugin/)\r\n"}}]);