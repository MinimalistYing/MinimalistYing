(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{"./src/blogs/ArrayAPI.md":function(r,n){r.exports="# Array's New API In ES6\r\n## Static Function\r\n\r\n### Array.of()\r\n大部分情况下我们都应该优先使用字面量的形式`const a = [1, 2]`来创建一个数组  \r\n但当我们定义了一个自己的Array子类，并且想要创建子类的数组时就只能通过构造器来实例化了\r\n```js\r\nclass MyArr extends Array {\r\n\tmax() {\r\n\t\tlet max = this[0]\r\n\t\tthis.map(item => {\r\n\t\t\tmax = Math.max(item, max)\r\n\t\t})\r\n\t\treturn max\r\n\t}\r\n}\r\n\r\nconst a = new MyArr(1, 2, 3)\r\na.max() // 3\r\n```\r\n一般情况下上例做法也不会有问题，但是当只传入一个参数时就会产生empty slots（可能是因为历史原因？）\r\n```js\r\nconst b = new MyArr(3) // 通过这种方式生成的不是 [3] 而是 [empty * 3]\r\nb.length // 3\r\nb.max() // undefined\r\n```\r\n使用`Array.of()`来实例化新数组可以避免上述问题\r\n```js\r\nconst c = MyArr.of(3) // [3]\r\nc.length // 1\r\nc.max() // 3\r\n```\r\n\r\n### Array.from()\r\n`Array.from`可用于数组的转化，假设我们有一个Array-Like Object\r\n```js\r\nconst o = {\r\n\tlength: 2,\r\n\t0: 'hello',\r\n\t1: 'world'\r\n}\r\n\r\nconst a = Array.from(o)\r\nconst b = Array.prototype.slice.call(o) // 以往的方式\r\n```\r\n可以看到，在ES6中我们可以很方便的将其转化为一个真正的数组，并且不用担心会产生empty slots\r\n```js\r\nconst o = {\r\n\tlength: 2,\r\n\t0: 'hello'\r\n}\r\n\r\nconst a = Array.from(o) // [\"hello\", undefined]\r\nconst b = Array.prototype.slice.call(o) // [\"hello\", empty]\r\n```\r\n该方法的第一个参数可以是任意Iterable的对象，并将其迭代产生的值依次放到一个数组中返回\r\n```js\r\n// 可用于复制数组\r\nconst arr = [1, 2, 3]\r\nconst arrCopy = Array.from(arr) // 更简洁 更易理解\r\nconst arrCopy2 = arr.slice() // 以往的方式\r\n```\r\n该方法的第二个参数可以接受一个函数，并依次对每一个值通过函数处理后再放到结果数组中\r\n```js\r\nconst arr = [1, 2, 3]\r\nconst arrCopy = Array.from(arr, item => item + 1) // [2, 3, 4]\r\n```\r\n\r\n## Prototype Method\r\n\r\n### copyWithin(target, start, end)\r\n该方法可以将数组的一部分复制到该数组特定位置，并覆盖原值  \r\n会直接修改原数组而不是产生一个新数组\r\n```js\r\nlet arr = [1, 2, 3, 4, 5]\r\n// 可以看到不明确提供start和end参数时该方法会从下标0处开始尽可能的拷贝更多的值\r\narr.copyWithin(1) // [1, 1, 2, 3, 4]\r\n\r\narr = [1, 2, 3, 4, 5]\r\narr.copyWithin(1, 0) // [1, 1, 2, 3, 4]\r\n\r\narr = [1, 2, 3, 4, 5]\r\narr.copyWithin(1, 0, 0)  // [1, 2, 3, 4, 5]\r\n\r\narr = [1, 2, 3, 4, 5]\r\narr.copyWithin(1, 0, 1)  // [1, 1, 3, 4, 5]\r\n\r\narr = [1, 2, 3, 4, 5]\r\n// 拷贝过程并不是严格的按照从左到右一个个执行的\r\n// 若果严格按照顺序执行的话，程序的结果应该是[1, 2, 2, 2, 2]\r\n// 可以假定执行过程如下\r\n// [1, 2, 2, 4, 5]\r\n// [1, 2, 2, 2, 5]\r\n// [1, 2, 2, 2, 2]\r\narr.copyWithin(2, 1) // [1, 2, 2, 3, 4]\r\n```\r\n### fill(value, start, end)\r\n该方法可以向数组中的指定位置填充值\r\n```js\r\n// 未明确指定start和end时会尽可能的填充更多的值\r\nnew Array(3).fill('hello') // ['hello', 'hello', 'hello']\r\n[null, null, null].fill('hello', 1) // [null, 'hello', 'hello']\r\n[null, null, null].fill('hello', 1, 2) // [null, 'hello', null]\r\n```\r\n\r\n### find()\r\n以往我们想要判断数组中是否包含某个元素通常是借助`indexOf()`\r\n```js\r\nconst arr = [1, '2', {name: 'hello'}]\r\narr.indexOf(1) !== -1 // true\r\narr.indexOf('2') !== -1 // true\r\narr.indexOf(2) !== -1 // false\r\n```\r\n这种方法有几个缺点:\r\n* 通过严格的===来比较\r\n* 需要通过判断是否等于-1来得出我们要的布尔值结果\r\n* 不能实现自定义的匹配条件\r\n\r\nES5中新增的`some()`解决了上述问题\r\nPS: 当我们不需要自定义匹配条件，想利用全等来比较时  \r\n可以采用ES7新增的更便捷的方法`Array.prototype.includes()`\r\n```js\r\nconst arr = [1, '2', {name: 'hello'}]\r\narr.some(v => v == 2) // true\r\narr.some(v => v.name === 'hello') // true\r\n\r\narr.includes(1) // true\r\n```\r\n大部分情况下这种方法都没有问题，但当我们想要直接获得正确匹配到的值  \r\n这时候就可以借助ES6的`find()`\r\n```js\r\nconst arr = [1, '2', {name: 'hello'}]\r\narr.find(v => v == 2) // '2'\r\narr.find(v => v,name === 'hello') // {name: 'hello'}\r\narr.find(v => v === 666) // undefined\r\n```\r\n\r\n### findIndex()\r\n总结一下上述数组的查找方法，可以发现，当我们只想确定是否存在特定值时可以采用`some()`  \r\n当我们想拿到符合比较条件的值时可以采用`find()`  \r\n如果我们想要拿到符合比较条件值的下标时就需要用到ES6的`findIndex()`\r\n```js\r\nconst arr = [1, '2', {name: 'hello'}]\r\narr.findIndex(v => v == 2) // 1\r\narr.findIndex(v => v,name === 'hello') // 2\r\narr.findIndex(v => v === 666) // -1\r\n```\r\n不难发现该方法和`indexOf()`的差别仅在于可以自定义匹配条件\r\n\r\n### entries() values() keys()\r\n类似`Map` `Set`等ES6新增的Collections，Array也提供了一系列的借助Iterator的迭代方法\r\n```js\r\nconst arr = [1, 2, 3]\r\n[...arr.values()] // [1, 2, 3]\r\n[...arr.entries()] // [[0, 1], [1, 2], [2, 3]]\r\n[...arr.keys()] // [0, 1, 2]\r\n```\r\n"},"./src/blogs/Collections.md":function(r,n){r.exports="# New Collections In ES6\r\n\r\n## Map\r\n以往当我们需要一种键/值对形式的数据结构时通常使用的是原生的Object\r\n```js\r\nconst o = {}\r\no[1] = 1\r\no['a'] = 'a'\r\nconsole.log(o) // { 1: 1, a: 'a'}\r\no['1'] = 2\r\nconsole.log(o) // {1: 2, a: 'a'}\r\n\r\nconst map = {}\r\nconst x = { a: 1 }\r\nconst y = { b: 2 }\r\nmap[x] = 1\r\nmap[y] = 2\r\n// 因为x.toString() === '[object Object]'\r\nconsole.log(map) // {[object Object]: 2}\r\n```\r\n可以看到这种方法有一个缺陷，由于Object的Key只能是字符串  \r\n这样生成的Map同样只能以字符串作为键  \r\nES6提供了对Map的原生支持，它可以将任何数据类型作为Key\r\n```js\r\nconst map = new Map()\r\nconst x = { a: 1 }\r\n// 支持链式调用\r\nmap.set(x, 1).set(2, 2).set('2', 2)\r\n\t.set(Symbol.for('sym'), 'symbol').set(true, true)\r\n\r\nmap.get(x) // 1\r\nmap.get(2) // 2\r\nmap.get('2') // 2\r\nmap.get(Symbol.for('sym')) // 'symbol'\r\nmap.get(true) // true\r\n\r\nmap.size // 5\r\n\r\nmap.delete(true)\r\nmap.delete(x)\r\nmap.delete('2')\r\n\r\nmap.size // 2\r\n\r\nmap.has(2) // true\r\nmap.has(Symbol.for('sym')) // true\r\n\r\n[...map.keys()] // [2, Symbol(sym)]\r\n[...map.values()] // [2, \"symbol\"]\r\n[...map.entries()] // [[2, 2], [Symbol(sym), \"symbol\"]]\r\n\r\nmap.clear()\r\nmap.size // 0\r\n```\r\nMap的实例是Iterable的，并且其默认的Iterator与`map.entries()`一致  \r\n所以以下方法都可以用于拷贝产生一个新的Map\r\n```js\r\nconst map = new Map()\r\nconst copy2 = new Map(map.entries())\r\nconst copy1 = new Map(map) // 推荐 更简洁\r\n```\r\n\r\n## WeakMap\r\nWeakMap的大部分行为与Map一致，主要区别在于WeakMap对内存分配机制的特殊处理  \r\nWeakMap的Key只能是Object，并且当作为Key的Object被GC回收后  \r\n其存储在WeakMap中的Entry也会随之被销毁  \r\nWeakMap相较Map而言只提供了`set()` `get()` `delete()` `has()` 四个有限的API  \r\n尤其适用于需要把不受我们控制的对象(例如DOM对象)作为Key值的情况\r\n\r\n## Set\r\nES6新增的Set用于存储一系列不重复的值  \r\n其判断是否重复的规则除了Set会认为+0等与-0外都与`Object.is()`相同\r\n```js\r\nconst set = new Set()\r\nconst x = { a: 1 }\r\nconst y = { b: 2 }\r\n// 支持链式调用\r\nset.add(x).add(y).add(x)\r\n\r\nset.size // 2\r\n\r\nset.delete(y)\r\nset.size // 1\r\n\r\nset.has(x) // true\r\nset.clear()\r\nset.size // 0\r\n\r\nset.add(1).add('1').add(2);\r\n[...set.keys()] // [1, \"1\", 2]\r\n[...set.values()] // [1, \"1\", 2]\r\n[...set.entries()] // [[1, 1], [\"1\", \"1\"], [2, 2]]\r\n```\r\n与Map不同的是Set实例的默认Iterator与`values()`相同  \r\n可以利用Set来进行数组去重\r\n```js\r\nconst arr = [1, 1, 2, 3, 3, 4, '4']\r\nconst unique = [...new Set(arr)]\r\nconsole.log(unique) // [1, 2, 3, 4, \"4\"]\r\n```\r\n\r\n## WeakSet\r\n同WeakMap类似，WeakSet中存储的值只能是Object\r\n并且当Object被GC后WeakSet也会自动将其从集合中删除\r\n"},"./src/blogs/Generator.md":function(r,n){r.exports="# Generator in ES6\r\n## 序\r\nGenerator不同于一般的函数，它可以在执行过程中被暂停然后在稍后的任意时刻恢复执行，并且在过程中可以与外界双向传递数据\r\n\r\n## 如何写一个最简单的Generator\r\n```js\r\nfunction *foo() {\r\n\treturn 'hello'\r\n}\r\n\r\nconst it = foo()\r\nit.next() // { value: 'hello', done: true}\r\n```\r\n与普通函数的不同的是调用一个Generator并不会立即执行函数体，而是返回一个Iterator来控制这个Generator的执行\r\n\r\n## 如何写一个有意义的Generator\r\n上例中的Generator并没有特殊的意义，因为它中间并没有暂停的步骤，若想让一个Generator可以中断需要使用ES6新引入的关键字`yield`\r\n```js\r\nfunction *foo() {\r\n\tconst a = yield 'hello'\r\n\tconsole.log(a)\r\n\t\r\n\tconst b = yield 'world'\r\n\tconsole.log(b)\r\n\t\r\n\treturn 'finish'\r\n}\r\n```\r\n下面来依次执行上述Generator，看看每一步的结果\r\n```js\r\nconst it = foo() // 获得Iterator\r\nit.next('step 1')\r\n// {value: \"hello\", done: false}\r\n```\r\n初次执行，代码会停在`const a = yield 'hello'`处，hello作为返回值被抛到函数外\r\n\r\n需要注意的是这里通过`next()`传入的值不会被函数接受，因为**yield**将自身替换为外部传入值的时机是在代码恢复执行时\r\n```js\r\nit.next('step 2')\r\n// 'step 2'\r\n// {value: \"world\", done: false}\r\n```\r\n第二次执行，代码会停在`const b = yield 'world'`处，我们在`next()`中传入的`'step2'`被赋值给变量`a`\r\n\r\n可以看做`yield 'hello'`被替换成了`'step2'`，world作为返回值被抛出\r\n```js\r\nit.next('step 3')\r\n// 'step 3'\r\n// {value: \"finish\", done: true}\r\n```\r\n最后一次执行，`'step3'`被赋值给变量`b`，Generator执行完毕，finish作为返回值被抛出\r\n\r\n## `yield *`\r\n**yield delegation**可以把当前Generator的控制委派给另一个Iterator  \r\n```js\r\nfunction *foo() {\r\n\tyield *[1, 2, 3]\r\n}\r\nfor (v of foo()) {\r\n\tconsole.log(v) // 1 2 3\r\n}\r\n```\r\n"},"./src/blogs/GulpPlugin.md":function(r,n){r.exports='# 如何编写一个自己的GulpPlugin\r\n\r\n```\r\nconst through = require("through-gulp"),\r\n\tfs = require("fs")\r\n\r\nfunction myPlugin() {\r\n\treturn through(function(file, encoding, callback) {\r\n\t\tlet result, origin\r\n\t\t\r\n\t\t// 传入的文件为空\r\n\t\tif (file.isNull()) {\r\n\t\t\tthrow "Please Check Files!"\r\n\t\t}\r\n\r\n\t\t// buffer对象可以直接操作\r\n\t\tif (file.isBuffer()) {\r\n\t\t\t//拿到单个文件buffer             \r\n\t\t\tfile.contents = new Buffer(file.contents.toString("utf-8"),"utf-8")\r\n\t\t}\r\n\t\t \r\n\t\t// stream流是不能操作的,可以通过fs.readFileSync\r\n\t\tif (file.isStream()) {\r\n\t\t\t// 同步读取\r\n\t\t\tfile.contents = new Buffer(s.readFileSync(file.path).toString("utf-8"),"utf-8")\r\n\t\t}\r\n\r\n\t\torigin = file.contents.toString("utf-8") // 转化为字符串\r\n\t\tresult = doYourPluginWork(origin) // 处理源文件 实现插件的逻辑\r\n\t\tfile.contents = new Buffer(result) // 将源文件的内容替换为插件处理完之后的内容\r\n\r\n\t\tthis.push(file)\r\n\t\tcallback() // 声明文件已处理完毕\r\n\t}, function(callback) {\r\n\t\tcallback() // 声明文件已处理完毕\r\n\t})\r\n}\r\n\r\nmodule.exports = myPlugin\r\n```\r\n'},"./src/blogs/Iterator.md":function(r,n){r.exports="# Iterator in ES6\r\n## Iterator 与 Iterable\r\nIterator可以看做一个拥有特定格式的对象，可供ES6提供的遍历->`for of`和解构->`...`等操作消费，并按顺序依次产出结果，样例如下\r\n```js\r\n// 除了以下俩个值外也可以额外返回更多的自定义属性\r\nconst IteratorResult = {\r\n\tvalue: ..., // 每次迭代产出的真实值\r\n\tdone: ..., // true|false true代表迭代结束 与true相对应的value一般建议为undefined\r\n}\r\n\r\nconst Iterator = {\r\n\t// 必须 用于返回每次迭代的结果集\r\n\tnext() { return IteratorResult},\r\n\t// 可选 提前结束迭代时做相应的资源清理操作并返回最后的结果集\r\n\treturn() {},\r\n\t// 可选 抛出异常信息并返回最后的结果集\r\n\tthrow() {}\r\n}\r\n```\r\n而Iterable则是指一个对象实现了Iterable接口(简单来说就是对象上有一个key为Symbol.iterator的方法并且这个方法会生成一个Iterator)\r\n```js\r\nconst Iterable = {\r\n\t[Symbol.iterator]() {return Iterator}\r\n}\r\n```\r\n\r\n## 如何构造一个简单的Iterable对象\r\n```js\r\nlet rand = Math.random()\r\n// 会随机产生一串数字的Iterable对象\r\nconst iterable = {\r\n\t// 必备!!! 这样才能使该对象变为Iterable\r\n\t[Symbol.iterator]() {return this},\r\n\t// 依次去获取数据\r\n\tnext() {\r\n\t\tif (rand > 0.5) {\r\n\t\t\trand = Math.random()\r\n\t\t\treturn {\r\n\t\t\t\tvalue: rand,\r\n\t\t\t\tdone: false\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\tdone: true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n// 该对象可以用for of遍历\r\nfor (let value of iterable) {\r\n\tconsole.log(value)\r\n}\r\n```\r\n\r\n## 如何构造一个完整的Iterable对象\r\n```js\r\n// 该对象可以步进的产生对数据的每一步累加结果\r\nconst stepAccumulator = {\r\n\t[Symbol.iterator]() {\r\n\t\tlet sum = 0\r\n\t\tlet index = 0\r\n\t\tconst data = this.data.slice()\r\n\t\tlet done = false\r\n\t\treturn {\r\n\t\t\t// 使迭代器(Iterator)本身可迭代(Iterable)\r\n\t\t\t[Symbol.iterator]() { return this },\r\n\t\t\tnext() {\r\n\t\t\t\tconst value = sum += data[index]\r\n\t\t\t\tindex++\r\n\t\t\t\tif (index <= data.length && !done) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tvalue,\r\n\t\t\t\t\t\tdone: false\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdone: true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\treturn(v) {\r\n\t\t\t\tconsole.log('abandoned')\r\n\t\t\t\tdone = true\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: v,\r\n\t\t\t\t\tdone: true\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tthrow(e) {\r\n\t\t\t\tconsole.log('error')\r\n\t\t\t\tdone = true\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: e,\r\n\t\t\t\t\tdone: true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tdata: []\r\n}\r\n// 设置数据\r\nstepAccumulator.data = [1, 2, 3]\r\nconsole.log(...stepAccumulator) // 1 3 6\r\n\r\n// 1 3 'abandoned'\r\nfor (let v of stepAccumulator) {\r\n\tconsole.log(v)\r\n\tif (v > 1) break\r\n}\r\n\r\nconst it = stepAccumulator[Symbol.iterator]()\r\nit.next() // { value:1, done: false }\r\nit.throw('!!!') // 'error' { vallue:'!!!', done: true }\r\nit.next() // { done: true }\r\n```\r\n* `return()`和`throw()`都可以通过**Iterator**调用，并且通常来说在调用过后便不应该能通过该迭代器获取到更多的值\r\n* 一般来说**Iterable**对象可以同时生成多个**Iterator**，且相互间的迭代不会互相影响，当然你也可以把迭代器设为单例\r\n* 任何一种取消或者提前终止迭代的行为都会使得**Iterator**自动调用`return()`来处理相关的清理工作\r\n\r\n## ES6自带的Iterable数据结构\r\n包括`String` `Map` `Set` `Array`等\r\n```js\r\nconst str = 'abc'\r\nconst arr = [1, 2, 3]\r\nconst map = new Map()\r\nmap.set('a', 1)\r\nmap.set('b', 2)\r\nfor (let v of str) {\r\n\tconsole.log(v) // 'a' 'b' 'c'\r\n}\r\nfor (let v of arr) {\r\n\tconsole.log(v) // 1 2 3\r\n}\r\nfor (let v of map) {\r\n\tconsole.log(v) // ['a', 1] ['b', 2]\r\n}\r\n```\r\n"},"./src/blogs/ObjectAPI.md":function(r,n){r.exports="## Object's New API In ES6\r\n\r\n### Object.is()\r\n该方法用于比较俩个值是否相等，基本的比较逻辑与`===`一致但是更加严格\r\n```js\r\nconst x = NaN\r\nconst y = 0\r\nconst z = -0\r\n\r\nx === x // false\r\nObject.is(x, x) // true\r\ny === z // true\r\nObject.is(y, z) // false\r\n```\r\n当不需要考虑这几种特殊情况时，直接用`===`比较更方便\r\n\r\n### Object.getOwnPropertySymbols()\r\nES6新增的`Symbol`可以作为对象上的特殊属性使用  \r\n有时我们可能希望只获得一个对象上的所有`Symbol`属性，排除其他普通属性  \r\n这个时候就可以借助该方法\r\n```js\r\nconst o = {\r\n\tfoo: 'hello',\r\n\t[ Symbol('bar') ]: 'world'\r\n}\r\n\r\nconst symbols = Object.getOwnPropertySymbols(o) // [Symbol(bar)]\r\no[symbols[0]] // 'world'\r\n```\r\n\r\n### Object.setPrototypeOf()\r\n该方法提供了一种更优雅的方式来修改一个对象的原型\r\n```js\r\nconst o1 = {\r\n\tbar: 1\r\n}\r\nconst o2 = {\r\n\tfoo: 2\r\n}\r\n\r\nObject.setPrototypeOf(o1, o2)\r\no1.foo // 2\r\no1.__proto__ === o2 // true\r\n\r\n// 将o1设置为无原型对象 类似 const o = Object.create(null)\r\n// 这种做法通常是为了获得一个纯净的对象来作为Map使用\r\n// 现在ES6新增了原生的Map结构 可以考虑避免使用这种技巧\r\nObject.setPrototypeOf(o1, null)\r\no1.__proto__ // undefined\r\n```\r\n\r\n### Object.assign()\r\n由于React/Vue/Angular等数据驱动的前端框架的流行  \r\n这个方法在平常项目中使用频率很高，用于将一系列对象中的值复制到目标对象中  \r\n并且会对各对象相同key的(enumerable)值按先后顺序进行覆盖\r\n```js\r\nlet o1 = { a: 1 }\r\nlet o2 = { b: 2 }\r\n\r\nObject.assign({}, o1, o2) // { a: 1, b: 2 }\r\n\r\nObject.defineProperty(o2, 'c', {\r\n\tvalue: 3,\r\n\tenumerable: false\r\n})\r\n\r\nObject.defineProperty(o2, 'd', {\r\n\tvalue: 4,\r\n\tenumerable: true\r\n})\r\n\r\n// 可以看到 enumerable为false的属性不会被拷贝\r\nObject.assign({}, o1, o2) // { a: 1, b: 2, d: 4}\r\n\r\no2[Symbol('bar')] = 5\r\n// Symbol属性也会被拷贝\r\nObject.assign({}, o1, o2) // { a: 1, b: 2, d: 4, Symbol(bar): 5}\r\n```\r\n值得注意的是，该方法的拷贝过程是浅拷贝  \r\n类似于对每个属性进行`target = src`的赋值  \r\n所以碰到数组、对象之类的复杂数据结构时要多加小心\r\n"},"./src/blogs/PreventModalScroll.md":function(r,n){r.exports="# 如何阻止模态框(Modal/Popup/Dialog)弹出后body可滚动\r\n\r\n## 序\r\n\r\n当模态框的遮罩层为透明时，鼠标或手指在模态框内容区进行操作  \r\n此时如果被遮罩层挡住的Body内容仍会滚动会造成视觉上的干扰  \r\n为了最佳的用户体验，我们需要想办法禁止这种默认的行为\r\n\r\n## 设置Body的样式`overflow: hidden`\r\n在模态框弹出时通过\r\n```js\r\n// 弹出\r\ndocument.body.style.overflow = 'hidden'\r\n// 关闭\r\ndocument.body.style.overflow = 'initial'\r\n```\r\n修改`<body>`的样式使得滚动条消失，Bootstrap的Modal采取的就是这种方式  \r\n缺点在于滚动条消失会导致页面向右偏移约20px，以填充滚动条消失的空白  \r\n在PC端会有比较明显的感觉，对用户体验还是稍有影响  \r\n另外移动端的大多浏览器对给`<body>`设置`overflow: hidden`并不感冒  \r\n绝大多数情况下这种方式在移动端不起作用(亲测ios chrome下无效)\r\n\r\n## 通过Javascript禁止滚动事件的默认行为\r\n```js\r\nfunction preventScroll(e) {\r\n\te.preventDefault()\r\n}\r\n\r\n// 弹出\r\n// { passive: false }是因为Chrome对相应事件做了优化 如果不设置会导致页面报错\r\n// Unable to preventDefault inside passive event listener due to target being treated as passive. \r\n// See https://www.chromestatus.com/features/5093566007214080\r\ndocument.body.addEventListener('mousewheel', preventScroll, { passive: false })\r\ndocument.body.addEventListener('touchmove', preventScroll, { passive: false })\r\n\r\n// 关闭\r\ndocument.body.removeEventListener('mousewheel', preventScroll)\r\ndocument.body.removeEventListener('touchmove', preventScroll)\r\n```\r\n如果模态框的内容区中没有可滚动的元素，那么这个方案是可行的  \r\n如果有的话会发现内容区中元素的滚动也被一并禁止了\r\n\r\n## 进一步优化方案\r\n由于我们不想禁止掉所有元素的滚动，可以考虑在需要滚动的元素上加一个特定类  \r\n当触发事件的元素是该允许滚动的元素或者其子元素时，不去preventDefault\r\n```js\r\nfunction preventScroll(e) {\r\n\t// 只有容器中类名包含scroll-able的元素以及子元素允许滚动\r\n\tif (!e.path.find(dom => dom.classList && dom.classList.contains('scroll-able'))) {\r\n\t\te.preventDefault()\r\n\t\te.stopPropagation()\r\n\t}\r\n}\r\n```\r\n"},"./src/blogs/Promise.md":function(r,n){r.exports="# Promise In ES6\r\n\r\n## 序\r\n以往我们通常用回调函数来处理异步编程\r\n当嵌套过深时便会使程序的可读性很差（Callback Hell）\r\n```js\r\nfunction foo(cb) {\r\n\tasyncFunc1(() => {\r\n\t\tcb()\r\n\t\tasyncFunc2(() => {\r\n\t\t\tcb()\r\n\t\t\tasyncFun3(() => {\r\n\t\t\t\tcb()\r\n\t\t\t})\r\n\t\t})\r\n\t})\r\n}\r\n```\r\nES6新增的Promise提供了一种更优雅的方式来处理异步编程\r\n\r\n## 如何构造一个基础的Promise\r\n```js\r\nconst p = new Promise((resolve, reject) => {\r\n\tconst rand = Math.random()\r\n\tsetTimeout(() => {\r\n\t\tif (rand > 0.5) {\r\n\t\t\tresolve('finish')\r\n\t\t} else {\r\n\t\t\treject('err')\r\n\t\t}\r\n\t}, 3000)\r\n})\r\n\r\n// 在3秒后输出'finish' or 'err'\r\np.then(res => console.log(res))\r\n.catch(err => console.log(err))\r\n\r\n// 同上\r\np.then(res => console.log(res), err => console.log(err))\r\n```\r\n一个Promise最终只会有俩个状态**fulfilled**或者**rejected**  \r\n前者可以在`then()`的第一个参数中获得处理完成的结果  \r\n后者可以在`then()`的第二个参数或者`catch()`中获得处理失败的原因  \r\n每一个Promise只会被resolve(fulfill 或者 reject)一次  \r\n并且一旦一个Promise执行完毕，它就成为了一个不可变的值  \r\n\r\n## Promise是如何避免Callback Hell的\r\n```js\r\nfunction asyncFunc1() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('1 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nfunction asyncFunc2() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('2 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nfunction asyncFunc3() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('3 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nasyncFunc1().then(res => {\r\n\tconsole.log(res)\r\n\treturn asyncFunc2()\r\n}).then(res => {\r\n\tconsole.log(res)\r\n\treturn asyncFunc3()\r\n}).then(res => {\r\n\tconsole.log(res)\r\n})\r\n// 3s后 \"1 done\"\r\n// 再3s后 \"2 done\"\r\n// 再3s后 \"3 done\"\r\n```\r\n通过上例可以看出，正确的使用Promise可以使得我们程序中的异步流程更为清晰  \r\n可以说完美的避开了Callback Hell\r\n\r\n## Promise API\r\n\r\n### Promise.resolve() 和 Promise.reject()\r\n```js\r\nconst p1 = Promise.resolve(1)\r\nconst p2 = new Promise(resolve => resolve(1))\r\n\r\nconst p3 = Promise.reject(1)\r\nconst p4 = new Promise((resolve, reject) => reject(1))\r\n```\r\n可以通过`Promise.resolve()`将thenable对象转为真正的Promise对象  \r\n如果你以前用了类似Promise语法的异步处理库  \r\n现在想将其行为转成和Promise一致时可能会用到\r\n\r\n### Promise.all([...])\r\n该方法的入参是一个包含多个Promise对象的数组  \r\n它会等到其中所有的Promise处理完成(fulfilled)后将结果集返回  \r\n或者其中任意一个Promise处理失败(rejected)后将错误抛出\r\n```js\r\nconst p1 = 1\r\nconst p2 = Promise.resolve(2)\r\nconst p3 = new Promise((resolve, reject) => {\r\n\tsetTimeout(() => {\r\n\t\tresolve(3)\r\n\t}, 3000)\r\n})\r\n\r\n// 3s后输出 [1, 2, 3]\r\nPromise.all([p1, p2, p3]).then(res => console.log(res))\r\n\r\nconst e1 = new Promise((resolve, reject) => {\r\n\tsetTimeout(() => {\r\n\t\treject('err')\r\n\t}, 1000)\r\n})\r\n\r\n// 1s后输出 \"err\"\r\nPromise.all([p1, p2, p3, e1])\r\n.then(res => console.log(res))\r\n.catch(err => console.log(err))\r\n```\r\n\r\n### Promise.race([...])\r\n与`Promise.all()`不同，该方法只会取入参中所有Promise中最快返回的结果  \r\n不管是接受(resolve)或是拒绝(reject)  \r\n其余Promise的处理结果都会被忽略\r\n```js\r\nconst p1 = new Promise((resolve, reject) => {\r\n\tsetTimeout(() => {\r\n\t\tresolve(1)\r\n\t}, 1000)\r\n})\r\nconst p2 = new Promise((resolve, reject) => {\r\n\tsetTimeout(() => {\r\n\t\tresolve(2)\r\n\t}, 2000)\r\n})\r\n// 1s后输出 1\r\n// 无论执行多少遍都是该结果 永远不会输出2\r\nPromise.race([p1, p2]).then(res => console.log(res))\r\n```\r\n要注意的是当传入空数组时`Promise.all([])`会立即执行完毕  \r\n而`Promise.race([])`会永远处于等待状态，所以建议永远别这么使用Promise\r\n\r\n## `async` + `await` （ES7）\r\n当ES6的Generator与Promise异步编程共同使用时可以产生一些更酷的特性  \r\n让我们能够像写同步代码一样去实现异步过程  \r\n但是需要实现一个特殊的Runner来执行这个Generator  \r\nES7新增了语法糖`async`以及`await`来帮助我们更迅速的实现这一特性\r\n```js\r\nfunction asyncFunc1() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('1 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nfunction asyncFunc2() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('2 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nfunction asyncFunc3() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('3 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nasync function main() {\r\n\tconst res1 = await asyncFunc1()\r\n\tconsole.log(res1)\r\n\tconst res2 = await asyncFunc2()\r\n\tconsole.log(res2)\r\n\tconst res3 = await asyncFunc3()\r\n\tconsole.log(res3)\r\n}\r\n\r\n// 3s后 \"1 done\"\r\n// 再3s后 \"2 done\"\r\n// 再3s后 \"3 done\"\r\nmain()\r\n```\r\n可以看到，相较于`Promise.then(...).then(...)`  \r\n这种方式让异步程序的执行过程更加一目了然\r\n需要注意的一点是`await`只能出现在`async`函数中  \r\n也就是说直接出现在最外层代码中的`const res = await fetch('xxx')`是错误的  \r\n除此之外，`await`也可以和`Promise.all()`一起使用\r\n```js\r\nasync function test() {\r\n\tconst allRes = await Promise.all([\r\n\t\tfetch('aaa'),\r\n\t\tfetch('bbb')\r\n\t])\r\n}\r\n```\r\n"},"./src/blogs/ReactRedux.md":function(r,n){r.exports="# React-Redux 从入门到后悔\r\n\r\n## 序\r\nRedux作为一个简单的用于管理应用状态的工具，可以与任何其它的前端框架共用  \r\n当然，尤其适用于数据驱动视图的框架(Vue/React/Angular)  \r\n为了避免让我们自己将Redux的Store一层一层往子组件传递  \r\n然后在一遍遍通过subscribe来监听Store的变化并去修改组件的状态  \r\nReact-Redux利用高阶组件(HOC)  \r\n将上述逻辑封装到了`<Provider>`以及`connect()`俩个简单的API中  \r\n当开发者想在React中使用Redux时，React-Redux将会是必不可少的帮手\r\n\r\n## How to use\r\n首先，用Redux提供的`<Provider>`包裹根组件\r\n```js\r\n// 新建Redux的Store\r\nconst store = createStore(reducers)\r\n\r\nReactDOM.render(\r\n\t<Provider store={store}>\r\n\t\t<App />\r\n\t</Provider>,\r\n\tdocument.getElementById('root')\r\n)\r\n```\r\n然后通过\r\n```js\r\nconnect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])(Comp)\r\n```\r\n这样就能得到注入Redux后的新组件  \r\n如果不传入`mapStateToProps`，则不会在该组件中去监听`store`的变化  \r\n如果不传入`mapDispatchToProps`，则默认只将`dipatch`注入组件  \r\n```js\r\nexport default connect()(Comp)\r\n```\r\n将`dispatch`注入组件  \r\n这样在组件中就可以通过`this.props.dispatch(action)`来修改Redux的`store`  \r\n但不会去监听`store`的变化\r\n```js\r\nexport default connect(state => state)(Comp)\r\n```\r\n监听所有`store`的的变化，并注入`dispatch`  \r\n不建议这么做，会降低程序的效率\r\n```js\r\nconst mapStateToProps = (state, ownProps) => {\r\n\treturn { all: state.total + ownProps.total }\r\n}\r\nexport default connect(mapStateToProps)(Comp)\r\n```\r\n注入`all`以及`dispatch`，并且监听`store`的变化  \r\n当`store`中的`total`或者组件自身的`total`发生变化时都会重绘组件\r\n```js\r\nconst mapDispatchToProps = dispatch => {\r\n\treturn {\r\n\t\taddTodo: todo => dispatch(todoActionCreator(todo))\r\n\t\t// 可以在此处借助bindActionCreators\r\n\t\t// addTodo: bindActionCreators(todoActionCreator, dispatch)\r\n\t}\r\n}\r\nexport default connect(null, mapDispatchToProps)(Comp)\r\n```\r\n不监听`store`  \r\n在组件中可以通过调用`this.props.addTodo('xx')`来改变应用状态\r\n\r\n## 源码中学习到的小技巧\r\nReact-Redux 默认通过以下方法来比较组件的Props是否相等  \r\n如果不等则意味着组件需要进行重绘\r\n```js\r\n// 通过hasOwn.call(xx, xx)\r\n// 相较于xx.hasOwnProperty(xx) 更简洁？\r\nconst hasOwn = Object.prototype.hasOwnProperty\r\n\r\n// Object.is()的Polyfill\r\nfunction is(x, y) {\r\n\tif (x === y) {\r\n\t\t// Object.is(0, -0) => false\r\n\t\treturn x !== 0 || y !== 0 || 1 / x === 1 / y \r\n\t} else {\r\n\t\t// Object.is(NaN, NaN) => true\r\n\t\treturn x !== x && y !== y\r\n\t}\r\n}\r\n\r\nexport default function shallowEqual(a, b) {\r\n\tif (is(a, b)) return true\r\n\t\r\n\t// 如果a或者b不是object 并且Object.is(a, b) => false\r\n\t// 则认为a和b不等\r\n\tif (typeof a !== 'object' || a === null ||\r\n\t\ttypeof b !== 'object' || b === null\r\n\t) {\r\n\t\treturn false\r\n\t}\r\n\t\r\n\tconst keysA = Object.keys(a)\r\n\tconst keysB = Object.keys(b)\r\n\t\r\n\t// 在a和b都是object的情况下\r\n\t// 如果a与b的所有key值相同 并且与之对应的value都满足Object.is(v1, v2) => true\r\n\t// 则也认为a和b相等\r\n\tif (keysA.length !== keysB.length) return false\r\n\tfor (let i = 0; i < keysA.length; i++) {\r\n\t\tif (!hasOwn.call(b, keysA[i]) ||\r\n\t\t\t!is(objA[keysA[i]], objB[keysA[i]])\r\n\t\t) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn true\r\n}\r\n```\r\n\r\n*********\r\n\r\nReact的PropTypes除了进行如下的基础校验\r\n```js\r\nnumber string object bool func\r\narray\r\nsymbol\r\nnode // 任何可以被当作节点绘制的类型\r\nelement // React Element\r\n```\r\n还可以利用相关API进行更严格的格式校验\r\n```js\r\nMyComponent.propTypes = {\r\n\t// 指定值中的其中一个 类似枚举类型\r\n\txx: PropTypes.oneOf(['News', 'Photos']),\r\n\t// 特定实例\r\n\txx: PropTypes.instanceOf(Foo),\r\n\t// 多种可选基础类型\r\n\txx: PropTypes.oneOfType([\r\n\t\tPropTypes.string,\r\n\t\tPropTypes.number\r\n\t]),\r\n\t// 只包含特定类型值的数组\r\n\txx: PropTypes.arrayOf(PropTypes.number),\r\n\t// 只包含特定类型值的对象\r\n\txx: PropTypes.objectOf(PropTypes.number),\r\n\t// 必须包含指定属性的对象\r\n\txx: PropTypes.shape({\r\n\t\txx: PropTypes.number,\r\n\t\tyy: PropTypes.bool.isRequired\r\n\t}),\r\n\t// 只能包含指定属性的对象\r\n\txx: PropTypes.exact({\r\n\t\txx: PropTypes.number,\r\n\t\tyy: PropTypes.bool.isRequired\r\n\t}),\r\n\t// 任意值\r\n\txx: PropTypes.any.isRequired\r\n}\r\n```\r\n\r\n*********\r\n\r\nReact 的高阶组件(HOC)并不会自动将被包裹组件的静态方法自动继承到新返回的组件中  \r\n会导致以下问题\r\n```js\r\nWrappedComponent.staticMethod = () => {}\r\n\r\nconst EnhancedComponent = HOC(WrappedComponent)\r\nEnhancedComponent.staticMethod // => undefined\r\n```\r\n可以借助[hoist-non-react-statics](https://github.com/mridgway/hoist-non-react-statics)来解决这个问题\r\n```js\r\nimport hoistNonReactStatic from 'hoist-non-react-statics'\r\n\r\nconst EnhancedComponent = hoistNonReactStatic(HOC(WrappedComponent), WrappedComponent)\r\nEnhancedComponent.staticMethod // => () => {}\r\n```\r\n"},"./src/blogs/Redux.md":function(r,n){r.exports="# Redux从入门到放弃\r\n\r\n## 基本概念\r\n前端应用日渐复杂，传统的JavaScipt+HTML+CSS三大件变得难以应对  \r\n近几年出现的各类MVVM框架(React/Vue/Angular)使我们可以开发管理更复杂的单页应用(SPA)  \r\n随之而来碰到的问题是对应用中各种状态的管理  \r\n每个组件都有各自的状态，当任意一个组件的状态发生变更，同时也可能需要触发另一个组件状态的变更  \r\n当这种耦合关系越来越多的时候，我们会发现很难去寻找一个状态发生变更的原有  \r\n并且当组件层级过深时，一层层的在组件间传递props也显得颇为繁琐  \r\nRedux的出现给开发者提供了一种更加规范的管理前端应用状态的解决方案  \r\n当然相应的代价是需要引入更冗余的语法(boilerplate)  \r\nRedux通过以下三个原则来更好的管理应用的状态:  \r\n* Single source of truth: Redux应用中的状态应该是全局唯一的  \r\n也就是说每个Redux应用应该只有一个全局唯一的Store\r\n* State is read-only: Store中存储的状态不能被直接修改  \r\n只能通过Dispatch Action来进行应用状态的变更  \r\n这样通过一些工具开发者可以很清楚的看到状态发生变更的时机以及每次所发生的改变  \r\n甚至进行Time Travel来回到某个Action执行前的状态  \r\n亦或是再次重新提交这个Action来观察其行为对应用的影响  \r\n* Changes are made with pure functions: Reducer只能是Pure Function  \r\n不能在其中直接修改Store中存储的值  \r\n而是依据Dispatch的不同Actions返回新的状态  \r\n\r\n### Actions\r\n不同于直接去修改应用的状态，例如react中的`this.setState()`  \r\nRedux推崇通过Dispacth Action来修改状态  \r\nAction是一个携带了操作类型以及具体改变数据的简单对象(Plain Object)  \r\n```js\r\nconst action = {\r\n\t// 操作类型 用于描述该次操作的用意\r\n\t// 通常由下划线分隔的大写字符组成\r\n\t// 当有很多action时建议将type提取成常量放到单独文件维护\r\n\ttype: 'ADD_PEOPLE',\r\n\t// 具体操作的数据\r\n\tpeople: {\r\n\t\tname: 'a'\r\n\t}\r\n}\r\n```\r\n以上Action中的数据是固定的，可以通过一个ActionCreator来根据参数动态的生成数据  \r\n```js\r\nconst actionCreator = people => ({\r\n\ttype: 'ADD_PEOPLE',\r\n\tpeople\r\n})\r\n```\r\n注意Action并不会真正的去改变状态，而只是携带了待改变状态的相关信息  \r\n需要通过'store.dispatch(action)'将Action派发至Reducer中才能进行状态的变更  \r\n所以具体的状态改变逻辑应该在Reducer中实现\r\n\r\n### Reducer\r\nReducer用于定义根据收到的不同Action如何去改变应用的状态  \r\nReducer应该是一个Pure function,意味着不应该在其中去改变参数  \r\n并且当入参相同时其返回值应该总是相同的  \r\n```js\r\n// 注意需要给我们的应用设置一个初始化的initalState\r\n// 如果未指定 Redux会开发环境下给出警告\r\nfunction reducer(state = initalState, action) {\r\n\tswitch(action.type) {\r\n\t\tcase 'ADD_PEOPLE':\r\n\t\t\treturn { ...state, ...{ people: action.people } }\r\n\t\t// 在遇到未知的Action时需要将原先的state直接返回\r\n\t\tdefault:\r\n\t\t\treturn state\r\n\t}\r\n}\r\n```\r\n\r\n### Store\r\n每一个应用都只能有一个唯一的Store  \r\n通过`createStore(reducers)`来生成  \r\n用于维护应用的所有State，以及提供一些静态方法用于改变、获取当前状态  \r\n```js\r\nstore.getState() // 获取当前状态\r\nstore.dispatch(action) // 提交action来改变当前状态\r\nconst unsubscribe = store.subscribe(listener) // 监听事件\r\nunsubscribe() // 取消监听\r\n```\r\n\r\n## 进阶以及源码(v4.0.0)\r\n\r\n### Middleware\r\nRedux提供的中间件使开发者可以在每次`dispatch(action)`前后加上一些特定的逻辑  \r\n例如logging/routing等，中间件的通用形式如下  \r\n```js\r\nconst middleware = store => next => action => {\r\n\t// 在dispatch前执行的逻辑\r\n\t// ...\r\n\t\r\n\tconst result = next(action)\r\n\t\r\n\t// ...\r\n\t// 在dispatch完成后执行的逻辑\r\n\treturn result\r\n}\r\n```\r\n\r\n### compose.js\r\n在Redux的applyMiddleware中会用到，函数式编程中常见  \r\n可以将传入的函数从右至左依次执行  \r\n并且每个函数执行的结果会作为下一个函数的参数\r\n类似`compose(a, b, c)(arg)`执行起来同`a(b(c(arg)))`\r\n```js\r\nexport function compose(...funcs) {\r\n\t// 如果没有传入任何参数 则直接返回一个会将第一个参数返回的函数\r\n\tif (funcs.length === 0) {\r\n\t\treturn arg => arg\r\n\t}\r\n\t\r\n\t// 如果参数只有一个函数则直接将该函数返回\r\n\tif (funcs.lenth === 1) {\r\n\t\treturn funcs[0]\r\n\t}\r\n\t\r\n\t// 关于Array.prototype.reduce \r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\r\n\treturn funcs.reduce((a, b) => (...args) => a(b(...args)))\r\n}\r\n\r\n----------- 下面都是分析  --------------\r\n\r\n// 我们来试试funcs.reduce是如何来实现逻辑的\r\nconst first = () => console.log(1)\r\nconst second = () => console.log(2)\r\nconst third = () => console.log(3)\r\nconst funcs = [first, second, third]\r\n\r\n// 分解开来看\r\n// 第一次reduce相当于\r\n// (first, second) => (...args) => first(second(...args))\r\n// 其返回结果是\r\n// (...args) => first(second(...args))\r\n// 第二次reduce执行时的accumulator及第一次的返回结果\r\n// 所以 (accumulator, third) => (...args) => accumulator(third(...args))\r\n// 返回结果是 \r\n// (...args) => accumulator(third(...args))\r\n// 相当于\r\n// (...args) => first(second(third(...args))\r\nconst re = funcs.reduce((a, b) => (...args) => a(b(...args)))\r\n\r\n// 上述代码中有一个地方要理解一下\r\n// const test = (...args) => f(...args)\r\n// 在参数中的...其实起到的是收集的作用，会将我们调用时传入的所有参数放到args这个数组中\r\n// 而在f(...args)中的...起到的是解构的作用\r\n// 又会将args数组中的所有元素依次作为参数传到f这个函数中\r\n// 假设我们test(1, 2, 3)这样调用则其返回结果其实就是f(1, 2, 3)\r\n// 所以这种做法其实就是在我们不确定一个函数入参个数的情况下\r\n// 将所有入参原封不动的按照原有顺序传入到调用函数中\r\n// 按照老的方式其实就是借助arguments来实现\r\n// es6\r\nconst test = (...args) => f(...args)\r\n// Babel编译后\r\nvar test = function test() {\r\n\treturn f.apply(undefined, arguments)\r\n}\r\n\r\n// 从上述分析可以得出 re其实就等同于\r\n// (...args) => first(second(third(...args))\r\n// 当我们调用re()就等同于\r\n// first(second(third())\r\n// 所以输出是 3 2 1\r\nre() // 3 2 1\r\n\r\n// 通过对传入函数的特殊处理 可以使这个过程变为正序\r\n// Redux的middleWare就是借助这种原理\r\nconst a = next => arg => { console.log(arg); next('b'); }\r\nconst b = next => arg => { console.log(arg); next('c'); }\r\nconst c = next => arg => { console.log(arg); next('d'); }\r\nconst d = arg => console.log(arg)\r\n\r\n// 'a' 'b' 'c' 'd'\r\ncompose(a,b,c)(d)('a')\r\n// 继续分解来看一下 首先是compose(a, b, c)\r\n// 从上述分析得出的结论来看也就是等同于\r\n// (...args) => a(b(c(...args)))\r\n// 然后是compose(a,b,c)(d) 所以入参为函数d\r\n// 也就是等同于a(b(c(d)))\r\n// 第一步c(d) 返回 re1 = arg => {console.log(arg); d('d')}\r\n// 第二步b(c(d)) 也就是b(re1) 返回 re2 = arg => { console.log(arg); re1('c'); }\r\n// 第三步a(b(c(d))) 也就是a(re2) 返回 re3 = arg => { console.log(arg); re2('b'); }\r\n// 所以compose(a,b,c)(d) 返回的就是 arg => { console.log(arg); re2('b'); }\r\n// 最后一步compose(a,b,c)(d)('a') 相当于\r\n// console.log('a'); re2('b')\r\n// 再把所有的结果展开\r\n// console.log('a'); console.log('b'); console.log('c'); console.log('d');\r\n```\r\n\r\n### applyMiddleware\r\n对外提供应用中间件的接口\r\n```js\r\nexport default function applyMiddleware(...middlewares) {\r\n\t// 注意applyMiddleware是一个高阶函数\r\n\t// 返回值是一个入参为createStore的函数\r\n\treturn createStore => (...args) => {\r\n\t\t// 当需运用中间件时 createStore在此处真正执行\r\n\t\tconst store = createStore(...args)\r\n\t\t\r\n\t\t// 如果middleware在执行自己的逻辑过程中调用dispatch则抛出错误\r\n\t\tlet dispatch = () => { throw new Error('...') }\r\n\t\t\r\n\t\t// 只提供给中间件有限的API而不是全部store\r\n\t\tconst middlewareAPI = {\r\n\t\t\tgetState: store.getState,\r\n\t\t\tdispatch: (...args) => dispatch(...args)\r\n\t\t}\r\n\t\t// 要注意此时如果在middleware中执行 middlewareAPI.dispatch() 会抛出错误\r\n\t\t// 由于Redux规定middleware形如 store => next => action => {} 的函数\r\n\t\t// 这样处理过后在chain中存放的便是形如 next => action => {} 的函数\r\n\t\tconst chain = middlewares.map(middleware => middleware(middlewareAPI))\r\n\t\t// 这里的dispatch是已经实现了中间件逻辑后的dispatch方法\r\n\t\tdispatch = compose(...chain)(store.dispatch)\r\n\t\t\r\n\t\t// 这里利用了解构会去重的特性\r\n\t\t// 会将store.dispatch覆盖为包含中间件逻辑的新dispatch\r\n\t\treturn {\r\n\t\t\t...store,\r\n\t\t\tdispatch\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n### utils/warning.js\r\nRedux通过该函数在开发环境下向控制台输出错误或提示信息方便开发者Debug\r\n```js\r\nexport default function warning(message) {\r\n\t// 为了增强程序的Robusty 只有当前运行的宿主环境存在console\r\n\t// 并且console.error是函数才去调用 使得任何情况下都不会因为该函数报错\r\n\t// 从而导致程序终止运行\r\n\tif (typeof console !== 'undefined' && typeof console.error === 'function') {\r\n\t\tconsole.error(message)\r\n\t}\r\n\t\r\n\t// 下面这段代码只有当我们打开浏览器的Console\r\n\t// 并开启break on all exceptions功能时\r\n\t// 才会在每次报错或提示时暂停程序执行(相当在出错的那行打断点)\r\n\t// 否则的话不会有任何作用\r\n\t// 同样是为了方便开发者进行Debug\r\n\ttry {\r\n\t\tthrow new Error(message)\r\n\t} catch (e) {}\r\n}\r\n```\r\n\r\n### utils/isPlainObject.js\r\n由于Redux中要求Action必须是Javascript中的Plain Object  \r\n所以这个工具函数用于判断一个对象是否满足该条件  \r\n会在`dispatch(action)`执行最开始处进行判断，如果传入的action不满足条件会抛出错误  \r\n所谓的Plain Object指的是直接通过`{}`或者`new Object()`生成，原型链上并没有其它对象的Object\r\n```js\r\nexport function isPlainObject(obj) {\r\n\t// 如果对象都不是当然也不是PlainObject\r\n\t// 这里注意的是 obj === null 这个判断\r\n\t// 因为在Js中 typeof null === 'object'\r\n\tif (typeof obj !== 'object' || obj === null) return false\r\n\t\r\n\t// lodash中的isPlainObject多了这个逻辑\r\n\t// 主要考虑到这个特殊情况 const o = Object.create(null)\r\n\t// 此处的o应该也满足条件 isPlainObject(o) // => true\r\n\tif (Object.getPrototypeOf(obj) === null) {\r\n\t\treturn true\r\n\t}\r\n\t\r\n\tlet proto = obj\r\n\t// 因为 Object.getPrototypeOf(Object.prototype) === null\r\n\t// 所以当循环结束时 proto 指向的其实就是Object.prototype\r\n\t// 也就是说此时的proto === Object.prototype\r\n\twhile (Object.getPrototypeOf(proto) !== null) {\r\n\t\tproto = Object.getPrototypeOf(proto)\r\n\t}\r\n\t\r\n\t// 如果传入对象的prototype与Object.prototype一致\r\n\t// 则认为该对象是Plain Object\r\n\t// 所以最终的判断逻辑其实与obj.__proto__ === Object.prototype类似\r\n\t// 上面的代码更多的是在考虑edge case\r\n\treturn Object.getPrototypeOf(obj) === proto\r\n}\r\n```\r\nPs: `lodash.isPlainObject`逻辑与上述代码基本一致  \r\n同样是Redux的timdorr提的PR\r\n\r\n### index.js\r\n```js\r\nimport createStore from './createStore'\r\nimport combineReducers from './combineReducers'\r\nimport bindActionCreators from './bindActionCreators'\r\nimport applyMiddleware from './applyMiddleware'\r\nimport compose from './compose'\r\nimport warning from './utils/warning'\r\nimport __DO_NOT_USE__ActionTypes from './utils/actionTypes'\r\n\r\n// 建立一个函数名为isCrushed的空函数\r\nfunction isCrushed() {}\r\n\r\n// 如果当前的环境不是生成环境但采用了压缩过后的代码则提示开发者\r\n// 因为压缩混淆后的代码会将函数改变为类似 function f() {} 以减小代码体积\r\nif (process.env.NODE_ENV !== 'production' && \r\n\ttypeof isCrushed.name === 'string' &&\r\n\tisCrushed.name !== 'isCrushed'\r\n) {\r\n\twarning('...')\r\n}\r\n\r\n// 以下为Redux所有对外提供的API\r\nexport {\r\n\tcreateStore,\r\n\tcombineReducers,\r\n\tbindActionCreators,\r\n\tapplyMiddleware,\r\n\tcompose,\r\n\t__DO_NOT_USE__ActionTypes\r\n}\r\n```\r\n\r\n### createStore.js\r\nRedux应用的主入口文件  \r\n```js\r\n// reducer 必传 通常来讲是我们通过combineReducers将所有ruducer集成到一起后的主函数\r\n// preloaderState 可选 可以传入的应用初始状态\r\n// enhancer 可选 也就是applyMiddleware()的返回结果\r\nexport default function createStore(reducer, preloadedState, enhancer) {\r\n\t// 由于preloadedState参数是可选的 所以这里考虑的是这么一种情况\r\n\t// createStore(reducer, applyMiddleware())\r\n\t// 这样在不传入preloadedState时就不用像createStore(reducer, null, applyMiddleware())这样调用\r\n\tif (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\r\n\t\tenhancer = preloadedState\r\n\t\tpreloadedState = undefined\r\n\t}\r\n\t\r\n\t// 有传入enhancer 也就是有使用中间件(applyMiddleware)\r\n\tif (typeof enhancer !== 'undefined') {\r\n\t\t// applyMiddleware()返回的应该是一个函数 否则需要报错\r\n\t\tif (typeof enhancer !== 'function') {\r\n\t\t\tthrow new Error('Expected the enhancer to be a function.')\r\n\t\t}\r\n\t\t\r\n\t\t// 有使用中间件的话 需要在applyMiddleware去createStore\r\n\t\t// applyMiddleware()返回的是一个形如 createStore => (...args) => {} 的函数\r\n\t\t// 所以这里会对enhancer(cerateStore)返回的结果再次传入参数(reducer, preloaderState)调用\r\n\t\treturn enhancer(createStore)(reducer, preloaderState)\r\n\t}\r\n\t\r\n\t// reducer也必须为函数\r\n\tif (typeof reducer !== 'function') {\r\n\t\tthrow new Error('Expected the reducer to be a function.')\r\n\t}\r\n\t\r\n\t// 利用闭包存储当前的Reducer\r\n\t// 这样就稍后才可通过replaceReducer()方法替换掉当前使用的Reducer\r\n\tlet currentReducer = reducer\r\n\t\r\n\t// 同上 整个Redux应用的状态树都是利用闭包存储的\r\n\tlet currentState = preloadedState\r\n\t\r\n\t// 这里要注意 多存了一份当前监听事件函数的备份\r\n\tlet currentListeners = []\r\n\tlet nextListeners = currentListeners\r\n\t\r\n\t// 用于标识当前是否正在执行dispatch()操作\r\n\tlet isDispatching = false\r\n\t\r\n\t// 确保nextListeners存的是currentListeners的备份 而不是引用\r\n\tfunction ensureCanMutateNextListeners() {\r\n\t\tif (nextListeners === currentListeners) {\r\n\t\t\tnextListeners = currentListeners.slice()\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 简单的把当前闭包所存储的应用状态返回出去\r\n\tfunction getState() {\r\n\t\t// 正在执行dispatch操作时不能获取当前状态\r\n\t\t// 因为当前状态可能会被正在执行的dispatch()操作改变\r\n\t\tif (isDispatching) {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\t\r\n\t\treturn currentState\r\n\t}\r\n\t\r\n\t// 注册监听事件 在每次dispath时都会调用所有注册过的函数\r\n\tfunction subscribe(listener) {\r\n\t\t// 注册的listener只能是函数\r\n\t\tif (typeof listener !== 'function') {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\r\n\t\t// 正在执行dispatch操作时不允许新注册监听事件\r\n\t\tif (isDispatching) {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\t\r\n\t\t// 这里同样利用了闭包\r\n\t\t// 每次调用都会有独立的isSubscribed状态\r\n\t\t// 与每个listener一一对应\r\n\t\tlet isSubscribed = true\r\n\t\t\r\n\t\tensureCanMutateNextListeners()\r\n\t\tnextListeners.push(listener)\r\n\t\t\r\n\t\treturn function unsubscribe(){\r\n\t\t\t// 避免重复取消监听 例如\r\n\t\t\t// const off = store.subscribe(...)\r\n\t\t\t// off()\r\n\t\t\t// off()\r\n\t\t\tif (!isSubscribed) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 正在执行dispatch操作时不允许取消监听\r\n\t\t\tif (isDispatching) {\r\n\t\t\t\tthrow new Error('...')\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 代表这个listener已经取消监听了\r\n\t\t\tisSubscribed = false\r\n\t\t\t\r\n\t\t\tensureCanMutateNextListeners()\r\n\t\t\t// 这里也利用了闭包 先找到当前闭包存储的入参listerner在数组中的下标\r\n\t\t\tconst index = nextListeners.indexOf(listener)\r\n\t\t\t// 移除数组中对应下标存储的元素\r\n\t\t\tnextListeners.splice(index, 1)\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tfunction dispatch(action) {\r\n\t\t// 在Redux中Action只能为plain object\r\n\t\tif (!isPlainObject(action)) {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\t\r\n\t\t// Action的type不能为空\r\n\t\t// 通常来说type都应该是一个用于描述当前行为的常量字符串\r\n\t\t// 不知道这里为什么不限制type只能为string\r\n\t\tif (typeof action.type === 'undefined') {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\t\r\n\t\t// 阻止开发者在reducer中去调用dispatch\r\n\t\tif (isDispatching) {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\t\r\n\t\ttry {\r\n\t\t\tisDispatching = true\r\n\t\t\t// currentReducer就是当前Redux正在使用的Reducer\r\n\t\t\t// 将当前状态树和action传入 返回经reducer处理过后的新状态树\r\n\t\t\tcurrentState = currentReducer(currentState, action)\r\n\t\t} finally {\r\n\t\t\t// 无论reducer处理过程中是否出错 都需要更改flag\r\n\t\t\t// 代表本次dispatch操作结束 否则接下来redux就没法用了\r\n\t\t\tisDispatching = false\r\n\t\t}\r\n\t\t\r\n\t\t// 这里要注意执行顺序\r\n\t\t// 每次dispatch都会将当前的currentListeners 指向 nextListeners\r\n\t\t// 所以每次执行的其实都是最新的nextListeners当中存储的的监听事件\r\n\t\t// 这里就可以理解ensureCanMutateNextListeners()的用处\r\n\t\t// 每次新增监听或取消监听时都要确保nextListeners是currentListener的拷贝\r\n\t\t// 这样保证在dispatch过程中的currentListerner不会发生变化\r\n\t\t// 例如如果我们在一个listener函数中去新subscribe或者unsubscribe\r\n\t\t// 都不会立马生效 而是只有等到下一次dispatch才会生效\r\n\t\tconst listeners = (currentListeners = nextListeners)\r\n\t\tfor (let i = 0; i < listeners.length; i++) {\r\n\t\t\t// 注意这里的用法 并没有直接像 listeners[i]()这样调用\r\n\t\t\t// 因为这样的话listener中的this会指向listeners而不是window\r\n\t\t\tconst listener = listeners[i]\r\n\t\t\tlistener()\r\n\t\t}\r\n\t\t\r\n\t\t// 将传入的action原封不动返回\r\n\t\t// 感觉基本来说不会用到这个函数的返回值\r\n\t\treturn action\r\n\t}\r\n\t\r\n\t// 替换当前正在使用的Reducer\r\n\tfunction replaceReducer(nextReducer) {\r\n\t\t// Reducer必须是函数\r\n\t\tif (typeof nextReducer !== 'function') {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\t\r\n\t\t// 直接将闭包的存储指向新的Reducer\r\n\t\tcurrentReducer = nextReducer\r\n\t\t// dispatch一个REPLACE Action 来重新生成新的状态树\r\n\t\tdispatch({ type: ActionTypes.REPLACE })\r\n\t}\r\n\t\r\n\t// dispatch一个INIT Action 初始化生成Redux的状态树\r\n\tdispatch({ type: ActionTypes.INIT })\r\n\t\r\n\t// 对外主要就提供了四个API\r\n\treturn {\r\n\t\tdispatch,\r\n\t\tsubscribe,\r\n\t\tgetState,\r\n\t\treplaceReducer,\r\n\t\t[$$observable]: observable // 私有的 用于测试 这里不具体展开\r\n\t}\r\n}\r\n```\r\n\r\n### combineReducer.js\r\n由于在大型应用中我们需要管理一个复杂的状态树  \r\n如果将所有的Action处理逻辑写在同一个Reducer中会很难维护  \r\n所以大多数情况下我们的项目中会有很多个不同的Reducer文件  \r\n而Redux的`createStore(reducer)`只接受一个RootReducer作为参数  \r\n所以这个时候就需要借助Redux提供的这个工具方法将所有的子Reducer合为最终的RootReducer\r\n其主要作用如下  \r\n```js\r\n// 应用的状态树\r\nconst state = {\r\n\ta: '',\r\n\tb: ''\r\n}\r\n\r\nconst reducerA = (a, action) => {}\r\nconst reducerB = (b, action) => {}\r\n// 自己手动来生成RootReducer\r\nconst rootReducer = (state, action) => {\r\n\treturn {\r\n\t\ta: reducerA(state.a, action),\r\n\t\tb: reducerB(state.b, action)\r\n\t}\r\n}\r\n// 借助combineReducer\r\n// 入参中的key需要与state中的key相对应\r\n// 子Reducer的函数名可以任意 并无影响\r\nconst rootReducer = combineReducer({\r\n\ta: reducerA,\r\n\tb: reducerB\r\n})\r\n```\r\n下面看看源码\r\n```js\r\nimport ActionTypes from './utils/actionTypes'\r\nimport warning from './utils/warning'\r\nimport isPlainObject from './utils/isPlainObject'\r\n\r\n// 用于生成当有Reducer返回的state为undefined时的错误描述\r\nfunction getUndefinedStateErrorMessage(key, action) {\r\n\tconst actionType = action && action.type\r\n\tconst actionDescription =\r\n\t\t(actionType && `action \"${String(actionType)}\"`)) || 'an action'\r\n\treturn '...'\r\n}\r\n\r\n// 用于生成在入参的key与state中的key有不一致时生成错误描述\r\nfunction getUnexpectedStateShapeWarningMessage() {}\r\n\r\n// 判断传入的reducer是否都合规 否则抛出错误\r\nfunction assertReducerShape(reducers) {\r\n\tObject.keys(reducers).forEach(key => {\r\n\t\tconst reducer = reducers[key]\r\n\t\t// 用初始化的Action去生成默认的state\r\n\t\tconst initialState = reducer(undefined, { type: ActionTypes.INIT })\r\n\t\t// 如果有reducer没有提供默认的state则抛出错误\r\n\t\t// 所以如果即使当我们希望一个reducer默认不返回值时应该显示的返回null\r\n\t\tif (initialState === undefined) {\r\n\t\t\tthrow new Error()\r\n\t\t}\r\n\t\t\r\n\t\t// 当传一个未知type的action到reducer中时\r\n\t\t// reducer也应该返回一个状态 通常来说是将传入的state 不错修改直接返回\r\n\t\tif (typeof reducer(undefined, {\r\n\t\t\ttype: ActionTypes.PROBE_UNKNOWN_ACTION()\r\n\t\t}) === 'undefined') {\r\n\t\t\tthrow new Error()\r\n\t\t}\r\n\t})\r\n}\r\n\r\n// 将多个子reducer组合返回一个root reducer函数\r\nexport default function combineReducers(reducers) {\r\n\t// 拿到入参对象的所有key\r\n\tconst reducerKeys = Object.keys(reducers)\r\n\tconst finalReducers = {}\r\n\t\r\n\tfor (let i = 0; i < reducerKeys.length; i++) {\r\n\t\tconst key = reducerKeys[i]\r\n\t\t\r\n\t\t// 只有在开发环境下进行警告提示\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\t// 不是很理解这个判断\r\n\t\t\t// 只有当入参对象的value中有undefined时才会警告\r\n\t\t\tif (typeof reducers[key] === 'undefined') {\r\n\t\t\t\twarning('...')\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 这一步会过滤掉入参中value不是函数的部分\r\n\t\t\t// 确保fianalReducers中的每个value都是一个函数\r\n\t\t\tif (typeof reducers[key] === 'function') {\r\n\t\t\t\tfinalReducers[key] = reducers[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (typeof reducers[key] === 'function') {\r\n\t\t\tfinalReducers[key] = reducers[key]\r\n\t\t}\r\n\t\tconst finalReducerKeys = Object.keys(finalReducers)\r\n\t\t\r\n\t\tlet unexpectedKeyCache\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tunexpectedKeyCache = {}\r\n\t\t}\r\n\t\t\r\n\t\tlet shapeAssertionError\r\n\t\ttry {\r\n\t\t\tassertReducerShape(finalReducers)\r\n\t\t} catch (e) {\r\n\t\t\tshapeAssertionError = e\r\n\t\t}\r\n\t\t\r\n\t\treturn function combination(state = {}, action) {\r\n\t\t\t// 当Reducer格式有误时 终止执行 抛出错误\r\n\t\t\tif (shapeAssertionError) {\r\n\t\t\t\tthrow shapeAssertionError\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 开发环境下给出错误提示\r\n\t\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\t\tconst warningMessage = getUnexpectedStateShapeWarningMessage(...)\r\n\t\t\t\tif (warningMessage) {\r\n\t\t\t\t\twarning(warningMessage)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlet hasChanged = false\r\n\t\t\tconst nextState = {}\r\n\t\t\tfor (let i = 0; i < finalReducerKeys.length; i++) {\r\n\t\t\t\tconst key = finalReducerKeys[i]\r\n\t\t\t\tconst reducer = finalReducers[key]\r\n\t\t\t\tconst previouStateForKey = state[key]\r\n\t\t\t\tconst nextStateForKey = reducer(previousStateForKey, action)\r\n\t\t\t\t// Reducer处理过后的状态不能返回为空\r\n\t\t\t\tif (typeof nextStateForKey === 'undefined') {\r\n\t\t\t\t\tthrow new Error('...')\r\n\t\t\t\t}\r\n\t\t\t\tnextState[key] = nextStateForKey\r\n\t\t\t\t// 判断经Reducer处理后的状态前后是否发生变化\r\n\t\t\t\thasChanged = hasChanged || nextStateForKey !== previousStateForKey\r\n\t\t\t}\r\n\t\t\t// 注意 对于Redux而言 整个状态树中只要有一处发生变化 则视为其有过变化\r\n\t\t\treturn hasChanged ? nextState : state\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n### bindActionCreators.js\r\n在Redux中我们每次先通过ActionCreator去生成一个Action  \r\n然后再通过`dispatch(action)`来触发状态的改变  \r\n有时候我们想要把Redux的相关逻辑放到父组件中  \r\n然后将改变状态的函数传入子组件，这个时候就需要利用bindActionCreators  \r\n该函数可以将create action以及dispatch这俩步操作绑定在一起  \r\n这样每次通过绑定后的Creator去生成Action时会同时进行dispatch操作\r\n```js\r\nfunction bindActionCreator(actionCreator, dispatch) {\r\n\t// 返回一个函数 执行会先Create Action  \r\n\t// 然后dispatch这个生成的Action\r\n\treturn function () {\r\n\t\tdispatch(actionCreator.apply(this, arguments))\r\n\t}\r\n}\r\n\r\nexport default bindActionCreators(actionCreators, dispatch) {\r\n\t// 传入单个creator\r\n\t// 直接返回绑定后的creator\r\n\tif (typeof actionCreators === 'function') {\r\n\t\treturn bindActionCreator(actionCreators, dispatch)\r\n\t}\r\n\t\r\n\t// 传入的actionCreators既不是函数也不是对象则抛出错误\r\n\tif (typeof actionCreators !== 'object' || typeof actionCreators === null) {\r\n\t\tthrow new Error('')\r\n\t}\r\n\t\r\n\tconst keys = Object.keys(actionCreators)\r\n\t// 用于存储绑定后的Creator\r\n\tconst boundActionCreators = {}\r\n\tfor (let i = 0; i < keys.length; i++) {\r\n\t\tconst key = keys[i]\r\n\t\tconst actionCreator = actionCreators[key]\r\n\t\t// actionCreator必须是一个函数\r\n\t\tif (typeof actionCreator === 'function') {\r\n\t\t\t// 依次绑定每一个Creator\r\n\t\t\tboundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\r\n\t\t}\r\n\t}\r\n\t// 将绑定后的结果返回\r\n\treturn boundActionCreators\r\n}\r\n```\r\n"},"./src/blogs/Symbol.md":function(r,n){r.exports="# Symbols in ES6\r\n`Symbol`是ES6中(时隔多年)新增的一种**primitive type**，可以把它看做一种自动生成**唯一字符串**的机制，它的真实值被隐藏在代码后且永远无法直接获得\r\n\r\n## 如何生成Symbol\r\n```js\r\n// 最基础的方式\r\nconst a = Symbol()\r\n\r\n// 可以传入一串描述该Symbol用途的字符串作为参数\r\nconst b = Symbol('some description text')\r\n\r\n// 从全局的Symbol库中查询所需的Symbol\r\n// 如果未找到则新建一个并返回\r\n// 这种方式较以上直接构造Symbol的优点在于\r\n// 可以不必在外部作用域中专门维护一个变量用于存储生成的Symbol\r\nconst c = Symbol.for('my Symbol')\r\n\r\n// 由于不管如何Symbol都是全局存在的\r\n// 为了尽量避免可能发生的冲突 可以给Symbol添加相应的前缀\r\nconst d = Symbol.for('prefix.Symbol')\r\n```\r\n\r\n## 如何判断一个值是否为Symbol\r\n```js\r\nconst a = Symbol()\r\n// 推荐方式\r\ntypeof a === 'symbol'// true\r\n\r\n// 其余方式\r\na instanceof Symbol // false\r\nObject(a) instanceof Symbol // true\r\nObject(a).valueOf() === a // true\r\n```\r\n\r\n## 如何获得Symbol的描述字符串\r\n```js\r\nconst a = Symbol('desc a')\r\nconst b = Symbol.for('desc b')\r\n\r\nSymbol.keyFor(a) // undefined\r\nSymbol.keyFor(b) // desc b\r\n\r\na.toString() // Symbol(desc a)\r\nb.toString() // Symbol(desc b)\r\n```\r\n通过上述对比，个人感觉用`Symbol.for()`来生成`Symbol`好像更加合适\r\n\r\n不仅可以避免使用不必要的变量污染作用域，并且能更方便的获得其描述\r\n\r\n## Symbol的用途\r\n借助`Symbol`来实现单例模式\r\n```js\r\nconst Instance = Symbol.for('instance')\r\nfunction singleton() {\r\n\tif (singleton[Instance]) {\r\n\t\treturn singleton[Instance]\r\n\t}\r\n\t\r\n\treturn singleton[Instance] = {}\r\n}\r\nconst a = singleton()\r\nconst b = singleton()\r\na === b // true\r\n```\r\n\r\n如果将上例中的Symbol替换成任意一个不规则字符串（Magic String）对逻辑的实现并无影响\r\n\r\n所以从这个角度看来，Symbol的出现更多的是对代码或者说程序层面上的提升，而不是函数性的提升\r\n\r\n```js\r\nconst o = {\r\n\tfoo: 1,\r\n\t[Symbol.for('bar')]: 2\r\n}\r\nObject.getOwnPropertyNames(o) // ['foo']\r\nObject.getOwnPropertySymbols(o) // [Symbol(for)]\r\nObject.keys(o) // ['foo']\r\nfor (let key in o ){\r\n\tconsole.log(key) // 'foo'\r\n}\r\n```\r\n\r\n可以看到，虽然Symbol作为Object的属性key不会被当作普通的键值被获取\r\n\r\n但是还是有特殊途径来获得，所以并不能试图通过Symbol把Object的部分属性隐藏(作为外部不可访问的私有属性)\r\n\r\n## Built-in Symbols\r\n个人感觉ES6自身提供的Built-in Symbols会是最常见的`Symbol`使用方式，例如`Symbol.iterator`:\r\n```js\r\nconst arr = [1, 2, 3]\r\narr[Symbol.iterator] // native function\r\nconst it = arr[Symbol.iterator]() // 获得数组arr的Iterator\r\n```\r\n值得一提的是这些内部的Symbol并不是像我们自定义的那样注册到全局库中\r\n\r\n而是作为Symbol构造函数的静态属性对外提供\r\n\r\n"},"./src/blogs/WebpackBaseConfig.md":function(r,n){r.exports="# Webpack(v3.8.1)\r\n```\r\nconst path = require('path')\r\nconst webpack = require('webpack')\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\r\nconst pkg = require(path.join(__dirname, 'package.json'))// package.json\r\n\r\n// 定义项目中的一些文件夹路径\r\nconst APP_PATH = path.resolve(__dirname, 'src')\r\n\r\nlet theme = {}\r\n// pkg.theme存的是项目中antd主题文件的路径\r\n// 这里是 ./antd-theme.js\r\nif (pkg.theme && typeof(pkg.theme) === 'string') {\r\n  theme = require(path.resolve(__dirname, pkg.theme))\r\n}\r\n\r\nmodule.exports = {\r\n  entry: path.resolve(APP_PATH, 'index.jsx'),\r\n  // 暂时本地开发环境的不配output好像影响不大\r\n  // 后期遇到问题再配\r\n  resolve: {\r\n    // 配置这个后引用node_modules中的依赖包不用加路径 直接import xx from ('antd')即可\r\n    modules: [\r\n      'node_modules'\r\n    ],\r\n    //后缀 配了这个就可以在import时 import xx from (./test) 而不用 import xx from (./test.jsx)\r\n    extensions: ['.js', '.jsx', '.json', '.scss']\r\n  },\r\n  module: {\r\n    rules: [{\r\n      test: /\\.js|\\.jsx$/,\r\n      use: [\r\n        'babel-loader',\r\n        'eslint-loader'\r\n      ],\r\n      exclude: /node_modules/\r\n    }, {\r\n      test: /\\.css$/,\r\n      use: ['css-loader']\r\n    }, {\r\n      test: /\\.less$/,\r\n      use: [{\r\n        loader: 'style-loader'\r\n      },{\r\n        loader: 'css-loader'\r\n      },{\r\n        loader: 'less-loader',\r\n        options: {\r\n          sourceMap: true,\r\n          modifyVars: theme // 用于自定义antd主题 覆盖其less变量\r\n        }\r\n      }],\r\n      include: path.resolve(__dirname, 'node_modules')\r\n    }, {\r\n      test: /\\.scss$/,\r\n      use: [\r\n        'style-loader',\r\n        'css-loader',\r\n        'sass-loader'\r\n      ],\r\n      include: APP_PATH\r\n    }, {\r\n      // 字体文件之类的需要这个loader支持\r\n      test: /\\.(eot|woff|woff2|svg|ttf)([\\?]?.*)$/,\r\n      use: ['file-loader'],\r\n      include: APP_PATH\r\n    }, {\r\n      test: /\\.(jpe?g|png|gif|svg)$/,\r\n      use: [{\r\n        loader: 'url-loader',\r\n        options: {\r\n          limit: 8192// 小于1kb的图片采用base64编码 并以DATAUrl的形式嵌入页面\r\n        }\r\n      }],\r\n      include: APP_PATH\r\n    }]\r\n  },\r\n  devServer: {\r\n    contentBase: './build',\r\n    historyApiFallback: true,\r\n    hot: true,// 开启HMR\r\n    inline: true,\r\n    compress: true,// 开启gzip\r\n    port: 8080\r\n  },\r\n  plugins: [\r\n    new webpack.NamedModulesPlugin(),// 用于确保多次build生成的bundle名称不变\r\n    new HtmlWebpackPlugin({\r\n      template: 'index.html'// 以根目录下的index.html为模版\r\n    }),\r\n    new webpack.HotModuleReplacementPlugin()// HMR所需\r\n  ],\r\n  devtool: 'cheap-module-eval-source-map'\r\n}\r\n\r\n```\r\n生产环境\r\n```\r\nconst path = require('path')\r\nconst webpack = require('webpack')\r\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\r\nconst CleanWebpackPlugin = require('clean-webpack-plugin')\r\nconst ROOT_PATH = path.resolve(__dirname)\r\nconst APP_PATH = path.resolve(ROOT_PATH, 'src')\r\n\r\nconst pkg = require(path.join(__dirname, 'package.json'))// package.json\r\nlet theme = {}\r\n// pkg.theme存的是项目中antd主题文件的路径\r\n// 这里是 ./antd-theme.js\r\nif (pkg.theme && typeof(pkg.theme) === 'string') {\r\n  theme = require(path.resolve(__dirname, pkg.theme))\r\n}\r\n// 用于提取自己写的css\r\nconst appExtract = new ExtractTextPlugin({filename: 'app.[contenthash].css', allChunks: true})\r\n// 用于提取依赖包的css(主要是Antd)\r\nconst vendorExtract = new ExtractTextPlugin({filename: 'vendor.css', allChunks: true})\r\n\r\nmodule.exports = {\r\n  entry: {\r\n    app: path.resolve(APP_PATH, 'index.jsx'),\r\n    vendor: ['react', 'axios']\r\n  },\r\n  output: {\r\n    path: path.resolve(__dirname, 'build'),\r\n    publicPath: '/',\r\n    filename: '[name].[chunkhash].js',\r\n    chunkFilename: '[name].[chunkhash:5].chunk.js',\r\n  },\r\n  resolve: {\r\n    // 配置这个后引用node_modules中的依赖包不用加路径 直接import xx from ('antd')即可\r\n    modules: [\r\n      'node_modules'\r\n    ],\r\n    //后缀 配了这个就可以在import时 import xx from (./test) 而不用 import xx from (./test.jsx)\r\n    extensions: ['.js', '.jsx', '.json', '.scss']\r\n  },\r\n  plugins: [\r\n    new webpack.optimize.UglifyJsPlugin({\r\n      compress: {\r\n        warnings: false\r\n      }\r\n    }),\r\n    // 与NamedModulesPlugin 但更适用于生成环境\r\n    new webpack.HashedModuleIdsPlugin(),\r\n    // 部分依赖包(React)会在非生产环境中包含一些提示、警告的代码来帮助开发者解决问题\r\n    // 在生产环境通过配置这个可以阻止生成这些代码 减小bundle的size\r\n    new webpack.DefinePlugin({ 'process.env.NODE_ENV': JSON.stringify('production') }),\r\n    // 变动频率小的外部依赖包\r\n    new webpack.optimize.CommonsChunkPlugin({\r\n      name: 'vendor'\r\n    }),\r\n    // webpack的运行环境所需\r\n    new webpack.optimize.CommonsChunkPlugin({\r\n      name: 'runtime'\r\n    }),\r\n    new HtmlWebpackPlugin({\r\n      template: 'index.html'// 以根目录下的index.html为模版\r\n    }),\r\n    new CleanWebpackPlugin('build'),\r\n    appExtract,\r\n    vendorExtract,\r\n  ],\r\n  module: {\r\n    rules: [{\r\n      test: /\\.js|\\.jsx$/,\r\n      use: [\r\n        'babel-loader',\r\n        'eslint-loader'\r\n      ],\r\n      exclude: /node_modules/\r\n    }, {\r\n      test: /\\.css$/,\r\n      use: vendorExtract.extract(['css-loader'])\r\n    }, {\r\n      test: /\\.less$/,\r\n      use: vendorExtract.extract({\r\n        fallback: 'style-loader',\r\n        use: [{\r\n          loader: 'css-loader'\r\n        },{\r\n          loader: 'less-loader',\r\n          options: {\r\n            sourceMap: true,\r\n            modifyVars: theme // 用于自定义antd主题 覆盖其less变量\r\n          }\r\n        }]\r\n      }),\r\n      include: path.resolve(__dirname, 'node_modules')\r\n    }, {\r\n      test: /\\.scss$/,\r\n      use: appExtract.extract({\r\n        fallback: 'style-loader',\r\n        use: ['css-loader','sass-loader']\r\n      }),\r\n      include: APP_PATH\r\n    }, {\r\n      // 字体文件之类的需要这个loader支持\r\n      test: /\\.(eot|woff|woff2|svg|ttf)([\\?]?.*)$/,\r\n      use: ['file-loader'],\r\n      include: APP_PATH\r\n    }, {\r\n      test: /\\.(jpe?g|png|gif|svg)$/,\r\n      use: [{\r\n        loader: 'url-loader',\r\n        options: {\r\n          outputPath: 'images/',// 将图片放入build/images/目录下\r\n          limit: 8192// 小于1kb的图片采用base64编码 并以DATAUrl的形式嵌入页面\r\n        }\r\n      }],\r\n      include: APP_PATH\r\n    }]\r\n  }\r\n};\r\n\r\n```\r\n"},"./src/blogs/WebpackV3ToV4.md":function(r,n){r.exports="# Webpack V3 升级至 V4\r\n## 序\r\n半年没关注，最近突然发现Webpack的版本已经升到4.16.2了，为了紧跟潮流的步伐，决定将项目中使用的3.10.0来个升级\r\n\r\n## 步骤\r\n1. 安装`webpack`以及`webpack-cli`\r\n2. 将项目中所有用到的`loader`以及`plugin`升级到最新\r\n3. 配置文件里新增 `mode: 'development'` or `mode: 'production'`\r\n4. 移除`webpack.optimize.UglifyJsPlugin`，现在webpack会在生产环境默认对js进行压缩\r\n5. 移除`extract-text-webpack-plugin`，v4推荐使用新的`mini-css-extract-plugin`来提取样式文件\r\n6. 引入`optimize-css-assets-webpack-plugin`以及`uglifyjs-webpack-plugin`，并在生产环境的配置文件下新增\r\n\r\n```js\r\nconst UglifyJsPlugin = require(\"uglifyjs-webpack-plugin\")\r\nconst OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\")\r\n\r\nmodule.exports = {\r\n\toptimization: {\r\n\t\tminimizer: [\r\n\t\t\t// 由于配置optimization会覆盖默认值 所以这里需要配一下UglifyJsPlugin\r\n\t\t\tnew UglifyJsPlugin({\r\n\t\t\t\tcache: true,\r\n\t\t\t\tparallel: true,\r\n\t\t\t}),\r\n\t\t\tnew OptimizeCSSAssetsPlugin({})\r\n\t\t]\r\n\t}\r\n}\r\n```\r\n7. 搞定\r\n\r\n## 总结\r\n升级过后打包和编译速度大概提升了15%左右（粗略比较）\r\n\r\n上述只是针对我之前项目配置的升级，并不完整，仅供参考\r\n\r\nWebpack官方有提供详细的迁移[文档](https://webpack.js.org/migrate/4/)\r\n\r\n遇到问题也可以通过报错信息很快定位到原因，再去相应的Github库上找一找解决办法，迁移过程还是比较顺利的\r\n"},"./src/components/Blog/index.jsx":function(r,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var e=function(){function r(r,n){for(var t=0;t<n.length;t++){var e=n[t];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(r,e.key,e)}}return function(n,t,e){return t&&r(n.prototype,t),e&&r(n,e),n}}(),o=x(t("./node_modules/react/index.js")),s=x(t("./src/components/Markdown/index.jsx")),a=x(t("./src/blogs/WebpackBaseConfig.md")),c=x(t("./src/blogs/GulpPlugin.md")),i=x(t("./src/blogs/Symbol.md")),l=x(t("./src/blogs/Iterator.md")),u=x(t("./src/blogs/WebpackV3ToV4.md")),d=x(t("./src/blogs/Generator.md")),p=x(t("./src/blogs/ArrayAPI.md")),m=x(t("./src/blogs/ObjectAPI.md")),f=x(t("./src/blogs/Collections.md")),b=x(t("./src/blogs/Promise.md")),y=x(t("./src/blogs/PreventModalScroll.md")),h=x(t("./src/blogs/Redux.md")),g=x(t("./src/blogs/ReactRedux.md"));function x(r){return r&&r.__esModule?r:{default:r}}t("./src/components/Blog/style.less");var j=[a.default,c.default,i.default,l.default,u.default,d.default,p.default,m.default,f.default,b.default,y.default,h.default,g.default],S=function(r){function n(){return function(r,n){if(!(r instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),function(r,n){if(!r)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?r:n}(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(r,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(r,n):r.__proto__=n)}(n,o.default.Component),e(n,[{key:"render",value:function(){return o.default.createElement("div",{className:"blogs"},j.map(function(r,n){return o.default.createElement("div",{className:"blog",key:n},o.default.createElement(s.default,{data:r}))}))}}]),n}();n.default=S},"./src/components/Blog/style.less":function(r,n,t){},"./src/components/Markdown/index.jsx":function(r,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var e=l(t("./node_modules/react/index.js")),o=l(t("./node_modules/marked/lib/marked.js")),s=l(t("./node_modules/highlight.js/lib/highlight.js")),a=l(t("./node_modules/highlight.js/lib/languages/javascript.js")),c=l(t("./node_modules/highlight.js/lib/languages/css.js")),i=l(t("./node_modules/highlight.js/lib/languages/xml.js"));function l(r){return r&&r.__esModule?r:{default:r}}t("./node_modules/highlight.js/styles/atom-one-light.css"),t("./src/components/Markdown/style.less"),s.default.registerLanguage("javascript",a.default),s.default.registerLanguage("css",c.default),s.default.registerLanguage("xml",i.default),o.default.setOptions({highlight:function(r){return s.default.highlightAuto(r).value}}),n.default=function(r){return e.default.createElement("div",{className:"my-md",dangerouslySetInnerHTML:{__html:(0,o.default)(r.data)}})}},"./src/components/Markdown/style.less":function(r,n,t){}}]);