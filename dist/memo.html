<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>MinimalistYing.io-Memo</title>
	
	<link rel="shortcut icon" type="image/x-icon" href="./assets/img/favicon.ico">
	<link rel="stylesheet" type="text/css" href="./assets/css/main.css">
</head>
<body>
	<header>
		<h3 class="header-title">MinimalistYing.io</h3>
		<nav>
			<ul>
				<li ><a href="../../index.html">Home</a></li>
				<li class="selected"><a href="./memo.html">Memo</a></li>
				<li ><a href="https://github.com/MinimalistYing">Github</a></li>
			</ul>
		</nav>
	</header>
	<main class="memo-main">
		<!-- JS相关 -->
		<div class="memo-anchor-target">JavaScript<a class="fake-target" name="javascript">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">判断一个值是否为<pre>NaN</pre>一定要通过<pre>isNaN()</pre>而不是通过等号比较，因为<pre>NaN !== NaN</pre>
			<div class="memo-time">2017/8/2</div></div>

			<div class="memo-card">通过Javascript<pre>element.scrollTop = value</pre>或者jQuery<pre>$(dom).scrollTop(value)</pre>去设置滚动条滚动位置时，注意所选取的元素就是设置了<pre>overflow-y : scroll</pre>的元素
			<div class="memo-time">2017/8/3</div></div>

			<div class="memo-card">Javascript中字符串替换API<pre>String.replace(reg, replacement)</pre>其中的replacement可以是一个回调函数<pre>(match, $1, $2, offset, string) =&gt;{}</pre>通过种方法可以实现将被匹配的文本做特殊的转化后再替换的功能，具体参数意义以及接口可见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace">这篇文档</a>
			<div class="memo-time">2017/8/20</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">在Javascript中进行浮点数运算是不可靠的，遵循IEEE 754标准，二进制的浮点数运算不能正确的处理十进制小数，例如典型的<pre>0.1 + 0.2 !== 0.3</pre>在一定的精度范围内可通过将小数转化为整数再进行比较来解决这个问题
			<div class="memo-time">2017/8/2</div></div>

			<div class="memo-card">实现类似改变一个DOM元素的滚动条位置但不触发绑定在上面的onscroll函数，或者改变一个input元素的值不触发绑定在上面的onchange函数的一种思路：在改变值之前先将其绑定的事件函数解绑，改变完成后再将原有函数绑定回元素上
			<br>
			注意如果值的改变如果是连续的，也就是这个过程会短时间内重复多次执行时，需要将解绑和绑定操作放在延时函数中执行，避免反复多次的绑定事件和解绑事件消耗过多资源，导致浏览器卡顿
			<div class="memo-time">2017/8/7</div></div>
			
			<div class="memo-card">用于监听CSS3动画结束的事件<pre>webkitAnimationEnd// Chrome Safari<br>mozAnimationEnd<br>MSAnimationEnd// IE10<br>oanimationend// Opera<br>animationend</pre>
			<div class="memo-time">2017/9/1</div></div>
			
			<div class="memo-card">利用原生的JS即可输出格式化后的JSON字符串<pre>JSON.stringify(value[, replacer[, space]])</pre>其中space即是缩进数，默认无缩进，最大为10。replacer可以是一个过滤函数，用来筛选或替换最后的输出结果。具体参数意义以及接口可见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">这篇文档</a>
			<div class="memo-time">2017/9/8</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">判断点击是否在某个DOM外部发生的思路，判断<pre>event.srcElement(IE) || event.target(FF)</pre>是否是这个DOM节点本身或者是其子元素,这里要注意在内部元素有特殊定位的情况下可能这个思路会有问题
			<div class="memo-time">2017/8/12</div></div>

			<div class="memo-card">在使用Javascript的<pre>parseInt()</pre>时，最好显示的指明进制，因为<pre>parseInt('0x16') = 22</pre>而你可能期望的结果是<pre>parseInt('0x16') = 0</pre>所以显示的指定进制才能做到真正的结果可控<pre>parseInt('0x16', 16) = 22<br>parseInt('0x16', 10) = 0</pre> 
			<div class="memo-time">2017/8/2</div></div>

			<div class="memo-card">Javascript中的假值(falsy values)<pre>false<br>null<br>undefined<br>空字符串''<br>0<br>NaN</pre>其它值都为true
			<div class="memo-time">2017/9/3</div></div>
		</div>

		<!-- CSS相关 -->
		<div class="memo-anchor-target">Cascading Style Sheets<a class="fake-target" name="css">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">为了实现隐藏一个元素的滚动条但仍可以在鼠标移入其中时进行滚动操作，可以通过将其用父元素包裹，并将父元素设为<pre>overflow : hidden</pre>同时将其向右偏移或者增宽，这样可以使得其滚动条隐藏在父元素之下，类似<pre>&lt;div calss=&quot;wrapper&quot; style=&quot;overflow : hidden; width : 200px&quot;&gt;<br>&lt;div class=&quot;inner&quot; style=&quot;max-height : 10px; overflow : scroll; width : 220px&quot;&gt;&lt;/div&gt;<br>&lt;/div&gt;</pre>的写法
			<div class="memo-time">2017/8/3</div></div>

			<div class="memo-card">想实现鼠标悬浮在一个父元素上能触发其子元素在<pre>:hover</pre>下的样式，之前的思路是通过借助jQuery<pre>$(parent).hover(() =&gt; $(son).hover())</pre>来实现，今天突然发现原来的方法太复杂，其实只需要几行CSS即可实现想要的效果，类似<pre>.parent:hover .son {<br>// 这里是鼠标悬浮在父元素上时子元素的样式<br>}</pre>先前的思路在使用原生的Javascript时更难实现，因为原生的规范中并没有hover事件，与之相关的是鼠标的<pre>mouseenter/mouseleave/mousemove</pre>事件，而即使是在代码中触发了这些事件也是无法触发CSS的<pre>:hover</pre>状态的
			<div class="memo-time">2017/8/10</div></div>

			<div class="memo-card">可以通过给锚点设置一个向上的负偏移量来实现调至锚点位置时不会将锚点至于页面最顶部(避免被顶部所固定的Header遮挡)，类似:<pre>a {<br>position: relative;<br>top: -66px;<br>}</pre>
			<div class="memo-time">2017/8/27</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card"><pre>::selection</pre>可用于改变文字选中时的字体颜色和背景色，IE9及以上和现代浏览器兼容
			<div class="memo-time">2017/8/10</div></div>

			<div class="memo-card">当一个<pre>position: absolute</pre>的绝对定位元素的父元素的<pre>overflow</pre>值被设为非<pre>visible</pre>时，会出现该定位元素超出父元素的部分会被遮盖掉无法显示的情况，暂时对这种问题的解决方式只知道将父元素改为<pre>overflow: visible</pre>或者尽量保证定位元素不会超出父元素的边界
			<div class="memo-time">2017/8/15</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">当一个<pre>display : inline-block</pre>元素的overflow被设为visible以外的值时，它的baseline位置会被从默认的字符x的底线位置修改为下外边沿，与此同时同一包含块的其它<pre>display : inline-block</pre>元素会被迫向下偏移来和这个元素对齐，遵循IFC(Inline Formatting Contexts)原则
			<div class="memo-time">2017/8/13</div></div>

			<div class="memo-card">当一个元素被设为<pre>display: flex</pre>时，它会被当作一个Flex Container，而它的所有子元素都会被当作Flex Item，并且这时候在其子元素上设置<pre>float | clear | vertical-align</pre>的值都是无效的
			<div class="memo-time">2017/8/16</div></div>
		</div>

		<!-- 兼容性相关 -->
		<div class="memo-anchor-target">浏览器兼容性<a class="fake-target" name="compatibility">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">为了使<pre>display: inline-block</pre>在IE8中起作用，必须在文档开头加上<pre>&lt;!DOCTYPE html&gt;</pre>并在头部加上<pre>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</pre>	
			<div class="memo-time">2017/8/1</div></div>

			<div class="memo-card">可以通过<pre>filter : Alpha(opacity = ?)</pre>来在IE7-8中兼容CSS3的<pre>opacity</pre>属性
			<div class="memo-time">2017/8/13</div></div>
			
			<div class="memo-card">关于<pre>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</pre>详情参看<a href="https://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do">这个回答</a>
			<div class="memo-time">2017/9/5</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">IE8中的伪元素只支持类似<pre>:after</pre>的写法，不支持<pre>::after</pre>的写法
			<div class="memo-time">2017/8/2</div></div>

			<div class="memo-card">在IE8下如果在<pre>table-layout : auto</pre>的表格中为单元格设置<pre>white-space : nowrap<br>overflow : hidden<br>text-overflow : ellipsis</pre>想实现单元格内文字过长时出现...并截断多余内容会发现无效，反而表格会被内容撑宽，破坏原有布局。要想实现这种效果，只能将表格设为<pre>table-layout : fixed</pre>
			<div class="memo-time">2017/8/16</div></div>
			
			<div class="memo-card">通过ES5shim和Babel使用新特性Class时如果类并没有继承却在<pre>contructor()</pre>中调用了<pre>super()</pre>会导致在IE8下报错Stackoverflow。谨记如果没有继承关系则不应该调用<pre>super()</pre>方法 
			<div class="memo-time">2017/9/8</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">IE8切换为兼容性视图模式时会将原User-Agent中包含的<pre>MSIE8.0</pre>转变为<pre>MSIE7.0</pre>所以在通过UA来判断IE版本时尤其要注意
			<div class="memo-time">2017/8/9</div></div>
			
			<div class="memo-card">Edge和IE11还有Safari好像会试图去识别页面上的数字是否像电话号码，如果像的话会在这些数字下加一个下划线，并使其可点击打开Skype之类的应用拨号(有些邮箱以及地址也同理)，想禁用这一特性可在HTML中加上<pre>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no,address=no&quot;&gt;</pre>
			<div class="memo-time">2017/9/1</div></div>
			
			<div class="memo-card"> IE8下可采用<pre>filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&lt;div class=&quot;memo-time&quot;&gt;(ieFilter)color,endColorstr=&lt;/div&gt;(ieFilter)color);</pre>来兼容<pre>rgba()</pre>
			<div class="memo-time">2017/9/11</div></div>
		</div>

		<!-- Gulp相关 -->
		<div class="memo-anchor-target">Gulp<a class="fake-target" name="gulp">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">Gulp确保任务按一定顺序执行<pre>gulp.task('second', ['first'], () =&gt; {})</pre>Gulp在匹配的文件列表中剔除指定文件<pre>gulp.src(['asset/*.js', '!asset/exclude.js'], () =&gt; {})</pre>上述代码会匹配asset目录下除去exclude.js的所有以.js结尾的文件
			<div class="memo-time">2017/8/21</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">Gulp在文件变化时触发回调函数<pre>gulp.watch('...', (event) =&gt; {})<br>//event.path 发生变化文件的路径<br>//event.type added|changed|deleted|renamed</pre>
			<div class="memo-time">2017/8/21</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">在使用<pre>gulp.src(...).pipe(...).pipe(...)</pre>的过程中会发现当出错时控制台中报出的错误信息很难看懂,这是由于在Node.js中stream出错时会抛出error事件，而上述代码里没有写有关错误事件的处理函数，所以Node会默认的报出堆栈跟踪信息作为错误信息。如果采取如下捕获异常事件的方式来处理错误<pre>gulp.src().pipe().on('err', () =&gt; {})</pre>会使代码变得很复杂，推荐使用Pump的方式来进行处理<pre>var pump = require('pump')<br>pump([gulp.src(), uglify(), concat()], cb)</pre>
			<div class="memo-time">2017/8/21</div></div>
		</div>
		
		<!-- jQuery相关 -->
		<div class="memo-anchor-target">jQuery<a class="fake-target" name="jquery">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">利用好jQuery的事件命名空间可以减少很多需要在一个Dom元素的同一事件上绑定多个不同回调函数时会碰到的问题，例如<pre>$(dom).on('click.a', () =&gt; {})<br>$(dom).on('click.b', () =&gt; {})</pre>当出于某种原因需要解绑第一个函数时，只需要<pre>$(dom).off('.a')</pre>即可实现，同时也不会对b命名空间下的绑定事件有任何影响。如果想触发某个特定空间下的事件，可以通过<pre>$(dom).trigger('click.b')</pre>来实现
			<div class="memo-time">2017/8/29</div></div>
			
			<div class="memo-card">jQuery可以通过<pre>$(':visible')/$(':hidden')</pre>来查找可见/不可见的Dom元素(通过判断元素的height和width是否大于0，所以<pre>opacity:0<br>visibility: hidden</pre>的元素会被认为是可见的)。这俩种选择器会带来性能上的问题，尽量避免使用，一定要使用的话也应该先通过纯CSS选择器将目标选出再通过<pre>$(dom).is(':visible')/$(dom).is(':hidden')</pre>判断，或者通过<pre>$(dom).filter(':visible')/$(dom).filter(':hidden')</pre>过滤
			<div class="memo-time">2017/8/30</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">jQuery核心函数的几种重载形式：<pre>//相当于$( document ).ready()<br>$(($) =&gt; {<br>//文档加载完毕<br>})</pre><pre>//选择器<br>$('selector')</pre><pre>//选择器(在父元素的范围下)<br>$('selector', parentDom)</pre><pre>//将Dom对象包装成jQuery对象<br>$(dom)</pre><pre>//将Dom对象的数组包装成jQuery对象<br>$(domArray)</pre><pre>//1.4以后返回空的jQuery对象<br>$()</pre><pre>//将Html字符串包装成jQuery对象<br>$('&lt;div&gt;&lt;/div&gt;')</pre><pre>//生成一个标签并包装成jQuery对象<br>$('&lt;div&gt;', {'class': 'a'})</pre>
			<div class="memo-time">2017/8/30</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">使用<pre>$(dom).html('...')</pre>时需注意防范脚本注入攻击，如果传入的字符串中包含可由用户填写的字段需要先进行转义，更好的办法是尽量使用<pre>$(dom).text('...')</pre>
			<div class="memo-time">2017/8/30</div></div>
		</div>

		<!-- Http相关 -->
		<div class="memo-anchor-target">HyperText Transfer Protocol<a class="fake-target" name="http">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">HTTP中的URL中没有具体表明端口号时，默认访问80端口，而HTTPS中的默认端口号为443
			<div class="memo-time">2017/8/22</div></div>

			<div class="memo-card">由于TCP具有慢启动特性（不能在连接的开始就将所有的IP分组一次发出，而是只有在一个分组成功确认后才有发出其它俩个分组的权限），所以新连接的速度一般会比已建立好的连接要慢
			<div class="memo-time">2017/8/25</div></div>
			
			<div class="memo-card">Web服务器也可以接受一个目录的URL请求，类似<pre>/dir/</pre>通过配置服务器可以指定不同的返回形式，可以返回一个错误，可以默认的去搜索该目录下的index.html并返回，可以扫描目录返回包含目录内容的html页面(通常这是不安全的，因为这样会把站点的目录结构暴露出来)
			<div class="memo-time">2017/8/28</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">关于URI/URL/URN，URL和URM其实是URI(Uniform Resource Identifier)统一资源定位符的子集。URL不止指定了资源的地址，同时还指定了获取资源的方式（协议/方法等等）。而URN则只通过特定的命名空间标识资源，不关注操作获取资源的方式。
			<div class="memo-time">2017/8/22</div></div>

			<div class="memo-card">源IP地址、目标IP地址、源端口号、目标端口号这四个值一起唯一地定义了一个TCP连接
			<div class="memo-time">2017/8/25</div></div>
			
			<div class="memo-card">HTTP响应中的Date首部应该表示原始服务器最初产生这个对象的日期
			<div class="memo-time">2017/9/5</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">HTTP的版本号不会被当作小数来比较，而是每个数字都单独处理，所以假设将来有这么俩个版本HTTP/2.22和HTTP/2.3，前者的版本更高
			<div class="memo-time">2017/8/23</div></div>

			<div class="memo-card">通常Web服务器的文件系统会有一个根目录(Document Root)来专门用于存放Web内容，当服务器收到一个对静态资源的请求时会获取其URI并附加在根目录后去寻找相应的文件，例如服务器的根目录为<pre>/usr/home</pre>请求为<pre>/test/haha.gif</pre>服务器会在文件系统的<pre>/usr/home/test/haha.gif</pre>目录下去寻找被请求的资源文件。要注意的是，一个服务器也可能同时提供多个Web站点，它可以通过不同的请求Host或者IP来访问不同的根目录
			<div class="memo-time">2017/8/28</div></div>
			
			<div class="memo-card">`Cache-Control : no-store` 禁止代理缓存<pre>Cache-Control : no-cache<br>Pragma : no-cache// 兼容HTTP/1.0</pre>允许缓存，但必须先与服务器进行新鲜度验证，之后才能将内容返回给客户端<pre>Cache-Control : max-age:66,must-revalidate</pre>允许缓存，并且只有在内容过期后才必须进行新鲜度验证（在缓存过期时即使服务器错误也不会将这个陈旧的缓存返回给客户端）
			<div class="memo-time">2017/9/5</div></div>
		</div>

		<!-- 其它没法归类的 -->
		<div class="memo-anchor-target">杂项<a class="fake-target" name="other">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">在自测与后台有交互，会发送请求的地方时一定要注意在Chrome的Network中观察发送请求的URL、参数等是否符合预期，同时也要注意考虑请求返回失败或返回空结果时页面UI的展示
			<div class="memo-time">2017/8/6</div></div>

			<div class="memo-card">正则表达式中的<pre>.</pre>可以用于匹配除换行符外的所有字符,如果想匹配含换行符在内的所有字符可以使用<pre>[\s\S]</pre>
			<div class="memo-time">2017/8/20</div></div>	
			
			<div class="memo-card">在HTML中属性可以用双引号、单引号、甚至不用引号包围，浏览器都是支持的。所以Google为了节省字节会采用不用引号的风格，大概对访问量极大的网站这也是一种省钱的方式吧
			<div class="memo-time">2017/9/4</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">关于采集站点的PV、UV数据，传统的做法是当页面load完成后像后台发送数据，当作一次PV<br>
			但在SPA(Single Page App)以及PWA(Progressive Web App)的情景下，这样的断定方式显得不那么合理，用户有可能一天中只Load一次页面然后在一天的任意时间段在这个应用中活动而不需要再一次Load页面<br>
			考虑用更新的方式进行统计可能比较合理，例如借助<a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API">Page Visibility API</a>在用户初次打开应用浏览以及过去合理的一段时间后(可以用Session持续的最长时间来判断)后从其它再次切换到这个Tab页都作为一次PV<br>
			详情可见这篇<a href="https://philipwalton.com/articles/how-we-track-pageviews-is-all-wrong/">Blog</a>
			<div class="memo-time">2017/8/14</div></div>

			<div class="memo-card">在新的HTML5规范中，如果一个元素拥有ID属性，那么ID属性的属性值就会成为window对象的属性名，属性值就是ID对应的元素。如果下列标签中的元素拥有name属性<pre>&lt;a&gt; &lt;applet&gt; &lt;area&gt; &lt;embed&gt; &lt;form&gt; &lt;frame&gt; &lt;frameset&gt; &lt;iframe&gt; &lt;img&gt; &lt;object&gt;</pre>那么name属性的属性值就会成为window对象的属性名。例如页面上有这么一个元素<pre>&lt;div id=&quot;a&quot;&gt;&lt;/div&gt;</pre>在script中<pre>console.info(a)<br>//结果为&lt;div id=&quot;a&quot;&gt;&lt;/div&gt;</pre>
			<div class="memo-time">2017/8/23</div></div>
			
			<div class="memo-card"><pre>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;<br>&lt;meta charset=&quot;utf-8&quot;&gt;</pre>在HTML中俩者都可用来表明页面所采用的字符集，各浏览器的兼容性良好，但后者更短建议采用后者
			<div class="memo-time">2017/9/5</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">HTML5新增了<pre>input</pre>事件来监听文本框的输入变化，但在IE9下存在用户删除输入或剪切文本时不会触发该事件的Bug,并且IE8下没有该事件，需同时监听<pre>propertychange</pre>来实现兼容IE8
			<div class="memo-time">2017/8/17</div></div>
			
			<div class="memo-card">阅读垠神博客有感  1.会写程序不是一件很了不起的事情，不要自负  2.语言、框架都只是工具，会用即可，不必过于推崇，重要的是我们脑海里的思想  3.开发软件也是一种工程，一定要极力避免Bug，这才是一个工程师该做的  4.面对同事、新人的提问请耐心解答，不要动不动就让提问者自行Google  5.不要觉得向他人提问是什么难为情的事，世界上总有东西是你不清楚的，哪怕是你日常工作所用的东西  6.复杂的代码不是显示能力的途径，简单易懂的才是
			<div class="memo-time">2017/8/30</div></div>
		</div>
	</main>

	<!-- 右侧导航 -->
	<aside class="memo-anchor">
		<ul>
			<li><a href="#_javascript">JavaScript</a></li>
			<li><a href="#_css">CSS</a></li>
			<li><a href="#_compatibility">兼容性</a></li>
			<li><a href="#_gulp">Gulp</a></li>
			<li><a href="#_jquery">jQuery</a></li>
			<li><a href="#_http">HTTP</a></li>
			<li><a href="#_other">杂项</a></li>
		</ul>
	</aside>

	<script type="text/javascript" src="./assets/js/main.js"></script>
</body>
</html>
