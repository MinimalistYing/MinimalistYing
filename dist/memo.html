<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>MinimalistYing.io-Memo</title>
	
	<link rel="shortcut icon" type="image/x-icon" href="./assets/img/favicon.ico">
	<link rel="stylesheet" type="text/css" href="./assets/css/main.css">
</head>
<body>
	<header>
		<h3 class="header-title">MinimalistYing.io</h3>
		<nav>
			<ul>
				<li ><a href="../../index.html">Home</a></li>
				<li class="selected"><a href="./memo.html">Memo</a></li>
				<li ><a href="https://jsfiddle.net/user/MinimalistYing/fiddles/">CodeBase</a></li>
				<li ><a href="https://github.com/MinimalistYing">Github</a></li>
			</ul>
		</nav>
	</header>
	<main class="memo-main">
		<!-- JS相关 -->
		<div class="memo-anchor-target">JavaScript<a class="fake-target" name="javascript">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">判断一个值是否为<code>NaN</code>一定要通过<code>isNaN()</code>而不是通过等号比较，因为<code>NaN !== NaN</code>
			<div class="memo-time">2017/8/2</div></div>

			<div class="memo-card">通过Javascript<code>element.scrollTop = value</code>或者jQuery<code>$(dom).scrollTop(value)</code>去设置滚动条滚动位置时，注意所选取的元素就是设置了<code>overflow-y : scroll</code>的元素
			<div class="memo-time">2017/8/3</div></div>

			<div class="memo-card">Javascript中字符串替换API<code>String.replace(reg, replacement)</code>其中的replacement可以是一个回调函数<code>(match, $1, $2, offset, string) =&gt;{}</code>通过种方法可以实现将被匹配的文本做特殊的转化后再替换的功能，具体参数意义以及接口可见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace">这篇文档</a>
			<div class="memo-time">2017/8/20</div></div>
			
			<div class="memo-card">Javascript中的原型是一种动态关系，改变原型的属性会立即对所有该原型链下的对象可见<pre>var a = {}<br>a.test =&gt; undefined<br>Object.prototype.test = 'Hello'<br>a.test =&gt; Hello</pre>
			<div class="memo-time">2017/9/27</div></div>
			
			<div class="memo-card">可以使用Object的<code>hasOwnProperty()</code>方法来检测一个属性是该对象独有还是由原型链继承而来
			<div class="memo-time">2017/9/27</div></div>
			
			<div class="memo-card">Javascript的<code>setTimeout()</code>和<code>setInterval()</code>都可以接受字符串参数，并类似eval()将其执行，不安全并且效率低下，最好不要使用。具体可见<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">这篇文档</a>
			<div class="memo-time">2017/9/28</div></div>
			
			<div class="memo-card">Javascript的变量名允许使用Unicode字符集中的所有字母和数字，所以类似<code>var 变量 = 1</code>也是合法的
			<div class="memo-time">2017/10/23</div></div>
			
			<div class="memo-card">使用<code>String.prototype.length()</code>来判断字符串长度在某些特殊场景下存在问题，例如<code>'𝒜'.length === 2</code>因为这个方法判断的是给定字符串用了几个UTF-16（16bit）来编码，而有些特殊字符需要32bit来编码，这时候这个方法计算一个字符的长度是2，判断方法可见<a href="http://ife.baidu.com/note/detail/id/583">这篇Blog</a>
			<div class="memo-time">2017/10/23</div></div>
			
			<div class="memo-card">在Javascript中<code>Object</code>是<code>truthy value</code>所以哪怕是<code>new Boolean(false)</code>也会在类型转化时被判断为true<pre>false && console.log(1) =&gt; false<br>new Boolean(false) && console.log(1) =&gt; 1 </pre>
			<div class="memo-time">2017/8/2</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">在Javascript中进行浮点数运算是不可靠的，遵循IEEE 754标准，二进制的浮点数运算不能正确的处理十进制小数，例如典型的<code>0.1 + 0.2 !== 0.3</code>在一定的精度范围内可通过将小数转化为整数再进行比较来解决这个问题
			<div class="memo-time">2017/8/2</div></div>

			<div class="memo-card">实现类似改变一个DOM元素的滚动条位置但不触发绑定在上面的onscroll函数，或者改变一个input元素的值不触发绑定在上面的onchange函数的一种思路：在改变值之前先将其绑定的事件函数解绑，改变完成后再将原有函数绑定回元素上
			<br>
			注意如果值的改变如果是连续的，也就是这个过程会短时间内重复多次执行时，需要将解绑和绑定操作放在延时函数中执行，避免反复多次的绑定事件和解绑事件消耗过多资源，导致浏览器卡顿
			<div class="memo-time">2017/8/7</div></div>
			
			<div class="memo-card">用于监听CSS3动画结束的事件<pre>webkitAnimationEnd// Chrome Safari<br>mozAnimationEnd<br>MSAnimationEnd// IE10<br>oanimationend// Opera<br>animationend</pre>
			<div class="memo-time">2017/9/1</div></div>
			
			<div class="memo-card">利用原生的JS即可输出格式化后的JSON字符串<code>JSON.stringify(value[, replacer[, space]])</code>其中space即是缩进数，默认无缩进，最大为10。replacer可以是一个过滤函数，用来筛选或替换最后的输出结果。具体参数意义以及接口可见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">这篇文档</a>
			<div class="memo-time">2017/9/8</div></div>
			
			<div class="memo-card">Javascript中的Array其实是一种类数组的对象，效率比真正的数组要低，所以会有如下一些奇怪的行为<pre>var arr = [1,2,3]<br>arr[0] =&gt; 1<br>arr['0'] =&gt; 1<br>arr.name = 'Hello'<br>arr.name =&gt; 'Hello'<br>arr[10] = 10<br>arr[6] =&gt; undefined<br>arr.length = 1<br>arr =&gt; [1]</pre>
			<div class="memo-time">2017/9/27</div></div>
			
			<div class="memo-card"><code>Array.prototype.sort()</code>可传入比较函数<code>comparefn(a, b)</code>来排序，希望a排在前该函数需返回一个负数，反之返回正数，俩者相等则返回0。
			<div class="memo-time">2017/9/28</div></div>
			
			<div class="memo-card">使用Javascript时如果选择在行尾不加上<code>;</code>是比较危险的行为，例如<pre>var arr = [1,2,3]<br>var b = arr<br>[2].toString()<br>console.info(b)</pre>的结果可能会出人意料，自动加分号的结果是<code>var arr = [1,2,3];var b = arr[2].toString();console.info(b);</code>再第二行以<code>( [ + -</code>开头时都需要注意避免以上情况
			<div class="memo-time">2017/10/23</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">判断点击是否在某个DOM外部发生的思路，判断<code>event.srcElement(IE) || event.target(FF)</code>是否是这个DOM节点本身或者是其子元素,这里要注意在内部元素有特殊定位的情况下可能这个思路会有问题
			<div class="memo-time">2017/8/12</div></div>

			<div class="memo-card">在使用Javascript的<code>parseInt()</code>时，最好显示的指明进制，因为<code>parseInt('0x16') = 22</code>而你可能期望的结果是<code>parseInt('0x16') = 0</code>所以显示的指定进制才能做到真正的结果可控<pre>parseInt('0x16', 16) = 22<br>parseInt('0x16', 10) = 0</pre> 
			<div class="memo-time">2017/8/2</div></div>

			<div class="memo-card">Javascript中的假值(falsy values)<pre>false<br>null<br>undefined<br>空字符串''<br>0<br>NaN</pre>其它值都为true
			<div class="memo-time">2017/9/3</div></div>
			
			<div class="memo-card">在Javascript中尝试去获取对象的某个属性值时，如果该对象没有该属性，则会继续在其原型链上查找直至<code>Object.prototype</code>,如果都没有找到才会返回<code>undefined</code>
			<div class="memo-time">2017/9/27</div></div>
			
			<div class="memo-card">判断是否是数组的方法，IE9+直接用原生的<code>Array.isArray()</code>如果要向下兼容的话<pre>Object.prototype.toString.call(arg) === '[object Array]'</pre>Ps:jQuery的<code>$.isArray()</code>亦是采用这种方式
			<div class="memo-time">2017/9/27</div></div>
			
			<div class="memo-card">关于<code>String.prototype.split([separator[, limit]])</code><pre>'abc'.split() =&gt; ['abc']<br>'abc'.split('') =&gt; ['a','b','c']<br>'a,b'.split(/(,)/) =&gt; [&quot;a&quot;, &quot;,&quot;, &quot;b&quot;]<br>'abc'.split('').reverse().join('')// 字符串倒序</pre>
			<div class="memo-time">2017/9/28</div></div>
		</div>

		<!-- CSS相关 -->
		<div class="memo-anchor-target">Cascading Style Sheets<a class="fake-target" name="css">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">为了实现隐藏一个元素的滚动条但仍可以在鼠标移入其中时进行滚动操作，可以通过将其用父元素包裹，并将父元素设为<code>overflow : hidden</code>同时将其向右偏移或者增宽，这样可以使得其滚动条隐藏在父元素之下，类似<pre>&lt;div calss=&quot;wrapper&quot; style=&quot;overflow : hidden; width : 200px&quot;&gt;<br>&lt;div class=&quot;inner&quot; style=&quot;max-height : 10px; overflow : scroll; width : 220px&quot;&gt;&lt;/div&gt;<br>&lt;/div&gt;</pre>的写法
			<div class="memo-time">2017/8/3</div></div>

			<div class="memo-card">想实现鼠标悬浮在一个父元素上能触发其子元素在<code>:hover</code>下的样式，之前的思路是通过借助jQuery<code>$(parent).hover(() =&gt; $(son).hover())</code>来实现，今天突然发现原来的方法太复杂，其实只需要几行CSS即可实现想要的效果，类似<pre>.parent:hover .son {<br>// 这里是鼠标悬浮在父元素上时子元素的样式<br>}</pre>先前的思路在使用原生的Javascript时更难实现，因为原生的规范中并没有hover事件，与之相关的是鼠标的<code>mouseenter/mouseleave/mousemove</code>事件，而即使是在代码中触发了这些事件也是无法触发CSS的<code>:hover</code>状态的
			<div class="memo-time">2017/8/10</div></div>

			<div class="memo-card">可以通过给锚点设置一个向上的负偏移量来实现调至锚点位置时不会将锚点至于页面最顶部(避免被顶部所固定的Header遮挡)，类似:<pre>a {<br>position: relative;<br>top: -66px;<br>}</pre>
			<div class="memo-time">2017/8/27</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card"><code>::selection</code>可用于改变文字选中时的字体颜色和背景色，IE9及以上和现代浏览器兼容
			<div class="memo-time">2017/8/10</div></div>

			<div class="memo-card">当一个<code>position: absolute</code>的绝对定位元素的父元素的<code>overflow</code>值被设为非<code>visible</code>时，会出现该定位元素超出父元素的部分会被遮盖掉无法显示的情况，暂时对这种问题的解决方式只知道将父元素改为<code>overflow: visible</code>或者尽量保证定位元素不会超出父元素的边界
			<div class="memo-time">2017/8/15</div></div>
			
			<div class="memo-card">一种提高使用transform以及opacity来做过度效果性能的思路<a href="https://aerotwist.com/blog/flip-your-animations/">FLIP</a>
			<div class="memo-time">2017/9/18</div></div>

			<div class="memo-card">关于实现背景透明但文字不透明的效果，首先考虑的是使用<code>opacity</code>但其子元素都会继承这个属性，且无法单独为其子元素设置一个值，所以不可行。如果只是背景色透明的话，使用<code>rgba()</code>来设置透明<code>background-color</code>是一种不错的方法，兼容至IE9。
			<div class="memo-time">2017/11/1</div></div>

			<div class="memo-card"> 关于css实现水平垂直居中
			<div class="memo-time">2017/11/8</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">当一个<code>display : inline-block</code>元素的overflow被设为visible以外的值时，它的baseline位置会被从默认的字符x的底线位置修改为下外边沿，与此同时同一包含块的其它<code>display : inline-block</code>元素会被迫向下偏移来和这个元素对齐，遵循IFC(Inline Formatting Contexts)原则
			<div class="memo-time">2017/8/13</div></div>

			<div class="memo-card">当一个元素被设为<code>display: flex</code>时，它会被当作一个Flex Container，而它的所有子元素都会被当作Flex Item，并且这时候在其子元素上设置<code>float | clear | vertical-align</code>的值都是无效的
			<div class="memo-time">2017/8/16</div></div>
			
			<div class="memo-card">一种将全部元素reset为<code>box-sizing: border-box</code>的方法<pre>html {<br>box-sizing: border-box;<br>}<br>*, *:before, *:after {<br>box-sizing: inherit;<br>}</pre>可能会有更好的方法？详情可见<a href="https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/">这篇文章</a>
			<div class="memo-time">2017/8/10</div></div>
		</div>

		<!-- 兼容性相关 -->
		<div class="memo-anchor-target">浏览器兼容性<a class="fake-target" name="compatibility">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">为了使<code>display: inline-block</code>在IE8中起作用，必须在文档开头加上<code>&lt;!DOCTYPE html&gt;</code>并在头部加上<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code>	
			<div class="memo-time">2017/8/1</div></div>

			<div class="memo-card">可以通过<code>filter : Alpha(opacity = ?)</code>来在IE7-8中兼容CSS3的<code>opacity</code>属性
			<div class="memo-time">2017/8/13</div></div>
			
			<div class="memo-card">关于<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code>详情参看<a href="https://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do">这个回答</a>
			<div class="memo-time">2017/9/5</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">IE8中的伪元素只支持类似<code>:after</code>的写法，不支持<code>::after</code>的写法
			<div class="memo-time">2017/8/2</div></div>

			<div class="memo-card">在IE8下如果在<code>table-layout : auto</code>的表格中为单元格设置<pre>white-space : nowrap<br>overflow : hidden<br>text-overflow : ellipsis</pre>想实现单元格内文字过长时出现...并截断多余内容会发现无效，反而表格会被内容撑宽，破坏原有布局。要想实现这种效果，只能将表格设为<code>table-layout : fixed</code>
			<div class="memo-time">2017/8/16</div></div>
			
			<div class="memo-card">通过ES5shim和Babel使用新特性Class时如果类并没有继承却在<code>contructor()</code>中调用了<code>super()</code>会导致在IE8下报错Stackoverflow。谨记如果没有继承关系则不应该调用<code>super()</code>方法 
			<div class="memo-time">2017/9/8</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">IE8切换为兼容性视图模式时会将原User-Agent中包含的<code>MSIE8.0</code>转变为<code>MSIE7.0</code>所以在通过UA来判断IE版本时尤其要注意
			<div class="memo-time">2017/8/9</div></div>
			
			<div class="memo-card">Edge和IE11还有Safari好像会试图去识别页面上的数字是否像电话号码，如果像的话会在这些数字下加一个下划线，并使其可点击打开Skype之类的应用拨号(有些邮箱以及地址也同理)，想禁用这一特性可在HTML中加上<pre>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no,address=no&quot;&gt;</pre>
			<div class="memo-time">2017/9/1</div></div>
			
			<div class="memo-card"> IE8下可采用<code>filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=xxx,endColorstr=xxx);</code>来兼容<code>rgba()</code>
			<div class="memo-time">2017/9/11</div></div>
		</div>

		<!-- Gulp相关 -->
		<div class="memo-anchor-target">Gulp<a class="fake-target" name="gulp">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">Gulp确保任务按一定顺序执行<pre>gulp.task('second', ['first'], () =&gt; {})</pre>Gulp在匹配的文件列表中剔除指定文件<pre>gulp.src(['asset/*.js', '!asset/exclude.js'], () =&gt; {})</pre>上述代码会匹配asset目录下除去exclude.js的所有以.js结尾的文件
			<div class="memo-time">2017/8/21</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">Gulp在文件变化时触发回调函数<pre>gulp.watch('...', (event) =&gt; {})<br>//event.path 发生变化文件的路径<br>//event.type added|changed|deleted|renamed</pre>
			<div class="memo-time">2017/8/21</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">在使用<pre>gulp.src(...).pipe(...).pipe(...)</pre>的过程中会发现当出错时控制台中报出的错误信息很难看懂,这是由于在Node.js中stream出错时会抛出error事件，而上述代码里没有写有关错误事件的处理函数，所以Node会默认的报出堆栈跟踪信息作为错误信息。如果采取如下捕获异常事件的方式来处理错误<pre>gulp.src().pipe().on('err', () =&gt; {})</pre>会使代码变得很复杂，推荐使用Pump的方式来进行处理<pre>var pump = require('pump')<br>pump([gulp.src(), uglify(), concat()], cb)</pre>
			<div class="memo-time">2017/8/21</div></div>
		</div>
		
		<!-- Webpack相关 -->
		<div class="memo-anchor-target">Webpack<a class="fake-target" name="webpack">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card"> 在开启Webpack<code>devServer</code>遇到问题时可以路由至URL<code>/webpack-dev-server</code>来观察打包出来的bundle文件详情来Debug
			<div class="memo-time">2017/10/27</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card"> 在开发环境中可配置<code>devtool: 'cheap-module-eval-source-map'</code>来获得更快的编译速度，在生产环境中可配置<code>devtool: 'cheap-module-source-map'</code>以便于更好的排查线上问题
			<div class="memo-time">2017/11/3</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card"> Webpack中的<code>url-loader</code>和<code>file-loader</code>都是用于打包一些图片字体之类的静态资源文件，区别在于<code>url-loader</code>会对一定大小限制内的图片进行Base64编码并采用DataUrl的形式嵌入页面或css，这些编码后的图片不会占用HTTP请求。但在图片过大的情况下会增加文件的大小，得不偿失，更适用于处理一些项目中多处用到的小图片（1kb以下）
			<div class="memo-time">2017/10/27</div></div>
		</div>
		
		<!-- jQuery相关 -->
		<div class="memo-anchor-target">jQuery<a class="fake-target" name="jquery">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">利用好jQuery的事件命名空间可以减少很多需要在一个Dom元素的同一事件上绑定多个不同回调函数时会碰到的问题，例如<pre>$(dom).on('click.a', () =&gt; {})<br>$(dom).on('click.b', () =&gt; {})</pre>当出于某种原因需要解绑第一个函数时，只需要<code>$(dom).off('.a')</code>即可实现，同时也不会对b命名空间下的绑定事件有任何影响。如果想触发某个特定空间下的事件，可以通过<code>$(dom).trigger('click.b')</code>来实现
			<div class="memo-time">2017/8/29</div></div>
			
			<div class="memo-card">jQuery可以通过<code>$(':visible')/$(':hidden')</code>来查找可见/不可见的Dom元素(通过判断元素的height和width是否大于0，所以<code>opacity:0  visibility: hidden</code>的元素会被认为是可见的)。这俩种选择器会带来性能上的问题，尽量避免使用，一定要使用的话也应该先通过纯CSS选择器将目标选出再通过<code>$(dom).is(':visible')</code>或<code>$(dom).is(':hidden')</code>判断，或者通过<code>$(dom).filter(':visible')</code>或<code>$(dom).filter(':hidden')</code>过滤
			<div class="memo-time">2017/8/30</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">jQuery核心函数的几种重载形式：<pre>$(($) =&gt; {<br>//文档加载完毕<br>//相当于$( document ).ready()<br>})<br>$('selector') // 选择器<br>$('selector', parentDom) // 选择器(在父元素的范围下)<br>$(dom) // 将Dom对象包装成jQuery对象<br>$(domArray) // 将Dom对象的数组包装成jQuery对象<br>$() // 1.4以后返回空的jQuery对象<br>$('&lt;div&gt;&lt;/div&gt;') // 将Html字符串包装成jQuery对象<br>$('&lt;div&gt;', {'class': 'a'}) // 生成一个标签并包装成jQuery对象</pre>
			<div class="memo-time">2017/8/30</div></div>
			
			<div class="memo-card">jQuery部分版本(1.10.X 1.8.X 可能还有其它)存在一个很奇怪的Bug，在HTML标签中使用nodeName作为ID(或者input的name)会导致页面报错<code>a.nodeName.toLowerCase is not a function</code>使用nodeType作为ID会导致$(window)发生变化并且绑定在上面的resize事件会失效。综上所述，以后谨记不要使用nodeName/nodeType/nodeValue作为HEML标签的ID或者name。
			<div class="memo-time">2017/9/26</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">使用<code>$(dom).html('...')</code>时需注意防范脚本注入攻击，如果传入的字符串中包含可由用户填写的字段需要先进行转义，更好的办法是尽量使用<code>$(dom).text('...')</code>
			<div class="memo-time">2017/8/30</div></div>
		</div>

		<!-- React相关 -->
		<div class="memo-anchor-target">React<a class="fake-target" name="react">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">React组件中的HTML标签必须闭合，否则会编译报错，例如<code>&lt;img&gt;</code>必须写作<code>&lt;img/&gt;</code>
			<div class="memo-time">2017/10/13</div></div>
			
			<div class="memo-card">使用React-Router(3.x版本 其它版本估计也一样)，如果在<code>&lt;Router history={xxx}&gt;</code>上不配置<code>history</code>会报错<code>Uncaught TypeError: Cannot read property 'getCurrentLocation' of undefined</code>所以这个属性是SPA必配？
			<div class="memo-time">2017/10/30</div></div>
			
			<div class="memo-card">React-Router采用动态路由的形式时页面报错<code>The root route must render a single element</code>可能是因为React组件是采用ES6的<code>export default</code>导出，而React-Router是采用CommonJS来<code>require</code>所以需要在导出的组件后加上<code>.default</code>类似<code>require('components/Comp')).default</code>  
			<div class="memo-time">2017/11/3</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">如果确定一个Component再初始化后不需要重新render，可以在组件中声明<code>shouldComponentUpdate (nextProps, nextState) {return false;}</code>这会使React跳过对该组件是否需要重绘的检查，提升性能。还有一种情况下，如果你希望只有在组件的部分属性发生变化时才检查，可以通过在上述方法中比较<code>nextProps</code>和<code>nextState</code>中的指定值是否发生变化来实现。还可以通过继承React提供的<code>React.PureComponent</code>来方便的实现上述需求，这个方法的缺陷是只会进行浅比较，如果<code>props.obj</code>中存储的是一个对象或者数组等就会失效
			<div class="memo-time">2017/10/14</div></div>
			
			<div class="memo-card">关于React-Router中<code>browserHisory</code>和<code>hashHistory</code>的区别，前者的URL类似<code>xx/xx</code>后者是<code>/&lt;div class=&quot;memo-time&quot;&gt;/xx</code>由于HTTP协议的约定，URL中<code>&lt;/div&gt;</code>后作为片段(frag)不会随请求发送至后台，所以不需要服务器进行特殊配置，而前者是借助浏览器下的<code>history</code>API实现，在IE8/9下会导致跳页时Full Load，并且需要服务器配置接受所有请求都返回 `index.html`。优点时使得站点有清晰干净的URL，并且服务器端渲染只能通过这种方式实现，固推荐使用<code>browserHistory</code>
			<div class="memo-time">2017/10/31</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">关于React中的Event Handlers传参数有一下俩种方式<code>&lt;button onClick={(e) =&gt; this.func(id, e)}&gt;click&lt;/button&gt;</code>或者<code>&lt;button onClick={this.func.bind(this, id)}&gt;click&lt;/button&gt;</code>第二种方式下的<code>e</code>会默认作为最后一个参数传递
			<div class="memo-time">2017/10/19</div></div>
			
			<div class="memo-card">如果希望在React组件内部进行路由、页面跳转，可以借助React-Router提供的<code>withRouter(comp)</code>之后便可在组件内部通过<code>this.props.router</code>来进行跳转。但有时候我们希望在组件外部来跳转，这就需要借助history来实现<pre>import {browserHistory} from 'react-router'<br>browserHistory.goBack()<br>browserHistory.push()</pre>
			<div class="memo-time">2017/11/2</div></div>
		</div>

		<!-- Http相关 -->
		<div class="memo-anchor-target">HyperText Transfer Protocol<a class="fake-target" name="http">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">HTTP中的URL中没有具体表明端口号时，默认访问80端口，而HTTPS中的默认端口号为443
			<div class="memo-time">2017/8/22</div></div>

			<div class="memo-card">由于TCP具有慢启动特性（不能在连接的开始就将所有的IP分组一次发出，而是只有在一个分组成功确认后才有发出其它俩个分组的权限），所以新连接的速度一般会比已建立好的连接要慢
			<div class="memo-time">2017/8/25</div></div>
			
			<div class="memo-card">Web服务器也可以接受一个目录的URL请求，类似<code>/dir/</code>通过配置服务器可以指定不同的返回形式，可以返回一个错误，可以默认的去搜索该目录下的index.html并返回，可以扫描目录返回包含目录内容的html页面(通常这是不安全的，因为这样会把站点的目录结构暴露出来)
			<div class="memo-time">2017/8/28</div></div>
			
			<div class="memo-card">HTTP常见状态码<pre>200 =&gt; 请求成功<br>301 =&gt; 资源永久迁移<br>302 =&gt; 资源临时迁移<br>303 =&gt;需要去另一个地址获取资源<br>304 =&gt; 资源未发生变化<br>400 =&gt; 请求异常<br>401 =&gt; 未授权<br>403 =&gt; 服务器拒绝请求<br>404 =&gt; 未找到<br>405 =&gt; 不支持的请求方法<br>408 =&gt; 请求超时<br>500 =&gt; 服务器错误<br>502 =&gt; 网关故障<br>504 =&gt; 网关超时</pre>
			<div class="memo-time">2017/9/19</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">关于URI/URL/URN，URL和URM其实是URI(Uniform Resource Identifier)统一资源定位符的子集。URL不止指定了资源的地址，同时还指定了获取资源的方式（协议/方法等等）。而URN则只通过特定的命名空间标识资源，不关注操作获取资源的方式。
			<div class="memo-time">2017/8/22</div></div>

			<div class="memo-card">源IP地址、目标IP地址、源端口号、目标端口号这四个值一起唯一地定义了一个TCP连接
			<div class="memo-time">2017/8/25</div></div>
			
			<div class="memo-card">HTTP响应中的Date首部应该表示原始服务器最初产生这个对象的日期
			<div class="memo-time">2017/9/5</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">HTTP的版本号不会被当作小数来比较，而是每个数字都单独处理，所以假设将来有这么俩个版本HTTP/2.22和HTTP/2.3，前者的版本更高
			<div class="memo-time">2017/8/23</div></div>

			<div class="memo-card">通常Web服务器的文件系统会有一个根目录(Document Root)来专门用于存放Web内容，当服务器收到一个对静态资源的请求时会获取其URI并附加在根目录后去寻找相应的文件，例如服务器的根目录为<code>/usr/home</code>请求为<code>/test/haha.gif</code>服务器会在文件系统的<code>/usr/home/test/haha.gif</code>目录下去寻找被请求的资源文件。要注意的是，一个服务器也可能同时提供多个Web站点，它可以通过不同的请求Host或者IP来访问不同的根目录
			<div class="memo-time">2017/8/28</div></div>
			
			<div class="memo-card"><code>Cache-Control : no-store</code>禁止代理缓存<code>Cache-Control : no-cache  Pragma : no-cache// 兼容HTTP/1.0</code>允许缓存，但必须先与服务器进行新鲜度验证，之后才能将内容返回给客户端<code>Cache-Control : max-age:66,must-revalidate</code>允许缓存，并且只有在内容过期后才必须进行新鲜度验证（在缓存过期时即使服务器错误也不会将这个陈旧的缓存返回给客户端）
			<div class="memo-time">2017/9/5</div></div>
		</div>

		<!-- 其它没法归类的 -->
		<div class="memo-anchor-target">杂项<a class="fake-target" name="other">&nbsp;</a></div>
		<div class="memo-col">
			<div class="memo-card">在自测与后台有交互，会发送请求的地方时一定要注意在Chrome的Network中观察发送请求的URL、参数等是否符合预期，同时也要注意考虑请求返回失败或返回空结果时页面UI的展示
			<div class="memo-time">2017/8/6</div></div>

			<div class="memo-card">正则表达式中的<code>.</code>可以用于匹配除换行符外的所有字符,如果想匹配含换行符在内的所有字符可以使用<code>[\s\S]</code>
			<div class="memo-time">2017/8/20</div></div>	
			
			<div class="memo-card">在HTML中属性可以用双引号、单引号、甚至不用引号包围，浏览器都是支持的。所以Google为了节省字节会采用不用引号的风格，大概对访问量极大的网站这也是一种省钱的方式吧
			<div class="memo-time">2017/9/4</div></div>
			
			<div class="memo-card">当页面的UI需要在后台数据返回后进行刷新时，一定要考虑到网络极差的情况下，请求会延迟很久后返回。这期间UI要怎样展示，或者用户能否进行操作，会不会有遗留的表单数据等等。
			<div class="memo-time">2017/9/13</div></div>
			
			<div class="memo-card">关于正则表达式量词(Regexp Quantifier)<pre>? =&gt; {0,1}<br>+ =&gt; {1,}<br>* =&gt; {0,}</pre>如果只有一个量词则为贪婪匹配，会尽可能的匹配更多结果。如果量词后附加后缀?则进行非贪婪匹配。
			<div class="memo-time">2017/9/28</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">关于采集站点的PV、UV数据，传统的做法是当页面load完成后像后台发送数据，当作一次PV<br>
			但在SPA(Single Page App)以及PWA(Progressive Web App)的情景下，这样的断定方式显得不那么合理，用户有可能一天中只Load一次页面然后在一天的任意时间段在这个应用中活动而不需要再一次Load页面<br>
			考虑用更新的方式进行统计可能比较合理，例如借助<a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API">Page Visibility API</a>在用户初次打开应用浏览以及过去合理的一段时间后(可以用Session持续的最长时间来判断)后从其它再次切换到这个Tab页都作为一次PV<br>
			详情可见这篇<a href="https://philipwalton.com/articles/how-we-track-pageviews-is-all-wrong/">Blog</a>
			<div class="memo-time">2017/8/14</div></div>

			<div class="memo-card">在新的HTML5规范中，如果一个元素拥有ID属性，那么ID属性的属性值就会成为window对象的属性名，属性值就是ID对应的元素。如果下列标签中的元素拥有name属性<code>&lt;a&gt; &lt;applet&gt; &lt;area&gt; &lt;embed&gt; &lt;form&gt; &lt;frame&gt; &lt;frameset&gt; &lt;iframe&gt; &lt;img&gt; &lt;object&gt;</code>那么name属性的属性值就会成为window对象的属性名。例如页面上有这么一个元素<code>&lt;div id=&quot;a&quot;&gt;&lt;/div&gt;</code>在script中<pre>console.info(a)<br>//结果为&lt;div id=&quot;a&quot;&gt;&lt;/div&gt;</pre>
			<div class="memo-time">2017/8/23</div></div>
			
			<div class="memo-card"><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;</code>在HTML中俩者都可用来表明页面所采用的字符集，各浏览器的兼容性良好，但后者更短建议采用后者
			<div class="memo-time">2017/9/5</div></div>
			
			<div class="memo-card">匹配中文字符（简繁体都包含）的正则<code>/^[\u4e00-\u9fa5]+$/</code>暂时无法确认其是否完全正确
			<div class="memo-time">2017/11/9</div></div>
		</div>
		<div class="memo-col">
			<div class="memo-card">HTML5新增了<code>input</code>事件来监听文本框的输入变化，但在IE9下存在用户删除输入或剪切文本时不会触发该事件的Bug,并且IE8下没有该事件，需同时监听<code>propertychange</code>来实现兼容IE8
			<div class="memo-time">2017/8/17</div></div>
			
			<div class="memo-card">阅读垠神博客有感  1.会写程序不是一件很了不起的事情，不要自负  2.语言、框架都只是工具，会用即可，不必过于推崇，重要的是我们脑海里的思想  3.开发软件也是一种工程，一定要极力避免Bug，这才是一个工程师该做的  4.面对同事、新人的提问请耐心解答，不要动不动就让提问者自行Google  5.不要觉得向他人提问是什么难为情的事，世界上总有东西是你不清楚的，哪怕是你日常工作所用的东西  6.复杂的代码不是显示能力的途径，简单易懂的才是
			<div class="memo-time">2017/8/30</div></div>
			
			<div class="memo-card">关于HTML中的相对路径<code>./</code>是文档相对路径，也就是当前访问页面的路径<code>/</code>是基于站点根目录的相对路径，举例说明访问网址http://0.0.0.0/1/2/son.html<pre>./test.js =&gt; http://0.0.0.0/1/2/test.js<br>/test.js =&gt; http://0.0.0.0/test.js</pre>
			<div class="memo-time">2017/9/13</div></div>
		</div>
	</main>

	<!-- 右侧导航 -->
	<aside class="memo-anchor">
		<ul>
			<li><a href="#_javascript">JavaScript</a></li>
			<li><a href="#_css">CSS</a></li>
			<li><a href="#_compatibility">兼容性</a></li>
			<li><a href="#_gulp">Gulp</a></li>
			<li><a href="#_webpack">Webpack</a></li>
			<li><a href="#_jquery">jQuery</a></li>
			<li><a href="#_react">React</a></li>
			<li><a href="#_http">HTTP</a></li>
			<li><a href="#_other">杂项</a></li>
		</ul>
	</aside>

	<script type="text/javascript" src="./assets/js/main.js"></script>
</body>
</html>
