(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{"./src/blogs/ArrayAPI.md":function(r,n){r.exports="# Array's New API In ES6\r\n## Static Function\r\n\r\n### Array.of()\r\n大部分情况下我们都应该优先使用字面量的形式`const a = [1, 2]`来创建一个数组  \r\n但当我们定义了一个自己的Array子类，并且想要创建子类的数组时就只能通过构造器来实例化了\r\n```js\r\nclass MyArr extends Array {\r\n\tmax() {\r\n\t\tlet max = this[0]\r\n\t\tthis.map(item => {\r\n\t\t\tmax = Math.max(item, max)\r\n\t\t})\r\n\t\treturn max\r\n\t}\r\n}\r\n\r\nconst a = new MyArr(1, 2, 3)\r\na.max() // 3\r\n```\r\n一般情况下上例做法也不会有问题，但是当只传入一个参数时就会产生empty slots（可能是因为历史原因？）\r\n```js\r\nconst b = new MyArr(3) // 通过这种方式生成的不是 [3] 而是 [empty * 3]\r\nb.length // 3\r\nb.max() // undefined\r\n```\r\n使用`Array.of()`来实例化新数组可以避免上述问题\r\n```js\r\nconst c = MyArr.of(3) // [3]\r\nc.length // 1\r\nc.max() // 3\r\n```\r\n\r\n### Array.from()\r\n`Array.from`可用于数组的转化，假设我们有一个Array-Like Object\r\n```js\r\nconst o = {\r\n\tlength: 2,\r\n\t0: 'hello',\r\n\t1: 'world'\r\n}\r\n\r\nconst a = Array.from(o)\r\nconst b = Array.prototype.slice.call(o) // 以往的方式\r\n```\r\n可以看到，在ES6中我们可以很方便的将其转化为一个真正的数组，并且不用担心会产生empty slots\r\n```js\r\nconst o = {\r\n\tlength: 2,\r\n\t0: 'hello'\r\n}\r\n\r\nconst a = Array.from(o) // [\"hello\", undefined]\r\nconst b = Array.prototype.slice.call(o) // [\"hello\", empty]\r\n```\r\n该方法的第一个参数可以是任意Iterable的对象，并将其迭代产生的值依次放到一个数组中返回\r\n```js\r\n// 可用于复制数组\r\nconst arr = [1, 2, 3]\r\nconst arrCopy = Array.from(arr) // 更简洁 更易理解\r\nconst arrCopy2 = arr.slice() // 以往的方式\r\n```\r\n该方法的第二个参数可以接受一个函数，并依次对每一个值通过函数处理后再放到结果数组中\r\n```js\r\nconst arr = [1, 2, 3]\r\nconst arrCopy = Array.from(arr, item => item + 1) // [2, 3, 4]\r\n```\r\n\r\n## Prototype Method\r\n\r\n### copyWithin(target, start, end)\r\n该方法可以将数组的一部分复制到该数组特定位置，并覆盖原值  \r\n会直接修改原数组而不是产生一个新数组\r\n```js\r\nlet arr = [1, 2, 3, 4, 5]\r\n// 可以看到不明确提供start和end参数时该方法会从下标0处开始尽可能的拷贝更多的值\r\narr.copyWithin(1) // [1, 1, 2, 3, 4]\r\n\r\narr = [1, 2, 3, 4, 5]\r\narr.copyWithin(1, 0) // [1, 1, 2, 3, 4]\r\n\r\narr = [1, 2, 3, 4, 5]\r\narr.copyWithin(1, 0, 0)  // [1, 2, 3, 4, 5]\r\n\r\narr = [1, 2, 3, 4, 5]\r\narr.copyWithin(1, 0, 1)  // [1, 1, 3, 4, 5]\r\n\r\narr = [1, 2, 3, 4, 5]\r\n// 拷贝过程并不是严格的按照从左到右一个个执行的\r\n// 若果严格按照顺序执行的话，程序的结果应该是[1, 2, 2, 2, 2]\r\n// 可以假定执行过程如下\r\n// [1, 2, 2, 4, 5]\r\n// [1, 2, 2, 2, 5]\r\n// [1, 2, 2, 2, 2]\r\narr.copyWithin(2, 1) // [1, 2, 2, 3, 4]\r\n```\r\n### fill(value, start, end)\r\n该方法可以向数组中的指定位置填充值\r\n```js\r\n// 未明确指定start和end时会尽可能的填充更多的值\r\nnew Array(3).fill('hello') // ['hello', 'hello', 'hello']\r\n[null, null, null].fill('hello', 1) // [null, 'hello', 'hello']\r\n[null, null, null].fill('hello', 1, 2) // [null, 'hello', null]\r\n```\r\n\r\n### find()\r\n以往我们想要判断数组中是否包含某个元素通常是借助`indexOf()`\r\n```js\r\nconst arr = [1, '2', {name: 'hello'}]\r\narr.indexOf(1) !== -1 // true\r\narr.indexOf('2') !== -1 // true\r\narr.indexOf(2) !== -1 // false\r\n```\r\n这种方法有几个缺点:\r\n* 通过严格的===来比较\r\n* 需要通过判断是否等于-1来得出我们要的布尔值结果\r\n* 不能实现自定义的匹配条件\r\n\r\nES5中新增的`some()`解决了上述问题\r\nPS: 当我们不需要自定义匹配条件，想利用全等来比较时  \r\n可以采用ES7新增的更便捷的方法`Array.prototype.includes()`\r\n```js\r\nconst arr = [1, '2', {name: 'hello'}]\r\narr.some(v => v == 2) // true\r\narr.some(v => v.name === 'hello') // true\r\n\r\narr.includes(1) // true\r\n```\r\n大部分情况下这种方法都没有问题，但当我们想要直接获得正确匹配到的值  \r\n这时候就可以借助ES6的`find()`\r\n```js\r\nconst arr = [1, '2', {name: 'hello'}]\r\narr.find(v => v == 2) // '2'\r\narr.find(v => v,name === 'hello') // {name: 'hello'}\r\narr.find(v => v === 666) // undefined\r\n```\r\n\r\n### findIndex()\r\n总结一下上述数组的查找方法，可以发现，当我们只想确定是否存在特定值时可以采用`some()`  \r\n当我们想拿到符合比较条件的值时可以采用`find()`  \r\n如果我们想要拿到符合比较条件值的下标时就需要用到ES6的`findIndex()`\r\n```js\r\nconst arr = [1, '2', {name: 'hello'}]\r\narr.findIndex(v => v == 2) // 1\r\narr.findIndex(v => v,name === 'hello') // 2\r\narr.findIndex(v => v === 666) // -1\r\n```\r\n不难发现该方法和`indexOf()`的差别仅在于可以自定义匹配条件\r\n\r\n### entries() values() keys()\r\n类似`Map` `Set`等ES6新增的Collections，Array也提供了一系列的借助Iterator的迭代方法\r\n```js\r\nconst arr = [1, 2, 3]\r\n[...arr.values()] // [1, 2, 3]\r\n[...arr.entries()] // [[0, 1], [1, 2], [2, 3]]\r\n[...arr.keys()] // [0, 1, 2]\r\n```\r\n"},"./src/blogs/Collections.md":function(r,n){r.exports="# New Collections In ES6\r\n\r\n## Map\r\n以往当我们需要一种键/值对形式的数据结构时通常考虑采用原生的Object\r\n```js\r\nconst o = {}\r\no[1] = 1\r\no['a'] = 'a'\r\nconsole.log(o) // { 1: 1, a: 'a'}\r\no['1'] = 2\r\nconsole.log(o) // {1: 2, a: 'a'}\r\n\r\nconst map = {}\r\nconst x = { a: 1 }\r\nconst y = { b: 2 }\r\nmap[x] = 1\r\nmap[y] = 2\r\n// 因为x.toString() === '[object Object]'\r\nconsole.log(map) // {[object Object]: 2}\r\n```\r\n可以看到这种方法有一个缺陷，由于Object的Key只能是字符串  \r\n这样生成的Map同样只能以字符串作为键  \r\nES6提供了对Map的原生支持，它可以将任何数据类型作为Key\r\n```js\r\nconst map = new Map()\r\nconst x = { a: 1 }\r\n// 支持链式调用\r\nmap.set(x, 1).set(2, 2).set('2', 2)\r\n\t.set(Symbol.for('sym'), 'symbol').set(true, true)\r\n\r\nmap.get(x) // 1\r\nmap.get(2) // 2\r\nmap.get('2') // 2\r\nmap.get(Symbol.for('sym')) // 'symbol'\r\nmap.get(true) // true\r\n\r\nmap.size // 5\r\n\r\nmap.delete(true)\r\nmap.delete(x)\r\nmap.delete('2')\r\n\r\nmap.size // 2\r\n\r\nmap.has(2) // true\r\nmap.has(Symbol.for('sym')) // true\r\n\r\n[...map.keys()] // [2, Symbol(sym)]\r\n[...map.values()] // [2, \"symbol\"]\r\n[...map.entries()] // [[2, 2], [Symbol(sym), \"symbol\"]]\r\n\r\nmap.clear()\r\nmap.size // 0\r\n```\r\nMap的实例是Iterable的，并且其默认的Iterator与`map.entries()`一致  \r\n所以以下方法都可以用于拷贝产生一个新的Map\r\n```js\r\nconst map = new Map()\r\nconst copy2 = new Map(map.entries())\r\nconst copy1 = new Map(map) // 推荐 更简洁\r\n```\r\n\r\n## WeakMap\r\nWeakMap的大部分行为与Map一致，主要区别在于WeakMap对内存分配机制的特殊处理  \r\nWeakMap只接受把Object作为Key，并且当作为Key的对象被GC回收后  \r\n其存储在WeakMap中的Entry也会随之被销毁  \r\nWeakMap相比Map只提供了`set()` `get()` `delete()` `has()` 四个有限的API  \r\n尤其适用于需要把不受我们控制的对象(例如DOM对象)作为Key值的情况\r\n\r\n## Set\r\nES6新增的Set用于存储一系列不允许重复的值  \r\n其判断是否重复的机制与`Object.is()`几乎相同，除了Set会认为0与-0相等\r\n```js\r\nconst set = new Set()\r\nconst x = { a: 1 }\r\nconst y = { b: 2 }\r\n// 支持链式调用\r\nset.add(x).add(y).add(x)\r\n\r\nset.size // 2\r\n\r\nset.delete(y)\r\nset.size // 1\r\n\r\nset.has(x) // true\r\nset.clear()\r\nset.size // 0\r\n\r\nset.add(1).add('1').add(2);\r\n[...set.keys()] // [1, \"1\", 2]\r\n[...set.values()] // [1, \"1\", 2]\r\n[...set.entries()] // [[1, 1], [\"1\", \"1\"], [2, 2]]\r\n```\r\n与Map不同的是Set实例的默认Iterator与`values()`相同  \r\n可以利用Set来进行数组去重\r\n```js\r\nconst arr = [1, 1, 2, 3, 3, 4, '4']\r\nconst unique = [...new Set(arr)]\r\nconsole.log(unique) // [1, 2, 3, 4, \"4\"]\r\n```\r\n\r\n## WeakSet\r\n同WeakMap类似，WeakSet只接受Object作为值  \r\n并且当对象被GC后WeakSet也会将其从集合中删除\r\n"},"./src/blogs/Generator.md":function(r,n){r.exports="# Generator in ES6\r\n## 序\r\nGenerator不同于一般的函数，它可以在执行过程中被暂停然后在稍后的任意时刻恢复执行，并且在过程中可以与外界双向传递数据\r\n\r\n## 如何写一个最简单的Generator\r\n```js\r\nfunction *foo() {\r\n\treturn 'hello'\r\n}\r\n\r\nconst it = foo()\r\nit.next() // { value: 'hello', done: true}\r\n```\r\n与普通函数的不同的是调用一个Generator并不会立即执行函数体，而是返回一个Iterator来控制这个Generator的执行\r\n\r\n## 如何写一个有意义的Generator\r\n上例中的Generator并没有特殊的意义，因为它中间并没有暂停的步骤，若想让一个Generator可以中断需要使用ES6新引入的关键字`yield`\r\n```js\r\nfunction *foo() {\r\n\tconst a = yield 'hello'\r\n\tconsole.log(a)\r\n\t\r\n\tconst b = yield 'world'\r\n\tconsole.log(b)\r\n\t\r\n\treturn 'finish'\r\n}\r\n```\r\n下面来依次执行上述Generator，看看每一步的结果\r\n```js\r\nconst it = foo() // 获得Iterator\r\nit.next('step 1')\r\n// {value: \"hello\", done: false}\r\n```\r\n初次执行，代码会停在`const a = yield 'hello'`处，hello作为返回值被抛到函数外\r\n\r\n需要注意的是这里通过`next()`传入的值不会被函数接受，因为**yield**将自身替换为外部传入值的时机是在代码恢复执行时\r\n```js\r\nit.next('step 2')\r\n// 'step 2'\r\n// {value: \"world\", done: false}\r\n```\r\n第二次执行，代码会停在`const b = yield 'world'`处，我们在`next()`中传入的`'step2'`被赋值给变量`a`\r\n\r\n可以看做`yield 'hello'`被替换成了`'step2'`，world作为返回值被抛出\r\n```js\r\nit.next('step 3')\r\n// 'step 3'\r\n// {value: \"finish\", done: true}\r\n```\r\n最后一次执行，`'step3'`被赋值给变量`b`，Generator执行完毕，finish作为返回值被抛出\r\n\r\n## `yield *`\r\n**yield delegation**可以把当前Generator的控制委派给另一个Iterator  \r\n```js\r\nfunction *foo() {\r\n\tyield *[1, 2, 3]\r\n}\r\nfor (v of foo()) {\r\n\tconsole.log(v) // 1 2 3\r\n}\r\n```\r\n"},"./src/blogs/GulpPlugin.md":function(r,n){r.exports='# 如何编写一个自己的GulpPlugin\r\n\r\n```\r\nconst through = require("through-gulp"),\r\n\tfs = require("fs")\r\n\r\nfunction myPlugin() {\r\n\treturn through(function(file, encoding, callback) {\r\n\t\tlet result, origin\r\n\t\t\r\n\t\t// 传入的文件为空\r\n\t\tif (file.isNull()) {\r\n\t\t\tthrow "Please Check Files!"\r\n\t\t}\r\n\r\n\t\t// buffer对象可以直接操作\r\n\t\tif (file.isBuffer()) {\r\n\t\t\t//拿到单个文件buffer             \r\n\t\t\tfile.contents = new Buffer(file.contents.toString("utf-8"),"utf-8")\r\n\t\t}\r\n\t\t \r\n\t\t// stream流是不能操作的,可以通过fs.readFileSync\r\n\t\tif (file.isStream()) {\r\n\t\t\t// 同步读取\r\n\t\t\tfile.contents = new Buffer(s.readFileSync(file.path).toString("utf-8"),"utf-8")\r\n\t\t}\r\n\r\n\t\torigin = file.contents.toString("utf-8") // 转化为字符串\r\n\t\tresult = doYourPluginWork(origin) // 处理源文件 实现插件的逻辑\r\n\t\tfile.contents = new Buffer(result) // 将源文件的内容替换为插件处理完之后的内容\r\n\r\n\t\tthis.push(file)\r\n\t\tcallback() // 声明文件已处理完毕\r\n\t}, function(callback) {\r\n\t\tcallback() // 声明文件已处理完毕\r\n\t})\r\n}\r\n\r\nmodule.exports = myPlugin\r\n```\r\n'},"./src/blogs/Iterator.md":function(r,n){r.exports="# Iterator in ES6\r\n## Iterator 与 Iterable\r\nIterator可以看做一个拥有特定格式的对象，可供ES6提供的遍历->`for of`和解构->`...`等操作消费，并按顺序依次产出结果，样例如下\r\n```js\r\n// 除了以下俩个值外也可以额外返回更多的自定义属性\r\nconst IteratorResult = {\r\n\tvalue: ..., // 每次迭代产出的真实值\r\n\tdone: ..., // true|false true代表迭代结束 与true相对应的value一般建议为undefined\r\n}\r\n\r\nconst Iterator = {\r\n\t// 必须 用于返回每次迭代的结果集\r\n\tnext() { return IteratorResult},\r\n\t// 可选 提前结束迭代时做相应的资源清理操作并返回最后的结果集\r\n\treturn() {},\r\n\t// 可选 抛出异常信息并返回最后的结果集\r\n\tthrow() {}\r\n}\r\n```\r\n而Iterable则是指一个对象实现了Iterable接口(简单来说就是对象上有一个key为Symbol.iterator的方法并且这个方法会生成一个Iterator)\r\n```js\r\nconst Iterable = {\r\n\t[Symbol.iterator]() {return Iterator}\r\n}\r\n```\r\n\r\n## 如何构造一个简单的Iterable对象\r\n```js\r\nlet rand = Math.random()\r\n// 会随机产生一串数字的Iterable对象\r\nconst iterable = {\r\n\t// 必备!!! 这样才能使该对象变为Iterable\r\n\t[Symbol.iterator]() {return this},\r\n\t// 依次去获取数据\r\n\tnext() {\r\n\t\tif (rand > 0.5) {\r\n\t\t\trand = Math.random()\r\n\t\t\treturn {\r\n\t\t\t\tvalue: rand,\r\n\t\t\t\tdone: false\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\tdone: true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n// 该对象可以用for of遍历\r\nfor (let value of iterable) {\r\n\tconsole.log(value)\r\n}\r\n```\r\n\r\n## 如何构造一个完整的Iterable对象\r\n```js\r\n// 该对象可以步进的产生对数据的每一步累加结果\r\nconst stepAccumulator = {\r\n\t[Symbol.iterator]() {\r\n\t\tlet sum = 0\r\n\t\tlet index = 0\r\n\t\tconst data = this.data.slice()\r\n\t\tlet done = false\r\n\t\treturn {\r\n\t\t\t// 使迭代器(Iterator)本身可迭代(Iterable)\r\n\t\t\t[Symbol.iterator]() { return this },\r\n\t\t\tnext() {\r\n\t\t\t\tconst value = sum += data[index]\r\n\t\t\t\tindex++\r\n\t\t\t\tif (index <= data.length && !done) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tvalue,\r\n\t\t\t\t\t\tdone: false\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdone: true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\treturn(v) {\r\n\t\t\t\tconsole.log('abandoned')\r\n\t\t\t\tdone = true\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: v,\r\n\t\t\t\t\tdone: true\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tthrow(e) {\r\n\t\t\t\tconsole.log('error')\r\n\t\t\t\tdone = true\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: e,\r\n\t\t\t\t\tdone: true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tdata: []\r\n}\r\n// 设置数据\r\nstepAccumulator.data = [1, 2, 3]\r\nconsole.log(...stepAccumulator) // 1 3 6\r\n\r\n// 1 3 'abandoned'\r\nfor (let v of stepAccumulator) {\r\n\tconsole.log(v)\r\n\tif (v > 1) break\r\n}\r\n\r\nconst it = stepAccumulator[Symbol.iterator]()\r\nit.next() // { value:1, done: false }\r\nit.throw('!!!') // 'error' { vallue:'!!!', done: true }\r\nit.next() // { done: true }\r\n```\r\n* `return()`和`throw()`都可以通过**Iterator**调用，并且通常来说在调用过后便不应该能通过该迭代器获取到更多的值\r\n* 一般来说**Iterable**对象可以同时生成多个**Iterator**，且相互间的迭代不会互相影响，当然你也可以把迭代器设为单例\r\n* 任何一种取消或者提前终止迭代的行为都会使得**Iterator**自动调用`return()`来处理相关的清理工作\r\n\r\n## ES6自带的Iterable数据结构\r\n包括`String` `Map` `Set` `Array`等\r\n```js\r\nconst str = 'abc'\r\nconst arr = [1, 2, 3]\r\nconst map = new Map()\r\nmap.set('a', 1)\r\nmap.set('b', 2)\r\nfor (let v of str) {\r\n\tconsole.log(v) // 'a' 'b' 'c'\r\n}\r\nfor (let v of arr) {\r\n\tconsole.log(v) // 1 2 3\r\n}\r\nfor (let v of map) {\r\n\tconsole.log(v) // ['a', 1] ['b', 2]\r\n}\r\n```\r\n"},"./src/blogs/ObjectAPI.md":function(r,n){r.exports="## Object's New API In ES6\r\n\r\n### Object.is()\r\n该方法用于比较俩个值是否相等，基本的比较逻辑与`===`一致但是更加严格\r\n```js\r\nconst x = NaN\r\nconst y = 0\r\nconst z = -0\r\n\r\nx === x // false\r\nObject.is(x, x) // true\r\ny === z // true\r\nObject.is(y, z) // false\r\n```\r\n当不需要考虑这几种特殊情况时，直接用`===`比较更方便\r\n\r\n### Object.getOwnPropertySymbols()\r\nES6新增的`Symbol`可以作为对象上的特殊属性使用  \r\n有时我们可能希望只获得一个对象上的所有`Symbol`属性，排除其他普通属性  \r\n这个时候就可以借助该方法\r\n```js\r\nconst o = {\r\n\tfoo: 'hello',\r\n\t[ Symbol('bar') ]: 'world'\r\n}\r\n\r\nconst symbols = Object.getOwnPropertySymbols(o) // [Symbol(bar)]\r\no[symbols[0]] // 'world'\r\n```\r\n\r\n### Object.setPrototypeOf()\r\n该方法提供了一种更优雅的方式来修改一个对象的原型\r\n```js\r\nconst o1 = {\r\n\tbar: 1\r\n}\r\nconst o2 = {\r\n\tfoo: 2\r\n}\r\n\r\nObject.setPrototypeOf(o1, o2)\r\no1.foo // 2\r\no1.__proto__ === o2 // true\r\n\r\n// 将o1设置为无原型对象 类似 const o = Object.create(null)\r\n// 这种做法通常是为了获得一个纯净的对象来作为Map使用\r\n// 现在ES6新增了原生的Map结构 可以考虑避免使用这种技巧\r\nObject.setPrototypeOf(o1, null)\r\no1.__proto__ // undefined\r\n```\r\n\r\n### Object.assign()\r\n由于React/Vue/Angular等数据驱动的前端框架的流行  \r\n这个方法在平常项目中使用频率很高，用于将一系列对象中的值复制到目标对象中  \r\n并且会对各对象相同key的(enumerable)值按先后顺序进行覆盖\r\n```js\r\nlet o1 = { a: 1 }\r\nlet o2 = { b: 2 }\r\n\r\nObject.assign({}, o1, o2) // { a: 1, b: 2 }\r\n\r\nObject.defineProperty(o2, 'c', {\r\n\tvalue: 3,\r\n\tenumerable: false\r\n})\r\n\r\nObject.defineProperty(o2, 'd', {\r\n\tvalue: 4,\r\n\tenumerable: true\r\n})\r\n\r\n// 可以看到 enumerable为false的属性不会被拷贝\r\nObject.assign({}, o1, o2) // { a: 1, b: 2, d: 4}\r\n\r\no2[Symbol('bar')] = 5\r\n// Symbol属性也会被拷贝\r\nObject.assign({}, o1, o2) // { a: 1, b: 2, d: 4, Symbol(bar): 5}\r\n```\r\n值得注意的是，该方法的拷贝过程是浅拷贝  \r\n类似于对每个属性进行`target = src`的赋值  \r\n所以碰到数组、对象之类的复杂数据结构时要多加小心\r\n"},"./src/blogs/Promise.md":function(r,n){r.exports="# Promise In ES6\r\n\r\n## 序\r\n以往我们大多用回调函数来处理工作中碰到的异步编程情况  \r\n当嵌套过深（Callback Hell）时便会让我们的程序很难读懂\r\n```js\r\nfunction foo(cb) {\r\n\tasyncFunc1(() => {\r\n\t\tcb()\r\n\t\tasyncFunc2(() => {\r\n\t\t\tcb()\r\n\t\t\tasyncFun3(() => {\r\n\t\t\t\tcb()\r\n\t\t\t})\r\n\t\t})\r\n\t})\r\n}\r\n```\r\nES6新增的Promise提供了一种更优雅的方式来处理异步编程\r\n\r\n## 如何构造一个基础的Promise\r\n```js\r\nconst p = new Promise((resolve, reject) => {\r\n\tconst rand = Math.random()\r\n\tsetTimeout(() => {\r\n\t\tif (rand > 0.5) {\r\n\t\t\tresolve('finish')\r\n\t\t} else {\r\n\t\t\treject('err')\r\n\t\t}\r\n\t}, 3000)\r\n})\r\n\r\n// 在3秒后输出'finish' or 'err'\r\np.then(res => console.log(res))\r\n.catch(err => console.log(err))\r\n\r\n// 同上\r\np.then(res => console.log(res), err => console.log(err))\r\n```\r\n一个Promise最终只会有俩个状态**fulfilled**或者**rejected**  \r\n前者可以在`then()`的第一个参数中获得处理完成的结果  \r\n后者可以在`then()`的第二个参数或者`catch()`中获得处理失败的原因  \r\n每一个Promise只会被resolve(fulfill 或者 reject)一次 \r\n并且一旦一个Promise执行完毕，它就成为了一个不可变的值  \r\n\r\n## Promise是如何避免Callback Hell的\r\n```js\r\nfunction asyncFunc1() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('1 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nfunction asyncFunc2() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('2 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nfunction asyncFunc3() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('3 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nasyncFunc1().then(res => {\r\n\tconsole.log(res)\r\n\treturn asyncFunc2()\r\n}).then(res => {\r\n\tconsole.log(res)\r\n\treturn asyncFunc3()\r\n}).then(res => {\r\n\tconsole.log(res)\r\n})\r\n// 3s后 \"1 done\"\r\n// 再3s后 \"2 done\"\r\n// 再3s后 \"3 done\"\r\n```\r\n通过上例可以看出，正确的使用Promise可以使得我们程序中的异步流程更为清晰  \r\n可以说完美的避开了Callback Hell\r\n\r\n## Promise API\r\n\r\n### Promise.resolve() 和 Promise.reject()\r\n```js\r\nconst p1 = Promise.resolve(1)\r\nconst p2 = new Promise(resolve => resolve(1))\r\n\r\nconst p3 = Promise.reject(1)\r\nconst p4 = new Promise((resolve, reject) => reject(1))\r\n```\r\n可以通过`Promise.resolve()`将thenable对象转为真正的Promise对象  \r\n如果你以前用了类似Promise语法的异步处理库  \r\n现在想将其行为转成和Promise一致时可能会用到\r\n\r\n### Promise.all([...])\r\n该方法可以传入一个包含多个Promise的数组  \r\n它会等到其中所有的异步处理完成(fulfilled)后将结果集放到数据中返回  \r\n或者其中任意一个处理失败(rejected)后将错误抛出\r\n```js\r\nconst p1 = 1\r\nconst p2 = Promise.resolve(2)\r\nconst p3 = new Promise((resolve, reject) => {\r\n\tsetTimeout(() => {\r\n\t\tresolve(3)\r\n\t}, 3000)\r\n})\r\n\r\n// 3s后输出 [1, 2, 3]\r\nPromise.all([p1, p2, p3]).then(res => console.log(res))\r\n\r\nconst e1 = new Promise((resolve, reject) => {\r\n\tsetTimeout(() => {\r\n\t\treject('err')\r\n\t}, 1000)\r\n})\r\n\r\n// 1s后输出 \"err\"\r\nPromise.all([p1, p2, p3, e1])\r\n.then(res => console.log(res))\r\n.catch(err => console.log(err))\r\n```\r\n\r\n### Promise.race([...])\r\n与`Promise.all()`不同，该方法只会等到第一个执行完毕的Promise  \r\n不管是接受(resolve)或是拒绝(reject)  \r\n除最快执行完的其余Promise的处理结果都会被忽略\r\n```js\r\nconst p1 = new Promise((resolve, reject) => {\r\n\tsetTimeout(() => {\r\n\t\tresolve(1)\r\n\t}, 1000)\r\n})\r\nconst p2 = new Promise((resolve, reject) => {\r\n\tsetTimeout(() => {\r\n\t\tresolve(2)\r\n\t}, 2000)\r\n})\r\n// 1s后输出 1\r\n// 无论执行多少遍都是该结果 永远不会输出2\r\nPromise.race([p1, p2]).then(res => console.log(res))\r\n```\r\n要注意的是当传入空数组时`Promise.all([])`会立即执行完毕  \r\n而`Promise.race([])`会永远处于等待状态，所以建议永远别这么使用Promise\r\n\r\n## `async` + `await` （ES7）\r\n当ES6的Generator与Promise异步编程共同使用时可以产生一些更酷的特性  \r\n让我们能够向写同步代码一样去实现异步过程  \r\n但是需要实现一个特殊的Runner来执行这个Generator  \r\nES7新增了语法糖`async`以及`await`来帮助我们实现相同的功能\r\n```js\r\nfunction asyncFunc1() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('1 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nfunction asyncFunc2() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('2 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nfunction asyncFunc3() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('3 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nasync function main() {\r\n\tconst res1 = await asyncFunc1()\r\n\tconsole.log(res1)\r\n\tconst res2 = await asyncFunc2()\r\n\tconsole.log(res2)\r\n\tconst res3 = await asyncFunc3()\r\n\tconsole.log(res3)\r\n}\r\n\r\n// 3s后 \"1 done\"\r\n// 再3s后 \"2 done\"\r\n// 再3s后 \"3 done\"\r\nmain()\r\n```\r\n可以看到，相较于`Promise.then(...).then(...)`  \r\n这种方式让异步程序的执行顺序更加一目了然\r\n"},"./src/blogs/Symbol.md":function(r,n){r.exports="# Symbols in ES6\r\n`Symbol`是ES6中(时隔多年)新增的一种**primitive type**，可以把它看做一种自动生成**唯一字符串**的机制，它的真实值被隐藏在代码后且永远无法直接获得\r\n\r\n## 如何生成Symbol\r\n```js\r\n// 最基础的方式\r\nconst a = Symbol()\r\n\r\n// 可以传入一串描述该Symbol用途的字符串作为参数\r\nconst b = Symbol('some description text')\r\n\r\n// 从全局的Symbol库中查询所需的Symbol\r\n// 如果未找到则新建一个并返回\r\n// 这种方式较以上直接构造Symbol的优点在于\r\n// 可以不必在外部作用域中专门维护一个变量用于存储生成的Symbol\r\nconst c = Symbol.for('my Symbol')\r\n\r\n// 由于不管如何Symbol都是全局存在的\r\n// 为了尽量避免可能发生的冲突 可以给Symbol添加相应的前缀\r\nconst d = Symbol.for('prefix.Symbol')\r\n```\r\n\r\n## 如何判断一个值是否为Symbol\r\n```js\r\nconst a = Symbol()\r\n// 推荐方式\r\ntypeof a === 'symbol'// true\r\n\r\n// 其余方式\r\na instanceof Symbol // false\r\nObject(a) instanceof Symbol // true\r\nObject(a).valueOf() === a // true\r\n```\r\n\r\n## 如何获得Symbol的描述字符串\r\n```js\r\nconst a = Symbol('desc a')\r\nconst b = Symbol.for('desc b')\r\n\r\nSymbol.keyFor(a) // undefined\r\nSymbol.keyFor(b) // desc b\r\n\r\na.toString() // Symbol(desc a)\r\nb.toString() // Symbol(desc b)\r\n```\r\n通过上述对比，个人感觉用`Symbol.for()`来生成`Symbol`好像更加合适\r\n\r\n不仅可以避免使用不必要的变量污染作用域，并且能更方便的获得其描述\r\n\r\n## Symbol的用途\r\n借助`Symbol`来实现单例模式\r\n```js\r\nconst Instance = Symbol.for('instance')\r\nfunction singleton() {\r\n\tif (singleton[Instance]) {\r\n\t\treturn singleton[Instance]\r\n\t}\r\n\t\r\n\treturn singleton[Instance] = {}\r\n}\r\nconst a = singleton()\r\nconst b = singleton()\r\na === b // true\r\n```\r\n\r\n如果将上例中的Symbol替换成任意一个不规则字符串（Magic String）对逻辑的实现并无影响\r\n\r\n所以从这个角度看来，Symbol的出现更多的是对代码或者说程序层面上的提升，而不是函数性的提升\r\n\r\n```js\r\nconst o = {\r\n\tfoo: 1,\r\n\t[Symbol.for('bar')]: 2\r\n}\r\nObject.getOwnPropertyNames(o) // ['foo']\r\nObject.getOwnPropertySymbols(o) // [Symbol(for)]\r\nObject.keys(o) // ['foo']\r\nfor (let key in o ){\r\n\tconsole.log(key) // 'foo'\r\n}\r\n```\r\n\r\n可以看到，虽然Symbol作为Object的属性key不会被当作普通的键值被获取\r\n\r\n但是还是有特殊途径来获得，所以并不能试图通过Symbol把Object的部分属性隐藏(作为外部不可访问的私有属性)\r\n\r\n## Built-in Symbols\r\n个人感觉ES6自身提供的Built-in Symbols会是最常见的`Symbol`使用方式，例如`Symbol.iterator`:\r\n```js\r\nconst arr = [1, 2, 3]\r\narr[Symbol.iterator] // native function\r\nconst it = arr[Symbol.iterator]() // 获得数组arr的Iterator\r\n```\r\n值得一提的是这些内部的Symbol并不是像我们自定义的那样注册到全局库中\r\n\r\n而是作为Symbol构造函数的静态属性对外提供\r\n\r\n"},"./src/blogs/WebpackBaseConfig.md":function(r,n){r.exports="# Webpack(v3.8.1)\r\n```\r\nconst path = require('path')\r\nconst webpack = require('webpack')\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\r\nconst pkg = require(path.join(__dirname, 'package.json'))// package.json\r\n\r\n// 定义项目中的一些文件夹路径\r\nconst APP_PATH = path.resolve(__dirname, 'src')\r\n\r\nlet theme = {}\r\n// pkg.theme存的是项目中antd主题文件的路径\r\n// 这里是 ./antd-theme.js\r\nif (pkg.theme && typeof(pkg.theme) === 'string') {\r\n  theme = require(path.resolve(__dirname, pkg.theme))\r\n}\r\n\r\nmodule.exports = {\r\n  entry: path.resolve(APP_PATH, 'index.jsx'),\r\n  // 暂时本地开发环境的不配output好像影响不大\r\n  // 后期遇到问题再配\r\n  resolve: {\r\n    // 配置这个后引用node_modules中的依赖包不用加路径 直接import xx from ('antd')即可\r\n    modules: [\r\n      'node_modules'\r\n    ],\r\n    //后缀 配了这个就可以在import时 import xx from (./test) 而不用 import xx from (./test.jsx)\r\n    extensions: ['.js', '.jsx', '.json', '.scss']\r\n  },\r\n  module: {\r\n    rules: [{\r\n      test: /\\.js|\\.jsx$/,\r\n      use: [\r\n        'babel-loader',\r\n        'eslint-loader'\r\n      ],\r\n      exclude: /node_modules/\r\n    }, {\r\n      test: /\\.css$/,\r\n      use: ['css-loader']\r\n    }, {\r\n      test: /\\.less$/,\r\n      use: [{\r\n        loader: 'style-loader'\r\n      },{\r\n        loader: 'css-loader'\r\n      },{\r\n        loader: 'less-loader',\r\n        options: {\r\n          sourceMap: true,\r\n          modifyVars: theme // 用于自定义antd主题 覆盖其less变量\r\n        }\r\n      }],\r\n      include: path.resolve(__dirname, 'node_modules')\r\n    }, {\r\n      test: /\\.scss$/,\r\n      use: [\r\n        'style-loader',\r\n        'css-loader',\r\n        'sass-loader'\r\n      ],\r\n      include: APP_PATH\r\n    }, {\r\n      // 字体文件之类的需要这个loader支持\r\n      test: /\\.(eot|woff|woff2|svg|ttf)([\\?]?.*)$/,\r\n      use: ['file-loader'],\r\n      include: APP_PATH\r\n    }, {\r\n      test: /\\.(jpe?g|png|gif|svg)$/,\r\n      use: [{\r\n        loader: 'url-loader',\r\n        options: {\r\n          limit: 8192// 小于1kb的图片采用base64编码 并以DATAUrl的形式嵌入页面\r\n        }\r\n      }],\r\n      include: APP_PATH\r\n    }]\r\n  },\r\n  devServer: {\r\n    contentBase: './build',\r\n    historyApiFallback: true,\r\n    hot: true,// 开启HMR\r\n    inline: true,\r\n    compress: true,// 开启gzip\r\n    port: 8080\r\n  },\r\n  plugins: [\r\n    new webpack.NamedModulesPlugin(),// 用于确保多次build生成的bundle名称不变\r\n    new HtmlWebpackPlugin({\r\n      template: 'index.html'// 以根目录下的index.html为模版\r\n    }),\r\n    new webpack.HotModuleReplacementPlugin()// HMR所需\r\n  ],\r\n  devtool: 'cheap-module-eval-source-map'\r\n}\r\n\r\n```\r\n生产环境\r\n```\r\nconst path = require('path')\r\nconst webpack = require('webpack')\r\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\r\nconst CleanWebpackPlugin = require('clean-webpack-plugin')\r\nconst ROOT_PATH = path.resolve(__dirname)\r\nconst APP_PATH = path.resolve(ROOT_PATH, 'src')\r\n\r\nconst pkg = require(path.join(__dirname, 'package.json'))// package.json\r\nlet theme = {}\r\n// pkg.theme存的是项目中antd主题文件的路径\r\n// 这里是 ./antd-theme.js\r\nif (pkg.theme && typeof(pkg.theme) === 'string') {\r\n  theme = require(path.resolve(__dirname, pkg.theme))\r\n}\r\n// 用于提取自己写的css\r\nconst appExtract = new ExtractTextPlugin({filename: 'app.[contenthash].css', allChunks: true})\r\n// 用于提取依赖包的css(主要是Antd)\r\nconst vendorExtract = new ExtractTextPlugin({filename: 'vendor.css', allChunks: true})\r\n\r\nmodule.exports = {\r\n  entry: {\r\n    app: path.resolve(APP_PATH, 'index.jsx'),\r\n    vendor: ['react', 'axios']\r\n  },\r\n  output: {\r\n    path: path.resolve(__dirname, 'build'),\r\n    publicPath: '/',\r\n    filename: '[name].[chunkhash].js',\r\n    chunkFilename: '[name].[chunkhash:5].chunk.js',\r\n  },\r\n  resolve: {\r\n    // 配置这个后引用node_modules中的依赖包不用加路径 直接import xx from ('antd')即可\r\n    modules: [\r\n      'node_modules'\r\n    ],\r\n    //后缀 配了这个就可以在import时 import xx from (./test) 而不用 import xx from (./test.jsx)\r\n    extensions: ['.js', '.jsx', '.json', '.scss']\r\n  },\r\n  plugins: [\r\n    new webpack.optimize.UglifyJsPlugin({\r\n      compress: {\r\n        warnings: false\r\n      }\r\n    }),\r\n    // 与NamedModulesPlugin 但更适用于生成环境\r\n    new webpack.HashedModuleIdsPlugin(),\r\n    // 部分依赖包(React)会在非生产环境中包含一些提示、警告的代码来帮助开发者解决问题\r\n    // 在生产环境通过配置这个可以阻止生成这些代码 减小bundle的size\r\n    new webpack.DefinePlugin({ 'process.env.NODE_ENV': JSON.stringify('production') }),\r\n    // 变动频率小的外部依赖包\r\n    new webpack.optimize.CommonsChunkPlugin({\r\n      name: 'vendor'\r\n    }),\r\n    // webpack的运行环境所需\r\n    new webpack.optimize.CommonsChunkPlugin({\r\n      name: 'runtime'\r\n    }),\r\n    new HtmlWebpackPlugin({\r\n      template: 'index.html'// 以根目录下的index.html为模版\r\n    }),\r\n    new CleanWebpackPlugin('build'),\r\n    appExtract,\r\n    vendorExtract,\r\n  ],\r\n  module: {\r\n    rules: [{\r\n      test: /\\.js|\\.jsx$/,\r\n      use: [\r\n        'babel-loader',\r\n        'eslint-loader'\r\n      ],\r\n      exclude: /node_modules/\r\n    }, {\r\n      test: /\\.css$/,\r\n      use: vendorExtract.extract(['css-loader'])\r\n    }, {\r\n      test: /\\.less$/,\r\n      use: vendorExtract.extract({\r\n        fallback: 'style-loader',\r\n        use: [{\r\n          loader: 'css-loader'\r\n        },{\r\n          loader: 'less-loader',\r\n          options: {\r\n            sourceMap: true,\r\n            modifyVars: theme // 用于自定义antd主题 覆盖其less变量\r\n          }\r\n        }]\r\n      }),\r\n      include: path.resolve(__dirname, 'node_modules')\r\n    }, {\r\n      test: /\\.scss$/,\r\n      use: appExtract.extract({\r\n        fallback: 'style-loader',\r\n        use: ['css-loader','sass-loader']\r\n      }),\r\n      include: APP_PATH\r\n    }, {\r\n      // 字体文件之类的需要这个loader支持\r\n      test: /\\.(eot|woff|woff2|svg|ttf)([\\?]?.*)$/,\r\n      use: ['file-loader'],\r\n      include: APP_PATH\r\n    }, {\r\n      test: /\\.(jpe?g|png|gif|svg)$/,\r\n      use: [{\r\n        loader: 'url-loader',\r\n        options: {\r\n          outputPath: 'images/',// 将图片放入build/images/目录下\r\n          limit: 8192// 小于1kb的图片采用base64编码 并以DATAUrl的形式嵌入页面\r\n        }\r\n      }],\r\n      include: APP_PATH\r\n    }]\r\n  }\r\n};\r\n\r\n```\r\n"},"./src/blogs/WebpackV3ToV4.md":function(r,n){r.exports="# Webpack V3 升级至 V4\r\n## 序\r\n半年没关注，最近突然发现Webpack的版本已经升到4.16.2了，为了紧跟潮流的步伐，决定将项目中使用的3.10.0来个升级\r\n\r\n## 步骤\r\n1. 安装`webpack`以及`webpack-cli`\r\n2. 将项目中所有用到的`loader`以及`plugin`升级到最新\r\n3. 配置文件里新增 `mode: 'development'` or `mode: 'production'`\r\n4. 移除`webpack.optimize.UglifyJsPlugin`，现在webpack会在生产环境默认对js进行压缩\r\n5. 移除`extract-text-webpack-plugin`，v4推荐使用新的`mini-css-extract-plugin`来提取样式文件\r\n6. 引入`optimize-css-assets-webpack-plugin`以及`uglifyjs-webpack-plugin`，并在生产环境的配置文件下新增\r\n\r\n```js\r\nconst UglifyJsPlugin = require(\"uglifyjs-webpack-plugin\")\r\nconst OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\")\r\n\r\nmodule.exports = {\r\n\toptimization: {\r\n\t\tminimizer: [\r\n\t\t\t// 由于配置optimization会覆盖默认值 所以这里需要配一下UglifyJsPlugin\r\n\t\t\tnew UglifyJsPlugin({\r\n\t\t\t\tcache: true,\r\n\t\t\t\tparallel: true,\r\n\t\t\t}),\r\n\t\t\tnew OptimizeCSSAssetsPlugin({})\r\n\t\t]\r\n\t}\r\n}\r\n```\r\n7. 搞定\r\n\r\n## 总结\r\n升级过后打包和编译速度大概提升了15%左右（粗略比较）\r\n\r\n上述只是针对我之前项目配置的升级，并不完整，仅供参考\r\n\r\nWebpack官方有提供详细的迁移[文档](https://webpack.js.org/migrate/4/)\r\n\r\n遇到问题也可以通过报错信息很快定位到原因，再去相应的Github库上找一找解决办法，迁移过程还是比较顺利的\r\n"},"./src/components/Blog/index.jsx":function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var t=function(){function r(r,n){for(var e=0;e<n.length;e++){var t=n[e];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(r,t.key,t)}}return function(n,e,t){return e&&r(n.prototype,e),t&&r(n,t),n}}(),o=y(e("./node_modules/react/index.js")),s=y(e("./src/components/Markdown/index.jsx")),l=y(e("./src/blogs/WebpackBaseConfig.md")),a=y(e("./src/blogs/GulpPlugin.md")),i=y(e("./src/blogs/Symbol.md")),c=y(e("./src/blogs/Iterator.md")),u=y(e("./src/blogs/WebpackV3ToV4.md")),m=y(e("./src/blogs/Generator.md")),d=y(e("./src/blogs/ArrayAPI.md")),p=y(e("./src/blogs/ObjectAPI.md")),b=y(e("./src/blogs/Collections.md")),f=y(e("./src/blogs/Promise.md"));function y(r){return r&&r.__esModule?r:{default:r}}e("./src/components/Blog/style.less");var g=[l.default,a.default,i.default,c.default,u.default,m.default,d.default,p.default,b.default,f.default],h=function(r){function n(){return function(r,n){if(!(r instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),function(r,n){if(!r)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?r:n}(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(r,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(r,n):r.__proto__=n)}(n,o.default.Component),t(n,[{key:"render",value:function(){return o.default.createElement("div",{className:"blogs"},g.map(function(r,n){return o.default.createElement("div",{className:"blog",key:n},o.default.createElement(s.default,{data:r}))}))}}]),n}();n.default=h},"./src/components/Blog/style.less":function(r,n,e){},"./src/components/Markdown/index.jsx":function(r,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var t=c(e("./node_modules/react/index.js")),o=c(e("./node_modules/marked/lib/marked.js")),s=c(e("./node_modules/highlight.js/lib/highlight.js")),l=c(e("./node_modules/highlight.js/lib/languages/javascript.js")),a=c(e("./node_modules/highlight.js/lib/languages/css.js")),i=c(e("./node_modules/highlight.js/lib/languages/xml.js"));function c(r){return r&&r.__esModule?r:{default:r}}e("./node_modules/highlight.js/styles/atom-one-light.css"),e("./src/components/Markdown/style.less"),s.default.registerLanguage("javascript",l.default),s.default.registerLanguage("css",a.default),s.default.registerLanguage("xml",i.default),o.default.setOptions({highlight:function(r){return s.default.highlightAuto(r).value}}),n.default=function(r){return t.default.createElement("div",{className:"my-md",dangerouslySetInnerHTML:{__html:(0,o.default)(r.data)}})}},"./src/components/Markdown/style.less":function(r,n,e){}}]);