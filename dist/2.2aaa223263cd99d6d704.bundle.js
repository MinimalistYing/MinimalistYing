(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{"./src/blogs/ArrayAPI.md":function(r,n){r.exports="# Array's New API In ES6\r\n## Static Function\r\n\r\n### Array.of()\r\n大部分情况下我们都应该优先使用字面量的形式`const a = [1, 2]`来创建一个数组  \r\n但当我们定义了一个自己的Array子类，并且想要创建子类的数组时就只能通过构造器来实例化了\r\n```js\r\nclass MyArr extends Array {\r\n\tmax() {\r\n\t\tlet max = this[0]\r\n\t\tthis.map(item => {\r\n\t\t\tmax = Math.max(item, max)\r\n\t\t})\r\n\t\treturn max\r\n\t}\r\n}\r\n\r\nconst a = new MyArr(1, 2, 3)\r\na.max() // 3\r\n```\r\n一般情况下上例做法也不会有问题，但是当只传入一个参数时就会产生empty slots（可能是因为历史原因？）\r\n```js\r\nconst b = new MyArr(3) // 通过这种方式生成的不是 [3] 而是 [empty * 3]\r\nb.length // 3\r\nb.max() // undefined\r\n```\r\n使用`Array.of()`来实例化新数组可以避免上述问题\r\n```js\r\nconst c = MyArr.of(3) // [3]\r\nc.length // 1\r\nc.max() // 3\r\n```\r\n\r\n### Array.from()\r\n`Array.from`可用于数组的转化，假设我们有一个Array-Like Object\r\n```js\r\nconst o = {\r\n\tlength: 2,\r\n\t0: 'hello',\r\n\t1: 'world'\r\n}\r\n\r\nconst a = Array.from(o)\r\nconst b = Array.prototype.slice.call(o) // 以往的方式\r\n```\r\n可以看到，在ES6中我们可以很方便的将其转化为一个真正的数组，并且不用担心会产生empty slots\r\n```js\r\nconst o = {\r\n\tlength: 2,\r\n\t0: 'hello'\r\n}\r\n\r\nconst a = Array.from(o) // [\"hello\", undefined]\r\nconst b = Array.prototype.slice.call(o) // [\"hello\", empty]\r\n```\r\n该方法的第一个参数可以是任意Iterable的对象，并将其迭代产生的值依次放到一个数组中返回\r\n```js\r\n// 可用于复制数组\r\nconst arr = [1, 2, 3]\r\nconst arrCopy = Array.from(arr) // 更简洁 更易理解\r\nconst arrCopy2 = arr.slice() // 以往的方式\r\n```\r\n该方法的第二个参数可以接受一个函数，并依次对每一个值通过函数处理后再放到结果数组中\r\n```js\r\nconst arr = [1, 2, 3]\r\nconst arrCopy = Array.from(arr, item => item + 1) // [2, 3, 4]\r\n```\r\n\r\n## Prototype Method\r\n\r\n### copyWithin(target, start, end)\r\n该方法可以将数组的一部分复制到该数组特定位置，并覆盖原值  \r\n会直接修改原数组而不是产生一个新数组\r\n```js\r\nlet arr = [1, 2, 3, 4, 5]\r\n// 可以看到不明确提供start和end参数时该方法会从下标0处开始尽可能的拷贝更多的值\r\narr.copyWithin(1) // [1, 1, 2, 3, 4]\r\n\r\narr = [1, 2, 3, 4, 5]\r\narr.copyWithin(1, 0) // [1, 1, 2, 3, 4]\r\n\r\narr = [1, 2, 3, 4, 5]\r\narr.copyWithin(1, 0, 0)  // [1, 2, 3, 4, 5]\r\n\r\narr = [1, 2, 3, 4, 5]\r\narr.copyWithin(1, 0, 1)  // [1, 1, 3, 4, 5]\r\n\r\narr = [1, 2, 3, 4, 5]\r\n// 拷贝过程并不是严格的按照从左到右一个个执行的\r\n// 若果严格按照顺序执行的话，程序的结果应该是[1, 2, 2, 2, 2]\r\n// 可以假定执行过程如下\r\n// [1, 2, 2, 4, 5]\r\n// [1, 2, 2, 2, 5]\r\n// [1, 2, 2, 2, 2]\r\narr.copyWithin(2, 1) // [1, 2, 2, 3, 4]\r\n```\r\n### fill(value, start, end)\r\n该方法可以向数组中的指定位置填充值\r\n```js\r\n// 未明确指定start和end时会尽可能的填充更多的值\r\nnew Array(3).fill('hello') // ['hello', 'hello', 'hello']\r\n[null, null, null].fill('hello', 1) // [null, 'hello', 'hello']\r\n[null, null, null].fill('hello', 1, 2) // [null, 'hello', null]\r\n```\r\n\r\n### find()\r\n以往我们想要判断数组中是否包含某个元素通常是借助`indexOf()`\r\n```js\r\nconst arr = [1, '2', {name: 'hello'}]\r\narr.indexOf(1) !== -1 // true\r\narr.indexOf('2') !== -1 // true\r\narr.indexOf(2) !== -1 // false\r\n```\r\n这种方法有几个缺点:\r\n* 通过严格的===来比较\r\n* 需要通过判断是否等于-1来得出我们要的布尔值结果\r\n* 不能实现自定义的匹配条件\r\n\r\nES5中新增的`some()`解决了上述问题\r\nPS: 当我们不需要自定义匹配条件，想利用全等来比较时  \r\n可以采用ES7新增的更便捷的方法`Array.prototype.includes()`\r\n```js\r\nconst arr = [1, '2', {name: 'hello'}]\r\narr.some(v => v == 2) // true\r\narr.some(v => v.name === 'hello') // true\r\n\r\narr.includes(1) // true\r\n```\r\n大部分情况下这种方法都没有问题，但当我们想要直接获得正确匹配到的值  \r\n这时候就可以借助ES6的`find()`\r\n```js\r\nconst arr = [1, '2', {name: 'hello'}]\r\narr.find(v => v == 2) // '2'\r\narr.find(v => v,name === 'hello') // {name: 'hello'}\r\narr.find(v => v === 666) // undefined\r\n```\r\n\r\n### findIndex()\r\n总结一下上述数组的查找方法，可以发现，当我们只想确定是否存在特定值时可以采用`some()`  \r\n当我们想拿到符合比较条件的值时可以采用`find()`  \r\n如果我们想要拿到符合比较条件值的下标时就需要用到ES6的`findIndex()`\r\n```js\r\nconst arr = [1, '2', {name: 'hello'}]\r\narr.findIndex(v => v == 2) // 1\r\narr.findIndex(v => v,name === 'hello') // 2\r\narr.findIndex(v => v === 666) // -1\r\n```\r\n不难发现该方法和`indexOf()`的差别仅在于可以自定义匹配条件\r\n\r\n### entries() values() keys()\r\n类似`Map` `Set`等ES6新增的Collections，Array也提供了一系列的借助Iterator的迭代方法\r\n```js\r\nconst arr = [1, 2, 3]\r\n[...arr.values()] // [1, 2, 3]\r\n[...arr.entries()] // [[0, 1], [1, 2], [2, 3]]\r\n[...arr.keys()] // [0, 1, 2]\r\n```\r\n"},"./src/blogs/BinaryTreeTraversal.md":function(r,n){r.exports="# 二叉树的遍历\r\n所谓树的遍历即是按特定的顺序访问树中所有的节点  \r\n以下面这颗二叉树为例，我们来研究一下最常见的三种二叉树遍历方式  \r\n\r\n           1\r\n         /   \\\r\n        3     2\r\n       / \\     \\  \r\n      5   7     9 \r\n\r\n\r\n## 前序遍历 NLR\r\n根->左子树->右子树  \r\n访问节点值的操作在继续遍历左子树和右子树之前进行，所以叫前序  \r\n上例中的二叉树前序遍历结果 `135729`\r\n\r\n## 中序遍历 LNR\r\n左子树->根->右子树  \r\n访问节点值的操作在遍历左子树之后遍历右子树之前进行，所以叫中序  \r\n上例中的二叉树中序遍历结果 `537129`\r\n\r\n## 后续遍历 LRN\r\n左子树->右子树->根  \r\n访问节点值的操作在遍历左子树和右子树之后进行，所以叫后序  \r\n上例中的二叉树后序遍历结果 `573921`\r\n\r\n## 代码实现\r\n```js\r\nfunction traverse(node) {\r\n\tconsole.log(node.value) // 前序\r\n\t\r\n\tif (node.left) {\r\n\t\ttraverse(node.left)\r\n\t}\r\n\t\r\n\tconsole.log(node.value) // 中序\r\n\t\r\n\tif (node.right) {\r\n\t\ttraverse(node.right)\r\n\t}\r\n\t\r\n\tconsole.log(node.value) // 后序\r\n}\r\n```\r\n\r\n## 总结\r\n其实类似上述的遍历方式应该一共有6种，包括NLR/NRL/LNR/RNL/LRN/RLN  \r\n但由于其中存在俩俩对称  \r\n所以通常只说先遍历左子树的前/中/后序遍历(NLR/LNR/LRN)这三种遍历方式  \r\n从代码实现中不难看出，对于这三种方式我们对树节点的递归过程是一致的  \r\n区别仅在于我们在递归中何时去访问具体的节点值  \r\n所以这三种遍历方式中的前/中/后其实指的正是我们是在遍历之前、之中还是之后去访问具体的节点值\r\n"},"./src/blogs/Collections.md":function(r,n){r.exports="# New Collections In ES6\r\n\r\n## Map\r\n以往当我们需要一种键/值对形式的数据结构时通常使用的是原生的Object\r\n```js\r\nconst o = {}\r\no[1] = 1\r\no['a'] = 'a'\r\nconsole.log(o) // { 1: 1, a: 'a'}\r\no['1'] = 2\r\nconsole.log(o) // {1: 2, a: 'a'}\r\n\r\nconst map = {}\r\nconst x = { a: 1 }\r\nconst y = { b: 2 }\r\nmap[x] = 1\r\nmap[y] = 2\r\n// 因为x.toString() === '[object Object]'\r\nconsole.log(map) // {[object Object]: 2}\r\n```\r\n可以看到这种方法有一个缺陷，由于Object的Key只能是字符串  \r\n这样生成的Map同样只能以字符串作为键  \r\nES6提供了对Map的原生支持，它可以将任何数据类型作为Key\r\n```js\r\nconst map = new Map()\r\nconst x = { a: 1 }\r\n// 支持链式调用\r\nmap.set(x, 1).set(2, 2).set('2', 2)\r\n\t.set(Symbol.for('sym'), 'symbol').set(true, true)\r\n\r\nmap.get(x) // 1\r\nmap.get(2) // 2\r\nmap.get('2') // 2\r\nmap.get(Symbol.for('sym')) // 'symbol'\r\nmap.get(true) // true\r\n\r\nmap.size // 5\r\n\r\nmap.delete(true)\r\nmap.delete(x)\r\nmap.delete('2')\r\n\r\nmap.size // 2\r\n\r\nmap.has(2) // true\r\nmap.has(Symbol.for('sym')) // true\r\n\r\n[...map.keys()] // [2, Symbol(sym)]\r\n[...map.values()] // [2, \"symbol\"]\r\n[...map.entries()] // [[2, 2], [Symbol(sym), \"symbol\"]]\r\n\r\nmap.clear()\r\nmap.size // 0\r\n```\r\nMap的实例是Iterable的，并且其默认的Iterator与`map.entries()`一致  \r\n所以以下方法都可以用于拷贝产生一个新的Map\r\n```js\r\nconst map = new Map()\r\nconst copy2 = new Map(map.entries())\r\nconst copy1 = new Map(map) // 推荐 更简洁\r\n```\r\n\r\n## WeakMap\r\nWeakMap的大部分行为与Map一致，主要区别在于WeakMap对内存分配机制的特殊处理  \r\nWeakMap的Key只能是Object，并且当作为Key的Object被GC回收后  \r\n其存储在WeakMap中的Entry也会随之被销毁  \r\nWeakMap相较Map而言只提供了`set()` `get()` `delete()` `has()` 四个有限的API  \r\n尤其适用于需要把不受我们控制的对象(例如DOM对象)作为Key值的情况\r\n\r\n## Set\r\nES6新增的Set用于存储一系列不重复的值  \r\n其判断是否重复的规则除了Set会认为+0等与-0外都与`Object.is()`相同\r\n```js\r\nconst set = new Set()\r\nconst x = { a: 1 }\r\nconst y = { b: 2 }\r\n// 支持链式调用\r\nset.add(x).add(y).add(x)\r\n\r\nset.size // 2\r\n\r\nset.delete(y)\r\nset.size // 1\r\n\r\nset.has(x) // true\r\nset.clear()\r\nset.size // 0\r\n\r\nset.add(1).add('1').add(2);\r\n[...set.keys()] // [1, \"1\", 2]\r\n[...set.values()] // [1, \"1\", 2]\r\n[...set.entries()] // [[1, 1], [\"1\", \"1\"], [2, 2]]\r\n```\r\n与Map不同的是Set实例的默认Iterator与`values()`相同  \r\n可以利用Set来进行数组去重\r\n```js\r\nconst arr = [1, 1, 2, 3, 3, 4, '4']\r\nconst unique = [...new Set(arr)]\r\nconsole.log(unique) // [1, 2, 3, 4, \"4\"]\r\n```\r\n\r\n## WeakSet\r\n同WeakMap类似，WeakSet中存储的值只能是Object\r\n并且当Object被GC后WeakSet也会自动将其从集合中删除\r\n"},"./src/blogs/CookieAndWebStorage.md":function(r,n){r.exports="# Cookies 和 WebStorage\r\n\r\n## 为什么需要客户端存储\r\n* 记录用户登录状态，当用户下次访问时不必重新登录\r\n* 存储一些用户对应用的自定义偏好设置，例如主题色、表格每页默认显示条数等\r\n* 一些广告商需要通过客户端端存储的一些用户行为数据来做一些更个性化的推荐\r\n\r\n恰当的利用客户端存储可以很好的优化用户体验\r\n\r\n## Cookies\r\n\r\n### Cookies 是什么\r\nCookies 其实就是网站存储在客户端的一些数据  \r\n这些数据会自动的被加到网站发起的每个 HTTP 请求的 Request Header 中  \r\n通常情况下服务端和客户端都可以对 Cookies 进行 CRUD 操作  \r\n[点这里查看 Cookies 协议](https://tools.ietf.org/html/rfc6265#section-5.2.1)\r\n\r\n### 如何在前端新增 Cookie\r\n```js\r\n// 最简单的设置方式 属性全部采用默认值\r\ndocument.cookie = 'name=value'\r\n// 自定义 Cookie 属性\r\ndocument.cookie = 'test=111; max-age=3600; domain=xx.com; path=/;'\r\n```\r\n注意一次只能同时新增一个 Cookie\r\n\r\n### 如何在前端修改或删除 Cookie\r\n```js\r\n// 修改 test 为 222\r\ndocument.cookie = 'test=222; max-age=7200; domain=xx.com; path=/'\r\n// 删除 test\r\ndocument.cookie = 'test=; max-age=0; domain=xx.com; path=/'\r\n```\r\n这里要注意的是要确保 `domain` 以及 `path` 与待修改 Cookie 设置的一致  \r\n因为 Cookie 其实是在同一个域名和路径下唯一  \r\n例如我们访问 `www.a.com/test/xx.html`  \r\n可以同时存在 `test=1; domain=a.com; path=/test` 以及 `test=1; domain=a.com; path=/`  \r\n这俩个 name 相同但是 path 不同的同名 Cookie  \r\n所以只有 `name` `domain` `path` 这三个值都相同时才能确定一个 Cookie\r\n\r\n### 如何读取 Cookie\r\n通过 `document.cookie` 获取到的是所有数据  \r\n类似 `name1=value1; name2=value2` 的字符串  \r\n要拿来使用的话还需通过一系列字符串操作将需要的值取出\r\n\r\n### 如何判断 Cookie 是否启用\r\n由于 Cookie 涉及到用户的隐私，用户可以手动禁止浏览器使用 Cookie  \r\n绝大多数浏览器都可以通过以下代码来判断用户是否禁用 Cookie  \r\n```js\r\nnavigator.cookieEnabled\r\n```\r\nPs: 经本人测试 禁用 Cookie 后 Github 淘宝 等都无法正常访问  \r\n感觉现在大多数用户都不会去禁用 Cookie，不然会有一堆网站访问不了\r\n\r\n### 关于 Cookie 的属性\r\n* domain  \r\n指定 Cookie 存储在哪个域名下 默认为当前服务器的域名  \r\n当然也遵循同源策略 例如在 `www.son.a.com` 页面下    \r\n我们可以设置 Cookie 的 domain 为 `a.com`  \r\n这样在 `www.another.a.com` 页面也可以获取到该 Cookie  \r\n但是不能在该页面试图去操作 domain 为 `b.com` 的 Cookie\r\n* path  \r\n指定 Cookie 存储在哪个路径下 默认为当前 URI 中的路径  \r\n例如在 `www.a.com/page/one.html` 我们按默认属性设置了一个Cookie  \r\n那么在 `www.a.com/page/two.html` `www.a.com/page/son/three.html`  \r\n这些页面下都可以获取这个 Cookie  \r\n但是在 `www.a.com/another/four.html` 页面上便无法得到这个 Cookie  \r\n可以将 path 设为 `/` 使得访问当前域名下所有路径的网页都能拿到设置的 Cookie\r\n* max-age 最大存储时间 以秒为单位 默认当浏览器 Session 结束时清除\r\n* expires 存储失效的 GMT 时间 默认当浏览器 Session 结束时清除\r\n* secure 包含该属性的 Cookie 只能通过 HTTPS 传输\r\n* httponly  \r\n只能在服务端进行设置  \r\n包含该属性的 Cookie 只会在 Request Headers 中出现  \r\n前端无法通过 `document.cookie` 查看修改\r\n\r\n### 关于 Cookie 中的保留字符\r\n由于 `;` `,` `空格` 在 Cookie 中有特殊含义  \r\n所以当存储的数据中包含这些特殊字符时  \r\n需要在存储前通过 `encodeURIComponent` 进行编码  \r\n读取前通过 `decodeURIComponent` 进行解码\r\n\r\n### Cookie 的优缺点\r\n优点：\r\n* 适合用于存放需要每个请求都必须携带的数据\r\n* 服务端也可以直接操作 Cookie\r\n* 可以通过 domain 以及 path 控制数据存储的范围\r\n\r\n缺点：\r\n* 容量有限，规范只要求每个域名下最低提供 4kb 的存储空间\r\n* 每次请求都会携带，如果存放了大量不必要的数据很显然会影响页面性能\r\n* 不安全，永远不要在 Cookie 中存放用户的敏感数据\r\n* 前端 API 不友好，CRUD 都是通过 `document.cookie` 进行，没有提供相关操作的方法\r\n\r\n# WebStorage\r\n\r\n## WebStorage 是什么\r\nWebStorage 是 HTML5 新增的客户端存储机制  \r\n分为 `LocalStorage` 以及 `SessionStorage`  \r\nIE8+ 以及各现代浏览器对其都有良好的支持  \r\n[点这里查看 WebStorage 规范](https://html.spec.whatwg.org/multipage/webstorage.html#storage)\r\n\r\n## LocalStorage\r\n永久存储（除非浏览器缓存被清除）在当前域下，遵循同源策略  \r\n如果在一个浏览器打开多个窗口访问同一域名的网站  \r\n那么这多个窗口中的 LocalStorage 是共享的\r\n\r\n## SessionStorage\r\n存储周期为当前 Session ，同样遵循同源策略  \r\n要注意这里的 Session 和 Cookie 的默认存储 Session 不同  \r\nSessionStorage 针对的是浏览器的每个窗口，而不是整个浏览器的进程  \r\n正因如此，与 LocalStorage 不同的是，多个窗口下的同域名网站，其 SessionStorage 也是分开存储的  \r\nPs：要注意的是如果在一个窗口内访问的网站通过 `<iframe>` 内嵌了俩个同域名网站  \r\n那么这俩个 `<iframe>` 内嵌站点的 SessionStorage 是共享的\r\n\r\n## API\r\n```\r\n// sessionStorage 与 localStorage 一致\r\nlocalStorage.a = 'test1' // 新增或修改\r\nlocalStorage.a // 读取\r\nlocalStorage['a'] // 读取\r\n\r\nlocalStorage.setItem(a, 'test3') // 新增\r\nlocalStorage.getItem(a) // 读取\r\nlocalStorage.removeItem(a) // 删除\r\nlocalStorage.clear() // 清空所有\r\nlocalStorage.key(index) // 获取指定 index 存储键值对的 key\r\nlocalStorage.length // 总共存储的键值对数量\r\n```\r\n可以看到通过类似操作普通对象一样来操作 WebStorage  \r\n通常来说这种方式更为简洁  \r\n但是也有类似 `clear()` `removeItem()` 等操作只能通过 API 进行\r\n\r\n## Storage Event\r\nWebStorage 还提供了事件机制，用于监听存储发生的变化  \r\n当打开俩个窗口访问同域网站，如果在其中一个窗口中修改了存储数据  \r\n在另一个窗口中可以通过如下代码监听到存储改变的事件  \r\n```js\r\n// 会被 setItem() removeItem() clear() 触发\r\nwindow.addEventListener('storage', e => {\r\n\t/**\r\n\t\te: {\r\n\t\t\tkey, // 发生改变的 key\r\n\t\t\tnewValue, // 旧值\r\n\t\t\toldValue, // 新值\r\n\t\t\turl, // 触发变化的文档 URL\r\n\t\t\t...\r\n\t\t}\r\n\t*/\r\n\t// 当事件是由 clear() 触发时 key/newVlue/oldValue 都为 null\r\n})\r\n```\r\n要注意的是这个事件只有在本地存储真的发生变化时才会触发  \r\n也就是说假设已经通过 `localStorage.a = 'test'` 设置了本地存储中 `a` 的值为 `test`  \r\n那么再次执行 `localStorage.a = 'test'` 并不会触发事件  \r\n并且通过 `localStorage.removeItem('notExist')` 试图移除一个不存在的属性时也不会触发事件  \r\nPs:（由于 SessionStorage 是基于浏览器窗口存储，所以只有当使用 `<iframe>` 处理内嵌页面时才可能会触发事件）  \r\n这个机制可以用于实现应用的广播功能，当用户在一个窗口的页面进行操作时同步对另一个窗口的页面做出修改  \r\n例如用户在一个窗口中修改了应用的主题色，我们通过 `localStorage.color = 'red'` 来保存这一改变  \r\n另一个窗口通过监听到 `localStorage` 的变化同步的将应用的主题色也修改为 `red`\r\n\r\n\r\n## WebStorage 的优势\r\n* 每个域下允许存储超过 5MB 的数据（各个浏览器有所不同）\r\n* 更友好的 API\r\n\r\n\r\n## 其它注意事项\r\n* 不管是 Cookies 还是 WebStorage 都是与浏览器相关的  \r\n也就意味着在 Chrome 浏览器中存储的数据，当用户切换为 FireFox 浏览时就无法获取  \r\n当然这应该是小概率事件，毕竟大多数人习惯于使用同一种浏览器\r\n* 当浏览器设置 Cookie 失败时并不会报错，这个过程是静默的  \r\n例如当你试图跨域的去设置 Cookie 时只会发现不生效，但不会在控制台中看到相应错误信息\r\n* 虽然 WebStorage 的规范希望能支持对类似数组对象等结构化数据进行存储  \r\n但目前为止大多数浏览器仅支持字符串作为 Value  \r\n传入非字符串的值会被强制转化为字符串  \r\n例如试图通过 `localStorage.o = {a: 1}` 存储一个对象  \r\n会发现实际存储的是 `o: \"[object Object]\"`\r\n\r\n"},"./src/blogs/CrossOrigin.md":function(r,n){r.exports="# 关于跨域\r\n\r\n## 什么叫跨域?\r\n提到跨域首要要说的就是浏览器的同源策略（Same origin policy  \r\n在浏览器中无法通过脚本程序获取不同域下的 Cookie/LocalStorage/IndexDB  \r\n无法操纵或读取不同域页面下的 DOM（例如无法获取通过 iframe 内嵌页面的 DOM  \r\n无法向不同域的服务器发起 AJAX 请求  \r\n所谓的同域指的是域名/协议/端口号完全一致  \r\n就算父域名相同子域名不同也算跨域  \r\n例如从 a.xx.com 向 b.xx.com 发起请求也算跨域请求  \r\n当我们通利用 XHR 像不同域的地址发起请求时就会碰到跨域问题  \r\n这时候如果接收请求的服务器未经过特殊设置，通常我们会在控制台中看到如下报错  \r\n```\r\nXMLHttpRequest cannot load xxx.\r\nNo 'Access-Control-Allow-Origin' header is present on the requested resource.\r\nOrigin 'xxx' is therefore not allowed access.\r\n```\r\n\r\n## 为什么浏览器会限制跨域请求?\r\n浏览器对跨域请求进行设置主要是出于安全方面的考虑  \r\n可以假想一下没有同源策略会引发什么样的问题  \r\n假设我们正在访问一个正常网站 a.com 同时打开了另一个恶意站点 b.com  \r\n如果没有同源限制，那么 b.com 页面上执行的恶意脚本文件即可获得我们所有的 Cookie/LocalStorage 中存放的数据  \r\n通常我们会把登录相关的信息放在其中，还有可能存放一些用户的隐私数据  \r\n这时 b.com 通过得到的登录相关信息又可以伪装成已登录的正常用户  \r\n通过向 a.com 发起请求并携带上这些登录信息，攻击者甚至可以窃取更多存在服务器端的关键数据  \r\n而 a.com 会认为这些请求是一个普通的已登录用户发出的  \r\n更危险的是由于一切操作都由脚本执行，普通用户根本感知不到这个过程\r\n\r\n## 怎样才能发起一个正确的跨域请求?\r\n在大多数情况下我们的前端工程不会和后端工程部署在同一域名下  \r\n这个时候我们需要采取一些特殊的方法来绕过浏览器对跨域的限制  \r\n\r\n### JSONP（JSON with Padding）\r\n由于页面中静态资源的加载并不会受到同源策略的限制  \r\nJSONP 正是利用 `<script>` 想页面中注入代码来实现跨域请求  \r\n假设我们需要向 `a.com/api` 发起跨域请求  \r\n客户端通过动态创建一个 `<script>` 标签并插入页面\r\n```html\r\n<script src=\"a.com/api?jsonp=cb\"><\/script>\r\n```\r\n这样一个标签，浏览器就可以向该 URL 发起请求  \r\n需要注意的是正是因为 JSONP 是通过这种方式向服务端请求的  \r\n所以 JSONP 只能发起 GET 请求  \r\n并且请求返回的类型（Content-Type）应该为 `text/javascript`  \r\n请求中的参数 `?jsonp=cb` 是为了告诉服务端前端时使用哪个回调函数来处理请求返回的数据  \r\n服务端需要将数据嵌套进这个函数中再返回  \r\n例如返回的真实数据为 `{ a: 1 }`  \r\n那么服务端在请求中需要返回的 Javascript 代码片段应该为 `cb({ a: 1 })`  \r\n正因如此 JSONP 的命名是 JSON with Padding 因为需要服务端进行字符串 Padding 操作  \r\n并且返回的数据恰好就是 JSON 格式，不需要经过 `JSON.parse()`  \r\n这样当客户端收到这个代码片段并去执行时，我们便可以在定义好的 `cb()` 函数中接受到数据  \r\n类似 Jquery 等库提供的 JSONP 功能其实就是对上述过程的一种封装\r\n\r\n### CORS (Cross-Origin Resource Sharing)\r\nW3C 在 2014 年正式推出了 CORS 协议来更好的解决跨域问题  \r\nCORS 把请求分为简单请求和复杂请求  \r\n复杂请求在发送正式请求之前会先发一个被称作 Preflight 的预校验 `OPTIONS` 请求  \r\n只有当一个请求是\r\n* GET\r\n* HEAD\r\n* POST\r\n\r\n以上三种请求之一并且请求头只包含\r\n* Accept\r\n* Accept-Language\r\n* Content-Type (Ps: 且值只能为 application/x-www-form-urlencoded 或 multipart/form-data 或 text/plain)\r\n* Content-Language\r\n\r\n如上几种时才会被认为是简单请求  \r\n对于前端来说需要做的支持操作仅仅在于当需要 CORS 请求支持携带 Cookie 等认证信息时  \r\n因为 CORS 请求默认不会携带这些信息  \r\n将 `xhr` 的 `withCredentials` 设为 `true`  \r\n```js\r\nconst xhr = new XMLHttpRequest()\r\nxhr.withCredentials = true\r\n```\r\n以我目前的项目经历来看，碰到的跨域问题都是后台配置有误，前端在这方面能做的有限  \r\n下面介绍一下 CORS 用于验证跨域请求的一些相关 `HTTP Headers`  \r\n请求头：\r\n* Origin （请求来源域名也就是发起请求页面的域名）\r\n* Access-Control-Request-Method （在预校验请求时预校验的 OPTIONS 请求中携带 告知服务端真实请求的类型）\r\n* Access-Control-Request-Headers （同上 在预校验请求中携带 告知服务端真实请求会携带的自定义请求头）\r\n\r\n响应头：\r\n* Access-Control-Allow-Origin （必备 当前接口允许的请求来源域名 当设为 * 时 请求不能携带 Cookie 等鉴权信息）\r\n* Access-Control-Allow-Headers （预校验请求返回 告知浏览器所有允许携带的自定义请求头）\r\n* Access-Control-Allow-Methods （预校验请求返回 告知浏览器所有服务端支持的请求类型）\r\n* Access-Control-Allow-Crendentials （可选 当需要传递 Cookie 时设为 true）\r\n* Access-Control-Max-Age (预校验请求返回  告知浏览器在一段时间内缓存 不必再次发起预校验请求)\r\n* Access-Control-Expose-Headers （前端能通过 `xhr.getResponseHeader()` 获取到哪些请求头的具体指）\r\n"},"./src/blogs/Generator.md":function(r,n){r.exports="# Generator in ES6\r\n## 序\r\nGenerator不同于一般的函数，它可以在执行过程中被暂停然后在稍后的任意时刻恢复执行，并且在过程中可以与外界双向传递数据\r\n\r\n## 如何写一个最简单的Generator\r\n```js\r\nfunction *foo() {\r\n\treturn 'hello'\r\n}\r\n\r\nconst it = foo()\r\nit.next() // { value: 'hello', done: true}\r\n```\r\n与普通函数的不同的是调用一个Generator并不会立即执行函数体，而是返回一个Iterator来控制这个Generator的执行\r\n\r\n## 如何写一个有意义的Generator\r\n上例中的Generator并没有特殊的意义，因为它中间并没有暂停的步骤，若想让一个Generator可以中断需要使用ES6新引入的关键字`yield`\r\n```js\r\nfunction *foo() {\r\n\tconst a = yield 'hello'\r\n\tconsole.log(a)\r\n\t\r\n\tconst b = yield 'world'\r\n\tconsole.log(b)\r\n\t\r\n\treturn 'finish'\r\n}\r\n```\r\n下面来依次执行上述Generator，看看每一步的结果\r\n```js\r\nconst it = foo() // 获得Iterator\r\nit.next('step 1')\r\n// {value: \"hello\", done: false}\r\n```\r\n初次执行，代码会停在`const a = yield 'hello'`处，hello作为返回值被抛到函数外\r\n\r\n需要注意的是这里通过`next()`传入的值不会被函数接受，因为**yield**将自身替换为外部传入值的时机是在代码恢复执行时\r\n```js\r\nit.next('step 2')\r\n// 'step 2'\r\n// {value: \"world\", done: false}\r\n```\r\n第二次执行，代码会停在`const b = yield 'world'`处，我们在`next()`中传入的`'step2'`被赋值给变量`a`\r\n\r\n可以看做`yield 'hello'`被替换成了`'step2'`，world作为返回值被抛出\r\n```js\r\nit.next('step 3')\r\n// 'step 3'\r\n// {value: \"finish\", done: true}\r\n```\r\n最后一次执行，`'step3'`被赋值给变量`b`，Generator执行完毕，finish作为返回值被抛出\r\n\r\n## `yield *`\r\n**yield delegation**可以把当前Generator的控制委派给另一个Iterator  \r\n```js\r\nfunction *foo() {\r\n\tyield *[1, 2, 3]\r\n}\r\nfor (v of foo()) {\r\n\tconsole.log(v) // 1 2 3\r\n}\r\n```\r\n"},"./src/blogs/GulpPlugin.md":function(r,n){r.exports='# 如何编写一个自己的GulpPlugin\r\n\r\n```\r\nconst through = require("through-gulp"),\r\n\tfs = require("fs")\r\n\r\nfunction myPlugin() {\r\n\treturn through(function(file, encoding, callback) {\r\n\t\tlet result, origin\r\n\t\t\r\n\t\t// 传入的文件为空\r\n\t\tif (file.isNull()) {\r\n\t\t\tthrow "Please Check Files!"\r\n\t\t}\r\n\r\n\t\t// buffer对象可以直接操作\r\n\t\tif (file.isBuffer()) {\r\n\t\t\t//拿到单个文件buffer             \r\n\t\t\tfile.contents = new Buffer(file.contents.toString("utf-8"),"utf-8")\r\n\t\t}\r\n\t\t \r\n\t\t// stream流是不能操作的,可以通过fs.readFileSync\r\n\t\tif (file.isStream()) {\r\n\t\t\t// 同步读取\r\n\t\t\tfile.contents = new Buffer(s.readFileSync(file.path).toString("utf-8"),"utf-8")\r\n\t\t}\r\n\r\n\t\torigin = file.contents.toString("utf-8") // 转化为字符串\r\n\t\tresult = doYourPluginWork(origin) // 处理源文件 实现插件的逻辑\r\n\t\tfile.contents = new Buffer(result) // 将源文件的内容替换为插件处理完之后的内容\r\n\r\n\t\tthis.push(file)\r\n\t\tcallback() // 声明文件已处理完毕\r\n\t}, function(callback) {\r\n\t\tcallback() // 声明文件已处理完毕\r\n\t})\r\n}\r\n\r\nmodule.exports = myPlugin\r\n```\r\n'},"./src/blogs/Iterator.md":function(r,n){r.exports="# Iterator in ES6\r\n## Iterator 与 Iterable\r\nIterator可以看做一个拥有特定格式的对象，可供ES6提供的遍历->`for of`和解构->`...`等操作消费，并按顺序依次产出结果，样例如下\r\n```js\r\n// 除了以下俩个值外也可以额外返回更多的自定义属性\r\nconst IteratorResult = {\r\n\tvalue: ..., // 每次迭代产出的真实值\r\n\tdone: ..., // true|false true代表迭代结束 与true相对应的value一般建议为undefined\r\n}\r\n\r\nconst Iterator = {\r\n\t// 必须 用于返回每次迭代的结果集\r\n\tnext() { return IteratorResult},\r\n\t// 可选 提前结束迭代时做相应的资源清理操作并返回最后的结果集\r\n\treturn() {},\r\n\t// 可选 抛出异常信息并返回最后的结果集\r\n\tthrow() {}\r\n}\r\n```\r\n而Iterable则是指一个对象实现了Iterable接口(简单来说就是对象上有一个key为Symbol.iterator的方法并且这个方法会生成一个Iterator)\r\n```js\r\nconst Iterable = {\r\n\t[Symbol.iterator]() {return Iterator}\r\n}\r\n```\r\n\r\n## 如何构造一个简单的Iterable对象\r\n```js\r\nlet rand = Math.random()\r\n// 会随机产生一串数字的Iterable对象\r\nconst iterable = {\r\n\t// 必备!!! 这样才能使该对象变为Iterable\r\n\t[Symbol.iterator]() {return this},\r\n\t// 依次去获取数据\r\n\tnext() {\r\n\t\tif (rand > 0.5) {\r\n\t\t\trand = Math.random()\r\n\t\t\treturn {\r\n\t\t\t\tvalue: rand,\r\n\t\t\t\tdone: false\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\tdone: true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n// 该对象可以用for of遍历\r\nfor (let value of iterable) {\r\n\tconsole.log(value)\r\n}\r\n```\r\n\r\n## 如何构造一个完整的Iterable对象\r\n```js\r\n// 该对象可以步进的产生对数据的每一步累加结果\r\nconst stepAccumulator = {\r\n\t[Symbol.iterator]() {\r\n\t\tlet sum = 0\r\n\t\tlet index = 0\r\n\t\tconst data = this.data.slice()\r\n\t\tlet done = false\r\n\t\treturn {\r\n\t\t\t// 使迭代器(Iterator)本身可迭代(Iterable)\r\n\t\t\t[Symbol.iterator]() { return this },\r\n\t\t\tnext() {\r\n\t\t\t\tconst value = sum += data[index]\r\n\t\t\t\tindex++\r\n\t\t\t\tif (index <= data.length && !done) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tvalue,\r\n\t\t\t\t\t\tdone: false\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdone: true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\treturn(v) {\r\n\t\t\t\tconsole.log('abandoned')\r\n\t\t\t\tdone = true\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: v,\r\n\t\t\t\t\tdone: true\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tthrow(e) {\r\n\t\t\t\tconsole.log('error')\r\n\t\t\t\tdone = true\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: e,\r\n\t\t\t\t\tdone: true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tdata: []\r\n}\r\n// 设置数据\r\nstepAccumulator.data = [1, 2, 3]\r\nconsole.log(...stepAccumulator) // 1 3 6\r\n\r\n// 1 3 'abandoned'\r\nfor (let v of stepAccumulator) {\r\n\tconsole.log(v)\r\n\tif (v > 1) break\r\n}\r\n\r\nconst it = stepAccumulator[Symbol.iterator]()\r\nit.next() // { value:1, done: false }\r\nit.throw('!!!') // 'error' { vallue:'!!!', done: true }\r\nit.next() // { done: true }\r\n```\r\n* `return()`和`throw()`都可以通过**Iterator**调用，并且通常来说在调用过后便不应该能通过该迭代器获取到更多的值\r\n* 一般来说**Iterable**对象可以同时生成多个**Iterator**，且相互间的迭代不会互相影响，当然你也可以把迭代器设为单例\r\n* 任何一种取消或者提前终止迭代的行为都会使得**Iterator**自动调用`return()`来处理相关的清理工作\r\n\r\n## ES6自带的Iterable数据结构\r\n包括`String` `Map` `Set` `Array`等\r\n```js\r\nconst str = 'abc'\r\nconst arr = [1, 2, 3]\r\nconst map = new Map()\r\nmap.set('a', 1)\r\nmap.set('b', 2)\r\nfor (let v of str) {\r\n\tconsole.log(v) // 'a' 'b' 'c'\r\n}\r\nfor (let v of arr) {\r\n\tconsole.log(v) // 1 2 3\r\n}\r\nfor (let v of map) {\r\n\tconsole.log(v) // ['a', 1] ['b', 2]\r\n}\r\n```\r\n"},"./src/blogs/Npm.md":function(r,n){r.exports="# NPM 相关问题记录\r\n\r\n## 初始化发布公共包到 npm 库的步骤\r\n* 有一个包含 `package.json` 的文件夹\r\n* 在命令行中使用 `npm login` 登录已有的 npm 账户\r\n* 确保 `package.json` 中 author 与已登录的账户名称一致\r\n* 初始化发布必须在 `npm publish` 后加上 `--access public`\r\n"},"./src/blogs/ObjectAPI.md":function(r,n){r.exports="## Object's New API In ES6\r\n\r\n### Object.is()\r\n该方法用于比较俩个值是否相等，基本的比较逻辑与`===`一致但是更加严格\r\n```js\r\nconst x = NaN\r\nconst y = 0\r\nconst z = -0\r\n\r\nx === x // false\r\nObject.is(x, x) // true\r\ny === z // true\r\nObject.is(y, z) // false\r\n```\r\n当不需要考虑这几种特殊情况时，直接用`===`比较更方便\r\n\r\n### Object.getOwnPropertySymbols()\r\nES6新增的`Symbol`可以作为对象上的特殊属性使用  \r\n有时我们可能希望只获得一个对象上的所有`Symbol`属性，排除其他普通属性  \r\n这个时候就可以借助该方法\r\n```js\r\nconst o = {\r\n\tfoo: 'hello',\r\n\t[ Symbol('bar') ]: 'world'\r\n}\r\n\r\nconst symbols = Object.getOwnPropertySymbols(o) // [Symbol(bar)]\r\no[symbols[0]] // 'world'\r\n```\r\n\r\n### Object.setPrototypeOf()\r\n该方法提供了一种更优雅的方式来修改一个对象的原型\r\n```js\r\nconst o1 = {\r\n\tbar: 1\r\n}\r\nconst o2 = {\r\n\tfoo: 2\r\n}\r\n\r\nObject.setPrototypeOf(o1, o2)\r\no1.foo // 2\r\no1.__proto__ === o2 // true\r\n\r\n// 将o1设置为无原型对象 类似 const o = Object.create(null)\r\n// 这种做法通常是为了获得一个纯净的对象来作为Map使用\r\n// 现在ES6新增了原生的Map结构 可以考虑避免使用这种技巧\r\nObject.setPrototypeOf(o1, null)\r\no1.__proto__ // undefined\r\n```\r\n\r\n### Object.assign()\r\n由于React/Vue/Angular等数据驱动的前端框架的流行  \r\n这个方法在平常项目中使用频率很高，用于将一系列对象中的值复制到目标对象中  \r\n并且会对各对象相同key的(enumerable)值按先后顺序进行覆盖\r\n```js\r\nlet o1 = { a: 1 }\r\nlet o2 = { b: 2 }\r\n\r\nObject.assign({}, o1, o2) // { a: 1, b: 2 }\r\n\r\nObject.defineProperty(o2, 'c', {\r\n\tvalue: 3,\r\n\tenumerable: false\r\n})\r\n\r\nObject.defineProperty(o2, 'd', {\r\n\tvalue: 4,\r\n\tenumerable: true\r\n})\r\n\r\n// 可以看到 enumerable为false的属性不会被拷贝\r\nObject.assign({}, o1, o2) // { a: 1, b: 2, d: 4}\r\n\r\no2[Symbol('bar')] = 5\r\n// Symbol属性也会被拷贝\r\nObject.assign({}, o1, o2) // { a: 1, b: 2, d: 4, Symbol(bar): 5}\r\n```\r\n值得注意的是，该方法的拷贝过程是浅拷贝  \r\n类似于对每个属性进行`target = src`的赋值  \r\n所以碰到数组、对象之类的复杂数据结构时要多加小心\r\n"},"./src/blogs/PreventModalScroll.md":function(r,n){r.exports="# 如何阻止模态框(Modal/Popup/Dialog)弹出后body可滚动\r\n\r\n## 序\r\n\r\n当模态框的遮罩层为透明时，鼠标或手指在模态框内容区进行操作  \r\n此时如果被遮罩层挡住的Body内容仍会滚动会造成视觉上的干扰  \r\n为了最佳的用户体验，我们需要想办法禁止这种默认的行为\r\n\r\n## 设置Body的样式`overflow: hidden`\r\n在模态框弹出时通过\r\n```js\r\n// 弹出\r\ndocument.body.style.overflow = 'hidden'\r\n// 关闭\r\ndocument.body.style.overflow = 'initial'\r\n```\r\n修改`<body>`的样式使得滚动条消失，Bootstrap的Modal采取的就是这种方式  \r\n缺点在于滚动条消失会导致页面向右偏移约20px，以填充滚动条消失的空白  \r\n在PC端会有比较明显的感觉，对用户体验还是稍有影响  \r\n另外移动端的大多浏览器对给`<body>`设置`overflow: hidden`并不感冒  \r\n绝大多数情况下这种方式在移动端不起作用(亲测ios chrome下无效)\r\n\r\n## 通过Javascript禁止滚动事件的默认行为\r\n```js\r\nfunction preventScroll(e) {\r\n\te.preventDefault()\r\n}\r\n\r\n// 弹出\r\n// { passive: false }是因为Chrome对相应事件做了优化 如果不设置会导致页面报错\r\n// Unable to preventDefault inside passive event listener due to target being treated as passive. \r\n// See https://www.chromestatus.com/features/5093566007214080\r\ndocument.body.addEventListener('mousewheel', preventScroll, { passive: false })\r\ndocument.body.addEventListener('touchmove', preventScroll, { passive: false })\r\n\r\n// 关闭\r\ndocument.body.removeEventListener('mousewheel', preventScroll)\r\ndocument.body.removeEventListener('touchmove', preventScroll)\r\n```\r\n如果模态框的内容区中没有可滚动的元素，那么这个方案是可行的  \r\n如果有的话会发现内容区中元素的滚动也被一并禁止了\r\n\r\n## 进一步优化方案\r\n由于我们不想禁止掉所有元素的滚动，可以考虑在需要滚动的元素上加一个特定类  \r\n当触发事件的元素是该允许滚动的元素或者其子元素时，不去preventDefault\r\n```js\r\nfunction preventScroll(e) {\r\n\t// 只有容器中类名包含scroll-able的元素以及子元素允许滚动\r\n\tif (!e.path.find(dom => dom.classList && dom.classList.contains('scroll-able'))) {\r\n\t\te.preventDefault()\r\n\t\te.stopPropagation()\r\n\t}\r\n}\r\n```\r\n"},"./src/blogs/Promise.md":function(r,n){r.exports="# Promise In ES6\r\n\r\n## 序\r\n以往我们通常用回调函数来处理异步编程\r\n当嵌套过深时便会使程序的可读性很差（Callback Hell）\r\n```js\r\nfunction foo(cb) {\r\n\tasyncFunc1(() => {\r\n\t\tcb()\r\n\t\tasyncFunc2(() => {\r\n\t\t\tcb()\r\n\t\t\tasyncFun3(() => {\r\n\t\t\t\tcb()\r\n\t\t\t})\r\n\t\t})\r\n\t})\r\n}\r\n```\r\nES6新增的Promise提供了一种更优雅的方式来处理异步编程\r\n\r\n## 如何构造一个基础的Promise\r\n```js\r\nconst p = new Promise((resolve, reject) => {\r\n\tconst rand = Math.random()\r\n\tsetTimeout(() => {\r\n\t\tif (rand > 0.5) {\r\n\t\t\tresolve('finish')\r\n\t\t} else {\r\n\t\t\treject('err')\r\n\t\t}\r\n\t}, 3000)\r\n})\r\n\r\n// 在3秒后输出'finish' or 'err'\r\np.then(res => console.log(res))\r\n.catch(err => console.log(err))\r\n\r\n// 同上\r\np.then(res => console.log(res), err => console.log(err))\r\n```\r\n一个Promise最终只会有俩个状态**fulfilled**或者**rejected**  \r\n前者可以在`then()`的第一个参数中获得处理完成的结果  \r\n后者可以在`then()`的第二个参数或者`catch()`中获得处理失败的原因  \r\n每一个Promise只会被resolve(fulfill 或者 reject)一次  \r\n并且一旦一个Promise执行完毕，它就成为了一个不可变的值  \r\n\r\n## Promise是如何避免Callback Hell的\r\n```js\r\nfunction asyncFunc1() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('1 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nfunction asyncFunc2() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('2 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nfunction asyncFunc3() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('3 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nasyncFunc1().then(res => {\r\n\tconsole.log(res)\r\n\treturn asyncFunc2()\r\n}).then(res => {\r\n\tconsole.log(res)\r\n\treturn asyncFunc3()\r\n}).then(res => {\r\n\tconsole.log(res)\r\n})\r\n// 3s后 \"1 done\"\r\n// 再3s后 \"2 done\"\r\n// 再3s后 \"3 done\"\r\n```\r\n通过上例可以看出，正确的使用Promise可以使得我们程序中的异步流程更为清晰  \r\n可以说完美的避开了Callback Hell\r\n\r\n## Promise API\r\n\r\n### Promise.resolve() 和 Promise.reject()\r\n```js\r\nconst p1 = Promise.resolve(1)\r\nconst p2 = new Promise(resolve => resolve(1))\r\n\r\nconst p3 = Promise.reject(1)\r\nconst p4 = new Promise((resolve, reject) => reject(1))\r\n```\r\n可以通过`Promise.resolve()`将thenable对象转为真正的Promise对象  \r\n如果你以前用了类似Promise语法的异步处理库  \r\n现在想将其行为转成和Promise一致时可能会用到\r\n\r\n### Promise.all([...])\r\n该方法的入参是一个包含多个Promise对象的数组  \r\n它会等到其中所有的Promise处理完成(fulfilled)后将结果集返回  \r\n或者其中任意一个Promise处理失败(rejected)后将错误抛出\r\n```js\r\nconst p1 = 1\r\nconst p2 = Promise.resolve(2)\r\nconst p3 = new Promise((resolve, reject) => {\r\n\tsetTimeout(() => {\r\n\t\tresolve(3)\r\n\t}, 3000)\r\n})\r\n\r\n// 3s后输出 [1, 2, 3]\r\nPromise.all([p1, p2, p3]).then(res => console.log(res))\r\n\r\nconst e1 = new Promise((resolve, reject) => {\r\n\tsetTimeout(() => {\r\n\t\treject('err')\r\n\t}, 1000)\r\n})\r\n\r\n// 1s后输出 \"err\"\r\nPromise.all([p1, p2, p3, e1])\r\n.then(res => console.log(res))\r\n.catch(err => console.log(err))\r\n```\r\n\r\n### Promise.race([...])\r\n与`Promise.all()`不同，该方法只会取入参中所有Promise中最快返回的结果  \r\n不管是接受(resolve)或是拒绝(reject)  \r\n其余Promise的处理结果都会被忽略\r\n```js\r\nconst p1 = new Promise((resolve, reject) => {\r\n\tsetTimeout(() => {\r\n\t\tresolve(1)\r\n\t}, 1000)\r\n})\r\nconst p2 = new Promise((resolve, reject) => {\r\n\tsetTimeout(() => {\r\n\t\tresolve(2)\r\n\t}, 2000)\r\n})\r\n// 1s后输出 1\r\n// 无论执行多少遍都是该结果 永远不会输出2\r\nPromise.race([p1, p2]).then(res => console.log(res))\r\n```\r\n要注意的是当传入空数组时`Promise.all([])`会立即执行完毕  \r\n而`Promise.race([])`会永远处于等待状态，所以建议永远别这么使用Promise\r\n\r\n## `async` + `await` （ES7）\r\n当ES6的Generator与Promise异步编程共同使用时可以产生一些更酷的特性  \r\n让我们能够像写同步代码一样去实现异步过程  \r\n但是需要实现一个特殊的Runner来执行这个Generator  \r\nES7新增了语法糖`async`以及`await`来帮助我们更迅速的实现这一特性\r\n```js\r\nfunction asyncFunc1() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('1 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nfunction asyncFunc2() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('2 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nfunction asyncFunc3() {\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tsetTimeout(() => {\r\n\t\t\tresolve('3 done')\r\n\t\t}, 3000)\r\n\t})\r\n}\r\n\r\nasync function main() {\r\n\tconst res1 = await asyncFunc1()\r\n\tconsole.log(res1)\r\n\tconst res2 = await asyncFunc2()\r\n\tconsole.log(res2)\r\n\tconst res3 = await asyncFunc3()\r\n\tconsole.log(res3)\r\n}\r\n\r\n// 3s后 \"1 done\"\r\n// 再3s后 \"2 done\"\r\n// 再3s后 \"3 done\"\r\nmain()\r\n```\r\n可以看到，相较于`Promise.then(...).then(...)`  \r\n这种方式让异步程序的执行过程更加一目了然\r\n需要注意的一点是`await`只能出现在`async`函数中  \r\n也就是说直接出现在最外层代码中的`const res = await fetch('xxx')`是错误的  \r\n除此之外，`await`也可以和`Promise.all()`一起使用\r\n```js\r\nasync function test() {\r\n\tconst allRes = await Promise.all([\r\n\t\tfetch('aaa'),\r\n\t\tfetch('bbb')\r\n\t])\r\n}\r\n```\r\n"},"./src/blogs/ReactRedux.md":function(r,n){r.exports="# React-Redux 从入门到后悔\r\n\r\n## 序\r\nRedux作为一个简单的用于管理应用状态的工具，可以与任何其它的前端框架共用  \r\n当然，尤其适用于数据驱动视图的框架(Vue/React/Angular)  \r\n为了避免让我们自己将Redux的Store一层一层往子组件传递  \r\n然后在一遍遍通过subscribe来监听Store的变化并去修改组件的状态  \r\nReact-Redux利用高阶组件(HOC)  \r\n将上述逻辑封装到了`<Provider>`以及`connect()`俩个简单的API中  \r\n当开发者想在React中使用Redux时，React-Redux将会是必不可少的帮手\r\n\r\n## How to use\r\n首先，用Redux提供的`<Provider>`包裹根组件\r\n```js\r\n// 新建Redux的Store\r\nconst store = createStore(reducers)\r\n\r\nReactDOM.render(\r\n\t<Provider store={store}>\r\n\t\t<App />\r\n\t</Provider>,\r\n\tdocument.getElementById('root')\r\n)\r\n```\r\n然后通过\r\n```js\r\nconnect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])(Comp)\r\n```\r\n这样就能得到注入Redux后的新组件  \r\n如果不传入`mapStateToProps`，则不会在该组件中去监听`store`的变化  \r\n如果不传入`mapDispatchToProps`，则默认只将`dipatch`注入组件  \r\n```js\r\nexport default connect()(Comp)\r\n```\r\n将`dispatch`注入组件  \r\n这样在组件中就可以通过`this.props.dispatch(action)`来修改Redux的`store`  \r\n但不会去监听`store`的变化\r\n```js\r\nexport default connect(state => state)(Comp)\r\n```\r\n监听所有`store`的的变化，并注入`dispatch`  \r\n不建议这么做，会降低程序的效率\r\n```js\r\nconst mapStateToProps = (state, ownProps) => {\r\n\treturn { all: state.total + ownProps.total }\r\n}\r\nexport default connect(mapStateToProps)(Comp)\r\n```\r\n注入`all`以及`dispatch`，并且监听`store`的变化  \r\n当`store`中的`total`或者组件自身的`total`发生变化时都会重绘组件\r\n```js\r\nconst mapDispatchToProps = dispatch => {\r\n\treturn {\r\n\t\taddTodo: todo => dispatch(todoActionCreator(todo))\r\n\t\t// 可以在此处借助bindActionCreators\r\n\t\t// addTodo: bindActionCreators(todoActionCreator, dispatch)\r\n\t}\r\n}\r\nexport default connect(null, mapDispatchToProps)(Comp)\r\n```\r\n不监听`store`  \r\n在组件中可以通过调用`this.props.addTodo('xx')`来改变应用状态\r\n\r\n## 源码中学习到的小技巧\r\nReact-Redux 默认通过以下方法来比较组件的Props是否相等  \r\n如果不等则意味着组件需要进行重绘\r\n```js\r\n// 通过hasOwn.call(xx, xx)\r\n// 相较于xx.hasOwnProperty(xx) 更简洁？\r\nconst hasOwn = Object.prototype.hasOwnProperty\r\n\r\n// Object.is()的Polyfill\r\nfunction is(x, y) {\r\n\tif (x === y) {\r\n\t\t// Object.is(0, -0) => false\r\n\t\treturn x !== 0 || y !== 0 || 1 / x === 1 / y \r\n\t} else {\r\n\t\t// Object.is(NaN, NaN) => true\r\n\t\treturn x !== x && y !== y\r\n\t}\r\n}\r\n\r\nexport default function shallowEqual(a, b) {\r\n\tif (is(a, b)) return true\r\n\t\r\n\t// 如果a或者b不是object 并且Object.is(a, b) => false\r\n\t// 则认为a和b不等\r\n\tif (typeof a !== 'object' || a === null ||\r\n\t\ttypeof b !== 'object' || b === null\r\n\t) {\r\n\t\treturn false\r\n\t}\r\n\t\r\n\tconst keysA = Object.keys(a)\r\n\tconst keysB = Object.keys(b)\r\n\t\r\n\t// 在a和b都是object的情况下\r\n\t// 如果a与b的所有key值相同 并且与之对应的value都满足Object.is(v1, v2) => true\r\n\t// 则也认为a和b相等\r\n\tif (keysA.length !== keysB.length) return false\r\n\tfor (let i = 0; i < keysA.length; i++) {\r\n\t\tif (!hasOwn.call(b, keysA[i]) ||\r\n\t\t\t!is(objA[keysA[i]], objB[keysA[i]])\r\n\t\t) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn true\r\n}\r\n```\r\n\r\n*********\r\n\r\nReact的PropTypes除了进行如下的基础校验\r\n```js\r\nnumber string object bool func\r\narray\r\nsymbol\r\nnode // 任何可以被当作节点绘制的类型\r\nelement // React Element\r\n```\r\n还可以利用相关API进行更严格的格式校验\r\n```js\r\nMyComponent.propTypes = {\r\n\t// 指定值中的其中一个 类似枚举类型\r\n\txx: PropTypes.oneOf(['News', 'Photos']),\r\n\t// 特定实例\r\n\txx: PropTypes.instanceOf(Foo),\r\n\t// 多种可选基础类型\r\n\txx: PropTypes.oneOfType([\r\n\t\tPropTypes.string,\r\n\t\tPropTypes.number\r\n\t]),\r\n\t// 只包含特定类型值的数组\r\n\txx: PropTypes.arrayOf(PropTypes.number),\r\n\t// 只包含特定类型值的对象\r\n\txx: PropTypes.objectOf(PropTypes.number),\r\n\t// 必须包含指定属性的对象\r\n\txx: PropTypes.shape({\r\n\t\txx: PropTypes.number,\r\n\t\tyy: PropTypes.bool.isRequired\r\n\t}),\r\n\t// 只能包含指定属性的对象\r\n\txx: PropTypes.exact({\r\n\t\txx: PropTypes.number,\r\n\t\tyy: PropTypes.bool.isRequired\r\n\t}),\r\n\t// 任意值\r\n\txx: PropTypes.any.isRequired\r\n}\r\n```\r\n\r\n*********\r\n\r\nReact 的高阶组件(HOC)并不会自动将被包裹组件的静态方法自动继承到新返回的组件中  \r\n会导致以下问题\r\n```js\r\nWrappedComponent.staticMethod = () => {}\r\n\r\nconst EnhancedComponent = HOC(WrappedComponent)\r\nEnhancedComponent.staticMethod // => undefined\r\n```\r\n可以借助[hoist-non-react-statics](https://github.com/mridgway/hoist-non-react-statics)来解决这个问题\r\n```js\r\nimport hoistNonReactStatic from 'hoist-non-react-statics'\r\n\r\nconst EnhancedComponent = hoistNonReactStatic(HOC(WrappedComponent), WrappedComponent)\r\nEnhancedComponent.staticMethod // => () => {}\r\n```\r\n"},"./src/blogs/Redux.md":function(r,n){r.exports="# Redux从入门到放弃\r\n\r\n## 基本概念\r\n前端应用日渐复杂，传统的JavaScipt+HTML+CSS三大件变得难以应对  \r\n近几年出现的各类MVVM框架(React/Vue/Angular)使我们可以开发管理更复杂的单页应用(SPA)  \r\n随之而来碰到的问题是对应用中各种状态的管理  \r\n每个组件都有各自的状态，当任意一个组件的状态发生变更，同时也可能需要触发另一个组件状态的变更  \r\n当这种耦合关系越来越多的时候，我们会发现很难去寻找一个状态发生变更的原有  \r\n并且当组件层级过深时，一层层的在组件间传递props也显得颇为繁琐  \r\nRedux的出现给开发者提供了一种更加规范的管理前端应用状态的解决方案  \r\n当然相应的代价是需要引入更冗余的语法(boilerplate)  \r\nRedux通过以下三个原则来更好的管理应用的状态:  \r\n* Single source of truth: Redux应用中的状态应该是全局唯一的  \r\n也就是说每个Redux应用应该只有一个全局唯一的Store\r\n* State is read-only: Store中存储的状态不能被直接修改  \r\n只能通过Dispatch Action来进行应用状态的变更  \r\n这样通过一些工具开发者可以很清楚的看到状态发生变更的时机以及每次所发生的改变  \r\n甚至进行Time Travel来回到某个Action执行前的状态  \r\n亦或是再次重新提交这个Action来观察其行为对应用的影响  \r\n* Changes are made with pure functions: Reducer只能是Pure Function  \r\n不能在其中直接修改Store中存储的值  \r\n而是依据Dispatch的不同Actions返回新的状态  \r\n\r\n### Actions\r\n不同于直接去修改应用的状态，例如react中的`this.setState()`  \r\nRedux推崇通过Dispacth Action来修改状态  \r\nAction是一个携带了操作类型以及具体改变数据的简单对象(Plain Object)  \r\n```js\r\nconst action = {\r\n\t// 操作类型 用于描述该次操作的用意\r\n\t// 通常由下划线分隔的大写字符组成\r\n\t// 当有很多action时建议将type提取成常量放到单独文件维护\r\n\ttype: 'ADD_PEOPLE',\r\n\t// 具体操作的数据\r\n\tpeople: {\r\n\t\tname: 'a'\r\n\t}\r\n}\r\n```\r\n以上Action中的数据是固定的，可以通过一个ActionCreator来根据参数动态的生成数据  \r\n```js\r\nconst actionCreator = people => ({\r\n\ttype: 'ADD_PEOPLE',\r\n\tpeople\r\n})\r\n```\r\n注意Action并不会真正的去改变状态，而只是携带了待改变状态的相关信息  \r\n需要通过'store.dispatch(action)'将Action派发至Reducer中才能进行状态的变更  \r\n所以具体的状态改变逻辑应该在Reducer中实现\r\n\r\n### Reducer\r\nReducer用于定义根据收到的不同Action如何去改变应用的状态  \r\nReducer应该是一个Pure function,意味着不应该在其中去改变参数  \r\n并且当入参相同时其返回值应该总是相同的  \r\n```js\r\n// 注意需要给我们的应用设置一个初始化的initalState\r\n// 如果未指定 Redux会开发环境下给出警告\r\nfunction reducer(state = initalState, action) {\r\n\tswitch(action.type) {\r\n\t\tcase 'ADD_PEOPLE':\r\n\t\t\treturn { ...state, ...{ people: action.people } }\r\n\t\t// 在遇到未知的Action时需要将原先的state直接返回\r\n\t\tdefault:\r\n\t\t\treturn state\r\n\t}\r\n}\r\n```\r\n\r\n### Store\r\n每一个应用都只能有一个唯一的Store  \r\n通过`createStore(reducers)`来生成  \r\n用于维护应用的所有State，以及提供一些静态方法用于改变、获取当前状态  \r\n```js\r\nstore.getState() // 获取当前状态\r\nstore.dispatch(action) // 提交action来改变当前状态\r\nconst unsubscribe = store.subscribe(listener) // 监听事件\r\nunsubscribe() // 取消监听\r\n```\r\n\r\n## 进阶以及源码(v4.0.0)\r\n\r\n### Middleware\r\nRedux提供的中间件使开发者可以在每次`dispatch(action)`前后加上一些特定的逻辑  \r\n例如logging/routing等，中间件的通用形式如下  \r\n```js\r\nconst middleware = store => next => action => {\r\n\t// 在dispatch前执行的逻辑\r\n\t// ...\r\n\t\r\n\tconst result = next(action)\r\n\t\r\n\t// ...\r\n\t// 在dispatch完成后执行的逻辑\r\n\treturn result\r\n}\r\n```\r\n\r\n### compose.js\r\n在Redux的applyMiddleware中会用到，函数式编程中常见  \r\n可以将传入的函数从右至左依次执行  \r\n并且每个函数执行的结果会作为下一个函数的参数\r\n类似`compose(a, b, c)(arg)`执行起来同`a(b(c(arg)))`\r\n```js\r\nexport function compose(...funcs) {\r\n\t// 如果没有传入任何参数 则直接返回一个会将第一个参数返回的函数\r\n\tif (funcs.length === 0) {\r\n\t\treturn arg => arg\r\n\t}\r\n\t\r\n\t// 如果参数只有一个函数则直接将该函数返回\r\n\tif (funcs.lenth === 1) {\r\n\t\treturn funcs[0]\r\n\t}\r\n\t\r\n\t// 关于Array.prototype.reduce \r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\r\n\treturn funcs.reduce((a, b) => (...args) => a(b(...args)))\r\n}\r\n\r\n----------- 下面都是分析  --------------\r\n\r\n// 我们来试试funcs.reduce是如何来实现逻辑的\r\nconst first = () => console.log(1)\r\nconst second = () => console.log(2)\r\nconst third = () => console.log(3)\r\nconst funcs = [first, second, third]\r\n\r\n// 分解开来看\r\n// 第一次reduce相当于\r\n// (first, second) => (...args) => first(second(...args))\r\n// 其返回结果是\r\n// (...args) => first(second(...args))\r\n// 第二次reduce执行时的accumulator及第一次的返回结果\r\n// 所以 (accumulator, third) => (...args) => accumulator(third(...args))\r\n// 返回结果是 \r\n// (...args) => accumulator(third(...args))\r\n// 相当于\r\n// (...args) => first(second(third(...args))\r\nconst re = funcs.reduce((a, b) => (...args) => a(b(...args)))\r\n\r\n// 上述代码中有一个地方要理解一下\r\n// const test = (...args) => f(...args)\r\n// 在参数中的...其实起到的是收集的作用，会将我们调用时传入的所有参数放到args这个数组中\r\n// 而在f(...args)中的...起到的是解构的作用\r\n// 又会将args数组中的所有元素依次作为参数传到f这个函数中\r\n// 假设我们test(1, 2, 3)这样调用则其返回结果其实就是f(1, 2, 3)\r\n// 所以这种做法其实就是在我们不确定一个函数入参个数的情况下\r\n// 将所有入参原封不动的按照原有顺序传入到调用函数中\r\n// 按照老的方式其实就是借助arguments来实现\r\n// es6\r\nconst test = (...args) => f(...args)\r\n// Babel编译后\r\nvar test = function test() {\r\n\treturn f.apply(undefined, arguments)\r\n}\r\n\r\n// 从上述分析可以得出 re其实就等同于\r\n// (...args) => first(second(third(...args))\r\n// 当我们调用re()就等同于\r\n// first(second(third())\r\n// 所以输出是 3 2 1\r\nre() // 3 2 1\r\n\r\n// 通过对传入函数的特殊处理 可以使这个过程变为正序\r\n// Redux的middleWare就是借助这种原理\r\nconst a = next => arg => { console.log(arg); next('b'); }\r\nconst b = next => arg => { console.log(arg); next('c'); }\r\nconst c = next => arg => { console.log(arg); next('d'); }\r\nconst d = arg => console.log(arg)\r\n\r\n// 'a' 'b' 'c' 'd'\r\ncompose(a,b,c)(d)('a')\r\n// 继续分解来看一下 首先是compose(a, b, c)\r\n// 从上述分析得出的结论来看也就是等同于\r\n// (...args) => a(b(c(...args)))\r\n// 然后是compose(a,b,c)(d) 所以入参为函数d\r\n// 也就是等同于a(b(c(d)))\r\n// 第一步c(d) 返回 re1 = arg => {console.log(arg); d('d')}\r\n// 第二步b(c(d)) 也就是b(re1) 返回 re2 = arg => { console.log(arg); re1('c'); }\r\n// 第三步a(b(c(d))) 也就是a(re2) 返回 re3 = arg => { console.log(arg); re2('b'); }\r\n// 所以compose(a,b,c)(d) 返回的就是 arg => { console.log(arg); re2('b'); }\r\n// 最后一步compose(a,b,c)(d)('a') 相当于\r\n// console.log('a'); re2('b')\r\n// 再把所有的结果展开\r\n// console.log('a'); console.log('b'); console.log('c'); console.log('d');\r\n```\r\n\r\n### applyMiddleware\r\n对外提供应用中间件的接口\r\n```js\r\nexport default function applyMiddleware(...middlewares) {\r\n\t// 注意applyMiddleware是一个高阶函数\r\n\t// 返回值是一个入参为createStore的函数\r\n\treturn createStore => (...args) => {\r\n\t\t// 当需运用中间件时 createStore在此处真正执行\r\n\t\tconst store = createStore(...args)\r\n\t\t\r\n\t\t// 如果middleware在执行自己的逻辑过程中调用dispatch则抛出错误\r\n\t\tlet dispatch = () => { throw new Error('...') }\r\n\t\t\r\n\t\t// 只提供给中间件有限的API而不是全部store\r\n\t\tconst middlewareAPI = {\r\n\t\t\tgetState: store.getState,\r\n\t\t\tdispatch: (...args) => dispatch(...args)\r\n\t\t}\r\n\t\t// 要注意此时如果在middleware中执行 middlewareAPI.dispatch() 会抛出错误\r\n\t\t// 由于Redux规定middleware形如 store => next => action => {} 的函数\r\n\t\t// 这样处理过后在chain中存放的便是形如 next => action => {} 的函数\r\n\t\tconst chain = middlewares.map(middleware => middleware(middlewareAPI))\r\n\t\t// 这里的dispatch是已经实现了中间件逻辑后的dispatch方法\r\n\t\tdispatch = compose(...chain)(store.dispatch)\r\n\t\t\r\n\t\t// 这里利用了解构会去重的特性\r\n\t\t// 会将store.dispatch覆盖为包含中间件逻辑的新dispatch\r\n\t\treturn {\r\n\t\t\t...store,\r\n\t\t\tdispatch\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n### utils/warning.js\r\nRedux通过该函数在开发环境下向控制台输出错误或提示信息方便开发者Debug\r\n```js\r\nexport default function warning(message) {\r\n\t// 为了增强程序的Robusty 只有当前运行的宿主环境存在console\r\n\t// 并且console.error是函数才去调用 使得任何情况下都不会因为该函数报错\r\n\t// 从而导致程序终止运行\r\n\tif (typeof console !== 'undefined' && typeof console.error === 'function') {\r\n\t\tconsole.error(message)\r\n\t}\r\n\t\r\n\t// 下面这段代码只有当我们打开浏览器的Console\r\n\t// 并开启break on all exceptions功能时\r\n\t// 才会在每次报错或提示时暂停程序执行(相当在出错的那行打断点)\r\n\t// 否则的话不会有任何作用\r\n\t// 同样是为了方便开发者进行Debug\r\n\ttry {\r\n\t\tthrow new Error(message)\r\n\t} catch (e) {}\r\n}\r\n```\r\n\r\n### utils/isPlainObject.js\r\n由于Redux中要求Action必须是Javascript中的Plain Object  \r\n所以这个工具函数用于判断一个对象是否满足该条件  \r\n会在`dispatch(action)`执行最开始处进行判断，如果传入的action不满足条件会抛出错误  \r\n所谓的Plain Object指的是直接通过`{}`或者`new Object()`生成，原型链上并没有其它对象的Object\r\n```js\r\nexport function isPlainObject(obj) {\r\n\t// 如果对象都不是当然也不是PlainObject\r\n\t// 这里注意的是 obj === null 这个判断\r\n\t// 因为在Js中 typeof null === 'object'\r\n\tif (typeof obj !== 'object' || obj === null) return false\r\n\t\r\n\t// lodash中的isPlainObject多了这个逻辑\r\n\t// 主要考虑到这个特殊情况 const o = Object.create(null)\r\n\t// 此处的o应该也满足条件 isPlainObject(o) // => true\r\n\tif (Object.getPrototypeOf(obj) === null) {\r\n\t\treturn true\r\n\t}\r\n\t\r\n\tlet proto = obj\r\n\t// 因为 Object.getPrototypeOf(Object.prototype) === null\r\n\t// 所以当循环结束时 proto 指向的其实就是Object.prototype\r\n\t// 也就是说此时的proto === Object.prototype\r\n\twhile (Object.getPrototypeOf(proto) !== null) {\r\n\t\tproto = Object.getPrototypeOf(proto)\r\n\t}\r\n\t\r\n\t// 如果传入对象的prototype与Object.prototype一致\r\n\t// 则认为该对象是Plain Object\r\n\t// 所以最终的判断逻辑其实与obj.__proto__ === Object.prototype类似\r\n\t// 上面的代码更多的是在考虑edge case\r\n\treturn Object.getPrototypeOf(obj) === proto\r\n}\r\n```\r\nPs: `lodash.isPlainObject`逻辑与上述代码基本一致  \r\n同样是Redux的timdorr提的PR\r\n\r\n### index.js\r\n```js\r\nimport createStore from './createStore'\r\nimport combineReducers from './combineReducers'\r\nimport bindActionCreators from './bindActionCreators'\r\nimport applyMiddleware from './applyMiddleware'\r\nimport compose from './compose'\r\nimport warning from './utils/warning'\r\nimport __DO_NOT_USE__ActionTypes from './utils/actionTypes'\r\n\r\n// 建立一个函数名为isCrushed的空函数\r\nfunction isCrushed() {}\r\n\r\n// 如果当前的环境不是生成环境但采用了压缩过后的代码则提示开发者\r\n// 因为压缩混淆后的代码会将函数改变为类似 function f() {} 以减小代码体积\r\nif (process.env.NODE_ENV !== 'production' && \r\n\ttypeof isCrushed.name === 'string' &&\r\n\tisCrushed.name !== 'isCrushed'\r\n) {\r\n\twarning('...')\r\n}\r\n\r\n// 以下为Redux所有对外提供的API\r\nexport {\r\n\tcreateStore,\r\n\tcombineReducers,\r\n\tbindActionCreators,\r\n\tapplyMiddleware,\r\n\tcompose,\r\n\t__DO_NOT_USE__ActionTypes\r\n}\r\n```\r\n\r\n### createStore.js\r\nRedux应用的主入口文件  \r\n```js\r\n// reducer 必传 通常来讲是我们通过combineReducers将所有ruducer集成到一起后的主函数\r\n// preloaderState 可选 可以传入的应用初始状态\r\n// enhancer 可选 也就是applyMiddleware()的返回结果\r\nexport default function createStore(reducer, preloadedState, enhancer) {\r\n\t// 由于preloadedState参数是可选的 所以这里考虑的是这么一种情况\r\n\t// createStore(reducer, applyMiddleware())\r\n\t// 这样在不传入preloadedState时就不用像createStore(reducer, null, applyMiddleware())这样调用\r\n\tif (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\r\n\t\tenhancer = preloadedState\r\n\t\tpreloadedState = undefined\r\n\t}\r\n\t\r\n\t// 有传入enhancer 也就是有使用中间件(applyMiddleware)\r\n\tif (typeof enhancer !== 'undefined') {\r\n\t\t// applyMiddleware()返回的应该是一个函数 否则需要报错\r\n\t\tif (typeof enhancer !== 'function') {\r\n\t\t\tthrow new Error('Expected the enhancer to be a function.')\r\n\t\t}\r\n\t\t\r\n\t\t// 有使用中间件的话 需要在applyMiddleware去createStore\r\n\t\t// applyMiddleware()返回的是一个形如 createStore => (...args) => {} 的函数\r\n\t\t// 所以这里会对enhancer(cerateStore)返回的结果再次传入参数(reducer, preloaderState)调用\r\n\t\treturn enhancer(createStore)(reducer, preloaderState)\r\n\t}\r\n\t\r\n\t// reducer也必须为函数\r\n\tif (typeof reducer !== 'function') {\r\n\t\tthrow new Error('Expected the reducer to be a function.')\r\n\t}\r\n\t\r\n\t// 利用闭包存储当前的Reducer\r\n\t// 这样就稍后才可通过replaceReducer()方法替换掉当前使用的Reducer\r\n\tlet currentReducer = reducer\r\n\t\r\n\t// 同上 整个Redux应用的状态树都是利用闭包存储的\r\n\tlet currentState = preloadedState\r\n\t\r\n\t// 这里要注意 多存了一份当前监听事件函数的备份\r\n\tlet currentListeners = []\r\n\tlet nextListeners = currentListeners\r\n\t\r\n\t// 用于标识当前是否正在执行dispatch()操作\r\n\tlet isDispatching = false\r\n\t\r\n\t// 确保nextListeners存的是currentListeners的备份 而不是引用\r\n\tfunction ensureCanMutateNextListeners() {\r\n\t\tif (nextListeners === currentListeners) {\r\n\t\t\tnextListeners = currentListeners.slice()\r\n\t\t}\r\n\t}\r\n\t\r\n\t// 简单的把当前闭包所存储的应用状态返回出去\r\n\tfunction getState() {\r\n\t\t// 正在执行dispatch操作时不能获取当前状态\r\n\t\t// 因为当前状态可能会被正在执行的dispatch()操作改变\r\n\t\tif (isDispatching) {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\t\r\n\t\treturn currentState\r\n\t}\r\n\t\r\n\t// 注册监听事件 在每次dispath时都会调用所有注册过的函数\r\n\tfunction subscribe(listener) {\r\n\t\t// 注册的listener只能是函数\r\n\t\tif (typeof listener !== 'function') {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\r\n\t\t// 正在执行dispatch操作时不允许新注册监听事件\r\n\t\tif (isDispatching) {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\t\r\n\t\t// 这里同样利用了闭包\r\n\t\t// 每次调用都会有独立的isSubscribed状态\r\n\t\t// 与每个listener一一对应\r\n\t\tlet isSubscribed = true\r\n\t\t\r\n\t\tensureCanMutateNextListeners()\r\n\t\tnextListeners.push(listener)\r\n\t\t\r\n\t\treturn function unsubscribe(){\r\n\t\t\t// 避免重复取消监听 例如\r\n\t\t\t// const off = store.subscribe(...)\r\n\t\t\t// off()\r\n\t\t\t// off()\r\n\t\t\tif (!isSubscribed) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 正在执行dispatch操作时不允许取消监听\r\n\t\t\tif (isDispatching) {\r\n\t\t\t\tthrow new Error('...')\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 代表这个listener已经取消监听了\r\n\t\t\tisSubscribed = false\r\n\t\t\t\r\n\t\t\tensureCanMutateNextListeners()\r\n\t\t\t// 这里也利用了闭包 先找到当前闭包存储的入参listerner在数组中的下标\r\n\t\t\tconst index = nextListeners.indexOf(listener)\r\n\t\t\t// 移除数组中对应下标存储的元素\r\n\t\t\tnextListeners.splice(index, 1)\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tfunction dispatch(action) {\r\n\t\t// 在Redux中Action只能为plain object\r\n\t\tif (!isPlainObject(action)) {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\t\r\n\t\t// Action的type不能为空\r\n\t\t// 通常来说type都应该是一个用于描述当前行为的常量字符串\r\n\t\t// 不知道这里为什么不限制type只能为string\r\n\t\tif (typeof action.type === 'undefined') {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\t\r\n\t\t// 阻止开发者在reducer中去调用dispatch\r\n\t\tif (isDispatching) {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\t\r\n\t\ttry {\r\n\t\t\tisDispatching = true\r\n\t\t\t// currentReducer就是当前Redux正在使用的Reducer\r\n\t\t\t// 将当前状态树和action传入 返回经reducer处理过后的新状态树\r\n\t\t\tcurrentState = currentReducer(currentState, action)\r\n\t\t} finally {\r\n\t\t\t// 无论reducer处理过程中是否出错 都需要更改flag\r\n\t\t\t// 代表本次dispatch操作结束 否则接下来redux就没法用了\r\n\t\t\tisDispatching = false\r\n\t\t}\r\n\t\t\r\n\t\t// 这里要注意执行顺序\r\n\t\t// 每次dispatch都会将当前的currentListeners 指向 nextListeners\r\n\t\t// 所以每次执行的其实都是最新的nextListeners当中存储的的监听事件\r\n\t\t// 这里就可以理解ensureCanMutateNextListeners()的用处\r\n\t\t// 每次新增监听或取消监听时都要确保nextListeners是currentListener的拷贝\r\n\t\t// 这样保证在dispatch过程中的currentListerner不会发生变化\r\n\t\t// 例如如果我们在一个listener函数中去新subscribe或者unsubscribe\r\n\t\t// 都不会立马生效 而是只有等到下一次dispatch才会生效\r\n\t\tconst listeners = (currentListeners = nextListeners)\r\n\t\tfor (let i = 0; i < listeners.length; i++) {\r\n\t\t\t// 注意这里的用法 并没有直接像 listeners[i]()这样调用\r\n\t\t\t// 因为这样的话listener中的this会指向listeners而不是window\r\n\t\t\tconst listener = listeners[i]\r\n\t\t\tlistener()\r\n\t\t}\r\n\t\t\r\n\t\t// 将传入的action原封不动返回\r\n\t\t// 感觉基本来说不会用到这个函数的返回值\r\n\t\treturn action\r\n\t}\r\n\t\r\n\t// 替换当前正在使用的Reducer\r\n\tfunction replaceReducer(nextReducer) {\r\n\t\t// Reducer必须是函数\r\n\t\tif (typeof nextReducer !== 'function') {\r\n\t\t\tthrow new Error('...')\r\n\t\t}\r\n\t\t\r\n\t\t// 直接将闭包的存储指向新的Reducer\r\n\t\tcurrentReducer = nextReducer\r\n\t\t// dispatch一个REPLACE Action 来重新生成新的状态树\r\n\t\tdispatch({ type: ActionTypes.REPLACE })\r\n\t}\r\n\t\r\n\t// dispatch一个INIT Action 初始化生成Redux的状态树\r\n\tdispatch({ type: ActionTypes.INIT })\r\n\t\r\n\t// 对外主要就提供了四个API\r\n\treturn {\r\n\t\tdispatch,\r\n\t\tsubscribe,\r\n\t\tgetState,\r\n\t\treplaceReducer,\r\n\t\t[$$observable]: observable // 私有的 用于测试 这里不具体展开\r\n\t}\r\n}\r\n```\r\n\r\n### combineReducer.js\r\n由于在大型应用中我们需要管理一个复杂的状态树  \r\n如果将所有的Action处理逻辑写在同一个Reducer中会很难维护  \r\n所以大多数情况下我们的项目中会有很多个不同的Reducer文件  \r\n而Redux的`createStore(reducer)`只接受一个RootReducer作为参数  \r\n所以这个时候就需要借助Redux提供的这个工具方法将所有的子Reducer合为最终的RootReducer\r\n其主要作用如下  \r\n```js\r\n// 应用的状态树\r\nconst state = {\r\n\ta: '',\r\n\tb: ''\r\n}\r\n\r\nconst reducerA = (a, action) => {}\r\nconst reducerB = (b, action) => {}\r\n// 自己手动来生成RootReducer\r\nconst rootReducer = (state, action) => {\r\n\treturn {\r\n\t\ta: reducerA(state.a, action),\r\n\t\tb: reducerB(state.b, action)\r\n\t}\r\n}\r\n// 借助combineReducer\r\n// 入参中的key需要与state中的key相对应\r\n// 子Reducer的函数名可以任意 并无影响\r\nconst rootReducer = combineReducer({\r\n\ta: reducerA,\r\n\tb: reducerB\r\n})\r\n```\r\n下面看看源码\r\n```js\r\nimport ActionTypes from './utils/actionTypes'\r\nimport warning from './utils/warning'\r\nimport isPlainObject from './utils/isPlainObject'\r\n\r\n// 用于生成当有Reducer返回的state为undefined时的错误描述\r\nfunction getUndefinedStateErrorMessage(key, action) {\r\n\tconst actionType = action && action.type\r\n\tconst actionDescription =\r\n\t\t(actionType && `action \"${String(actionType)}\"`)) || 'an action'\r\n\treturn '...'\r\n}\r\n\r\n// 用于生成在入参的key与state中的key有不一致时生成错误描述\r\nfunction getUnexpectedStateShapeWarningMessage() {}\r\n\r\n// 判断传入的reducer是否都合规 否则抛出错误\r\nfunction assertReducerShape(reducers) {\r\n\tObject.keys(reducers).forEach(key => {\r\n\t\tconst reducer = reducers[key]\r\n\t\t// 用初始化的Action去生成默认的state\r\n\t\tconst initialState = reducer(undefined, { type: ActionTypes.INIT })\r\n\t\t// 如果有reducer没有提供默认的state则抛出错误\r\n\t\t// 所以如果即使当我们希望一个reducer默认不返回值时应该显示的返回null\r\n\t\tif (initialState === undefined) {\r\n\t\t\tthrow new Error()\r\n\t\t}\r\n\t\t\r\n\t\t// 当传一个未知type的action到reducer中时\r\n\t\t// reducer也应该返回一个状态 通常来说是将传入的state 不错修改直接返回\r\n\t\tif (typeof reducer(undefined, {\r\n\t\t\ttype: ActionTypes.PROBE_UNKNOWN_ACTION()\r\n\t\t}) === 'undefined') {\r\n\t\t\tthrow new Error()\r\n\t\t}\r\n\t})\r\n}\r\n\r\n// 将多个子reducer组合返回一个root reducer函数\r\nexport default function combineReducers(reducers) {\r\n\t// 拿到入参对象的所有key\r\n\tconst reducerKeys = Object.keys(reducers)\r\n\tconst finalReducers = {}\r\n\t\r\n\tfor (let i = 0; i < reducerKeys.length; i++) {\r\n\t\tconst key = reducerKeys[i]\r\n\t\t\r\n\t\t// 只有在开发环境下进行警告提示\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\t// 不是很理解这个判断\r\n\t\t\t// 只有当入参对象的value中有undefined时才会警告\r\n\t\t\tif (typeof reducers[key] === 'undefined') {\r\n\t\t\t\twarning('...')\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 这一步会过滤掉入参中value不是函数的部分\r\n\t\t\t// 确保fianalReducers中的每个value都是一个函数\r\n\t\t\tif (typeof reducers[key] === 'function') {\r\n\t\t\t\tfinalReducers[key] = reducers[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (typeof reducers[key] === 'function') {\r\n\t\t\tfinalReducers[key] = reducers[key]\r\n\t\t}\r\n\t\tconst finalReducerKeys = Object.keys(finalReducers)\r\n\t\t\r\n\t\tlet unexpectedKeyCache\r\n\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\tunexpectedKeyCache = {}\r\n\t\t}\r\n\t\t\r\n\t\tlet shapeAssertionError\r\n\t\ttry {\r\n\t\t\tassertReducerShape(finalReducers)\r\n\t\t} catch (e) {\r\n\t\t\tshapeAssertionError = e\r\n\t\t}\r\n\t\t\r\n\t\treturn function combination(state = {}, action) {\r\n\t\t\t// 当Reducer格式有误时 终止执行 抛出错误\r\n\t\t\tif (shapeAssertionError) {\r\n\t\t\t\tthrow shapeAssertionError\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// 开发环境下给出错误提示\r\n\t\t\tif (process.env.NODE_ENV !== 'production') {\r\n\t\t\t\tconst warningMessage = getUnexpectedStateShapeWarningMessage(...)\r\n\t\t\t\tif (warningMessage) {\r\n\t\t\t\t\twarning(warningMessage)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlet hasChanged = false\r\n\t\t\tconst nextState = {}\r\n\t\t\tfor (let i = 0; i < finalReducerKeys.length; i++) {\r\n\t\t\t\tconst key = finalReducerKeys[i]\r\n\t\t\t\tconst reducer = finalReducers[key]\r\n\t\t\t\tconst previouStateForKey = state[key]\r\n\t\t\t\tconst nextStateForKey = reducer(previousStateForKey, action)\r\n\t\t\t\t// Reducer处理过后的状态不能返回为空\r\n\t\t\t\tif (typeof nextStateForKey === 'undefined') {\r\n\t\t\t\t\tthrow new Error('...')\r\n\t\t\t\t}\r\n\t\t\t\tnextState[key] = nextStateForKey\r\n\t\t\t\t// 判断经Reducer处理后的状态前后是否发生变化\r\n\t\t\t\thasChanged = hasChanged || nextStateForKey !== previousStateForKey\r\n\t\t\t}\r\n\t\t\t// 注意 对于Redux而言 整个状态树中只要有一处发生变化 则视为其有过变化\r\n\t\t\treturn hasChanged ? nextState : state\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n### bindActionCreators.js\r\n在Redux中我们每次先通过ActionCreator去生成一个Action  \r\n然后再通过`dispatch(action)`来触发状态的改变  \r\n有时候我们想要把Redux的相关逻辑放到父组件中  \r\n然后将改变状态的函数传入子组件，这个时候就需要利用bindActionCreators  \r\n该函数可以将create action以及dispatch这俩步操作绑定在一起  \r\n这样每次通过绑定后的Creator去生成Action时会同时进行dispatch操作\r\n```js\r\nfunction bindActionCreator(actionCreator, dispatch) {\r\n\t// 返回一个函数 执行会先Create Action  \r\n\t// 然后dispatch这个生成的Action\r\n\treturn function () {\r\n\t\tdispatch(actionCreator.apply(this, arguments))\r\n\t}\r\n}\r\n\r\nexport default bindActionCreators(actionCreators, dispatch) {\r\n\t// 传入单个creator\r\n\t// 直接返回绑定后的creator\r\n\tif (typeof actionCreators === 'function') {\r\n\t\treturn bindActionCreator(actionCreators, dispatch)\r\n\t}\r\n\t\r\n\t// 传入的actionCreators既不是函数也不是对象则抛出错误\r\n\tif (typeof actionCreators !== 'object' || typeof actionCreators === null) {\r\n\t\tthrow new Error('')\r\n\t}\r\n\t\r\n\tconst keys = Object.keys(actionCreators)\r\n\t// 用于存储绑定后的Creator\r\n\tconst boundActionCreators = {}\r\n\tfor (let i = 0; i < keys.length; i++) {\r\n\t\tconst key = keys[i]\r\n\t\tconst actionCreator = actionCreators[key]\r\n\t\t// actionCreator必须是一个函数\r\n\t\tif (typeof actionCreator === 'function') {\r\n\t\t\t// 依次绑定每一个Creator\r\n\t\t\tboundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\r\n\t\t}\r\n\t}\r\n\t// 将绑定后的结果返回\r\n\treturn boundActionCreators\r\n}\r\n```\r\n"},"./src/blogs/SourceMapAndWebpack.md":function(r,n){r.exports='# 关于 Source Map 以及 Webpack 中 Devtool 的相关配置\r\n\r\n## Source Map 是什么\r\n为了提升 Web App 的性能，通常我们会把源码压缩混淆后再发布到服务器上  \r\n当 App 出现问题时这些压缩过后的代码就会使得我们很难具体定位到错误出现在哪  \r\nSource Map 的出现正是为了解决这个难题  \r\n通过在压缩后的代码中加入如下注释\r\n```js\r\n// 注意此处的 sourceMappingURL 支持 http uri 以及 data uri 俩种形式\r\n//# sourceMappingURL=/path/to/script.js.map\r\n```\r\n并在压缩混淆同时生成相应的 map 文件\r\n```js\r\n{\r\n    version: 3,\r\n    file: "script.js.map",\r\n    sources: [\r\n        "a.js",\r\n        "b.js",\r\n        "c.js"\r\n    ], // 所有源文件的路径\r\n    sourceRoot: "/",\r\n    names: ["foo", "bar", "func"], // 所有源文件中出现的变量名 函数名\r\n\t// 关键所在 具体原理就不管了 有点复杂 大致是通过 Base64-VQL 编码做映射\r\n    mappings: "AABASD,ASDFDSA,OAAOC,OAAO..."\r\n}\r\n```\r\n这样浏览器就可以反向定位到错误具体出现在源码中的哪个文件的哪一行中  \r\nPs: [关于原理](https://www.codercto.com/a/31149.html)\r\n\r\n## 关于 Source Map 的几个问题以及解答\r\n### 为什么在浏览器的 network 中看不到下载 .map 文件的请求\r\n浏览器默认只会在打开开发者工具时才去请求 .map 文件  \r\n所以在 network 中看不到记录\r\n[Stackoverflow](https://stackoverflow.com/questions/44315460/when-do-browsers-download-sourcemaps#)\r\n\r\n### 如果将 .map 文件也发布到公开的服务器上，普通用户能否利用 Source Map 看到源文件\r\n很不幸，答案是会的  \r\n更不幸的是，通过 .map 文件以及压缩后的代码可以反向生成源代码  \r\n这意味着在公开的生产环境下我们不应该去使用 Source Map  \r\n因为这样相当于把整个 App 的源码暴露在外，是一种很危险的行为  \r\n建议在类似预发环境(也就是与正式环境相同但是是私有的环境)下来利用 Source Map 进行 Debug  \r\nPs: 还可以通过服务器端的配置来禁止普通用户下载 .map 文件，这样就可以安全的把 .map 文件也放到正式环境上\r\n\r\n### Source Map 对开发环境的意义何在\r\n开发环境我们通常不会采用混淆代码，对于简单的 Javascript 应用可能意义并不大  \r\n但当我们在开发 React App 或者 Vue App 时  \r\nSource Map 可以将我们 Webpack 打包后的文件直接映射为源代码中的 .jsx/.vue 文件  \r\n而不利用 Source Map 我们就只能去 Debug 编译过后的文件  \r\n所以即是在开发环境下，Source Map 也是能给我们提供很大帮助的\r\n\r\n## Webpack 的 Devtool\r\nWebpack 中可以通过这项配置来决定具体使用何种 Source Map  \r\n默认值为 `false` 也就是不启用 Source Map  \r\n从方便 Debug 的角度从差到好排列，Webpack 一共提供了如下几种形式的 Source Map\r\n* bundled code // 不开启 浏览器中只能看到打包过后的代码\r\n* generated code // 可以看到打包前的每个 Module 但是看到的是 Webpack 处理后的文件\r\n* transformed code // 可以看到打包前的每个 Module 但是看到的是经过 Loader 编译过后的文件\r\n* original source // 可以看到源码\r\n* (lines only) // 只定位到行 不定位到列\r\n* without source content // 不暴露源文件 但是仍会暴露目录结构 可以在错误信息中看到源码对应的出错行列\r\n\r\n关于 Devtool 的配置大致由如下几种关键字组合而来，每个关键字代表着不同特性\r\n* eval // 编译速度最快\r\n* inline // 不生成 .map 文件 以DataURL的形式嵌入\r\n* cheap // 只定位到行 transformed code\r\n* cheap-module // 只定位到行 original source\r\n\r\n就目前来说  \r\n个人感觉在开发环境下设为 `cheap-module-eval-source-map`  \r\n可以获得较好的 Debug 体验，以及较快的编译速度  \r\n在预发环境下设为 `source-map` 可以获得最完整的映射  \r\n在正式环境下设为 `false` 避免源文件暴露  \r\n当然碰到具体问题时可以进行调整  \r\n要记住 Source Map 的终极目的是为了方便开发者定位问题  \r\n所以只要能帮助我们找到问题的配置就是好配置\r\n\r\nPs: Webpack V4 中，当 mode 设为 \'production\' 时  \r\n默认使用的 `uglifyjs-webpack-plugin` 会默认设置 `sourceMap: true`  \r\n当我们手动去新配置 `uglifyjs-webpack-plugin` 时会覆盖掉默认配置  \r\n所以要注意像如下配置一样加上 `sourceMap: true` 否则 Souce Map 会不生效\r\n```js\r\n// webpack.prod.config.js\r\nconst UglifyJsPlugin = require("uglifyjs-webpack-plugin")\r\n\r\nmodule.exports = {\r\n\t// ...\r\n\tmode: \'production\',\r\n\toptimization: {\r\n\t\tminimizer: [\r\n\t\t\tnew UglifyJsPlugin({\r\n\t\t\t\t// ...\r\n\t\t\t\tsourceMap: true // 注意这里!!!!!!\r\n\t\t\t\t// ...\r\n\t\t\t})\r\n\t\t]\r\n\t}\r\n\t// ...\r\n}\r\n```\r\n'},"./src/blogs/Symbol.md":function(r,n){r.exports="# Symbols in ES6\r\n`Symbol`是ES6中(时隔多年)新增的一种**primitive type**，可以把它看做一种自动生成**唯一字符串**的机制，它的真实值被隐藏在代码后且永远无法直接获得\r\n\r\n## 如何生成Symbol\r\n```js\r\n// 最基础的方式\r\nconst a = Symbol()\r\n\r\n// 可以传入一串描述该Symbol用途的字符串作为参数\r\nconst b = Symbol('some description text')\r\n\r\n// 从全局的Symbol库中查询所需的Symbol\r\n// 如果未找到则新建一个并返回\r\n// 这种方式较以上直接构造Symbol的优点在于\r\n// 可以不必在外部作用域中专门维护一个变量用于存储生成的Symbol\r\nconst c = Symbol.for('my Symbol')\r\n\r\n// 由于不管如何Symbol都是全局存在的\r\n// 为了尽量避免可能发生的冲突 可以给Symbol添加相应的前缀\r\nconst d = Symbol.for('prefix.Symbol')\r\n```\r\n\r\n## 如何判断一个值是否为Symbol\r\n```js\r\nconst a = Symbol()\r\n// 推荐方式\r\ntypeof a === 'symbol'// true\r\n\r\n// 其余方式\r\na instanceof Symbol // false\r\nObject(a) instanceof Symbol // true\r\nObject(a).valueOf() === a // true\r\n```\r\n\r\n## 如何获得Symbol的描述字符串\r\n```js\r\nconst a = Symbol('desc a')\r\nconst b = Symbol.for('desc b')\r\n\r\nSymbol.keyFor(a) // undefined\r\nSymbol.keyFor(b) // desc b\r\n\r\na.toString() // Symbol(desc a)\r\nb.toString() // Symbol(desc b)\r\n```\r\n通过上述对比，个人感觉用`Symbol.for()`来生成`Symbol`好像更加合适\r\n\r\n不仅可以避免使用不必要的变量污染作用域，并且能更方便的获得其描述\r\n\r\n## Symbol的用途\r\n借助`Symbol`来实现单例模式\r\n```js\r\nconst Instance = Symbol.for('instance')\r\nfunction singleton() {\r\n\tif (singleton[Instance]) {\r\n\t\treturn singleton[Instance]\r\n\t}\r\n\t\r\n\treturn singleton[Instance] = {}\r\n}\r\nconst a = singleton()\r\nconst b = singleton()\r\na === b // true\r\n```\r\n\r\n如果将上例中的Symbol替换成任意一个不规则字符串（Magic String）对逻辑的实现并无影响\r\n\r\n所以从这个角度看来，Symbol的出现更多的是对代码或者说程序层面上的提升，而不是函数性的提升\r\n\r\n```js\r\nconst o = {\r\n\tfoo: 1,\r\n\t[Symbol.for('bar')]: 2\r\n}\r\nObject.getOwnPropertyNames(o) // ['foo']\r\nObject.getOwnPropertySymbols(o) // [Symbol(for)]\r\nObject.keys(o) // ['foo']\r\nfor (let key in o ){\r\n\tconsole.log(key) // 'foo'\r\n}\r\n```\r\n\r\n可以看到，虽然Symbol作为Object的属性key不会被当作普通的键值被获取\r\n\r\n但是还是有特殊途径来获得，所以并不能试图通过Symbol把Object的部分属性隐藏(作为外部不可访问的私有属性)\r\n\r\n## Built-in Symbols\r\n个人感觉ES6自身提供的Built-in Symbols会是最常见的`Symbol`使用方式，例如`Symbol.iterator`:\r\n```js\r\nconst arr = [1, 2, 3]\r\narr[Symbol.iterator] // native function\r\nconst it = arr[Symbol.iterator]() // 获得数组arr的Iterator\r\n```\r\n值得一提的是这些内部的Symbol并不是像我们自定义的那样注册到全局库中\r\n\r\n而是作为Symbol构造函数的静态属性对外提供\r\n\r\n"},"./src/blogs/WebpackBaseConfig.md":function(r,n){r.exports="# Webpack(v3.8.1)\r\n```\r\nconst path = require('path')\r\nconst webpack = require('webpack')\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\r\nconst pkg = require(path.join(__dirname, 'package.json'))// package.json\r\n\r\n// 定义项目中的一些文件夹路径\r\nconst APP_PATH = path.resolve(__dirname, 'src')\r\n\r\nlet theme = {}\r\n// pkg.theme存的是项目中antd主题文件的路径\r\n// 这里是 ./antd-theme.js\r\nif (pkg.theme && typeof(pkg.theme) === 'string') {\r\n  theme = require(path.resolve(__dirname, pkg.theme))\r\n}\r\n\r\nmodule.exports = {\r\n  entry: path.resolve(APP_PATH, 'index.jsx'),\r\n  // 暂时本地开发环境的不配output好像影响不大\r\n  // 后期遇到问题再配\r\n  resolve: {\r\n    // 配置这个后引用node_modules中的依赖包不用加路径 直接import xx from ('antd')即可\r\n    modules: [\r\n      'node_modules'\r\n    ],\r\n    //后缀 配了这个就可以在import时 import xx from (./test) 而不用 import xx from (./test.jsx)\r\n    extensions: ['.js', '.jsx', '.json', '.scss']\r\n  },\r\n  module: {\r\n    rules: [{\r\n      test: /\\.js|\\.jsx$/,\r\n      use: [\r\n        'babel-loader',\r\n        'eslint-loader'\r\n      ],\r\n      exclude: /node_modules/\r\n    }, {\r\n      test: /\\.css$/,\r\n      use: ['css-loader']\r\n    }, {\r\n      test: /\\.less$/,\r\n      use: [{\r\n        loader: 'style-loader'\r\n      },{\r\n        loader: 'css-loader'\r\n      },{\r\n        loader: 'less-loader',\r\n        options: {\r\n          sourceMap: true,\r\n          modifyVars: theme // 用于自定义antd主题 覆盖其less变量\r\n        }\r\n      }],\r\n      include: path.resolve(__dirname, 'node_modules')\r\n    }, {\r\n      test: /\\.scss$/,\r\n      use: [\r\n        'style-loader',\r\n        'css-loader',\r\n        'sass-loader'\r\n      ],\r\n      include: APP_PATH\r\n    }, {\r\n      // 字体文件之类的需要这个loader支持\r\n      test: /\\.(eot|woff|woff2|svg|ttf)([\\?]?.*)$/,\r\n      use: ['file-loader'],\r\n      include: APP_PATH\r\n    }, {\r\n      test: /\\.(jpe?g|png|gif|svg)$/,\r\n      use: [{\r\n        loader: 'url-loader',\r\n        options: {\r\n          limit: 8192// 小于1kb的图片采用base64编码 并以DATAUrl的形式嵌入页面\r\n        }\r\n      }],\r\n      include: APP_PATH\r\n    }]\r\n  },\r\n  devServer: {\r\n    contentBase: './build',\r\n    historyApiFallback: true,\r\n    hot: true,// 开启HMR\r\n    inline: true,\r\n    compress: true,// 开启gzip\r\n    port: 8080\r\n  },\r\n  plugins: [\r\n    new webpack.NamedModulesPlugin(),// 用于确保多次build生成的bundle名称不变\r\n    new HtmlWebpackPlugin({\r\n      template: 'index.html'// 以根目录下的index.html为模版\r\n    }),\r\n    new webpack.HotModuleReplacementPlugin()// HMR所需\r\n  ],\r\n  devtool: 'cheap-module-eval-source-map'\r\n}\r\n\r\n```\r\n生产环境\r\n```\r\nconst path = require('path')\r\nconst webpack = require('webpack')\r\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\r\nconst CleanWebpackPlugin = require('clean-webpack-plugin')\r\nconst ROOT_PATH = path.resolve(__dirname)\r\nconst APP_PATH = path.resolve(ROOT_PATH, 'src')\r\n\r\nconst pkg = require(path.join(__dirname, 'package.json'))// package.json\r\nlet theme = {}\r\n// pkg.theme存的是项目中antd主题文件的路径\r\n// 这里是 ./antd-theme.js\r\nif (pkg.theme && typeof(pkg.theme) === 'string') {\r\n  theme = require(path.resolve(__dirname, pkg.theme))\r\n}\r\n// 用于提取自己写的css\r\nconst appExtract = new ExtractTextPlugin({filename: 'app.[contenthash].css', allChunks: true})\r\n// 用于提取依赖包的css(主要是Antd)\r\nconst vendorExtract = new ExtractTextPlugin({filename: 'vendor.css', allChunks: true})\r\n\r\nmodule.exports = {\r\n  entry: {\r\n    app: path.resolve(APP_PATH, 'index.jsx'),\r\n    vendor: ['react', 'axios']\r\n  },\r\n  output: {\r\n    path: path.resolve(__dirname, 'build'),\r\n    publicPath: '/',\r\n    filename: '[name].[chunkhash].js',\r\n    chunkFilename: '[name].[chunkhash:5].chunk.js',\r\n  },\r\n  resolve: {\r\n    // 配置这个后引用node_modules中的依赖包不用加路径 直接import xx from ('antd')即可\r\n    modules: [\r\n      'node_modules'\r\n    ],\r\n    //后缀 配了这个就可以在import时 import xx from (./test) 而不用 import xx from (./test.jsx)\r\n    extensions: ['.js', '.jsx', '.json', '.scss']\r\n  },\r\n  plugins: [\r\n    new webpack.optimize.UglifyJsPlugin({\r\n      compress: {\r\n        warnings: false\r\n      }\r\n    }),\r\n    // 与NamedModulesPlugin 但更适用于生成环境\r\n    new webpack.HashedModuleIdsPlugin(),\r\n    // 部分依赖包(React)会在非生产环境中包含一些提示、警告的代码来帮助开发者解决问题\r\n    // 在生产环境通过配置这个可以阻止生成这些代码 减小bundle的size\r\n    new webpack.DefinePlugin({ 'process.env.NODE_ENV': JSON.stringify('production') }),\r\n    // 变动频率小的外部依赖包\r\n    new webpack.optimize.CommonsChunkPlugin({\r\n      name: 'vendor'\r\n    }),\r\n    // webpack的运行环境所需\r\n    new webpack.optimize.CommonsChunkPlugin({\r\n      name: 'runtime'\r\n    }),\r\n    new HtmlWebpackPlugin({\r\n      template: 'index.html'// 以根目录下的index.html为模版\r\n    }),\r\n    new CleanWebpackPlugin('build'),\r\n    appExtract,\r\n    vendorExtract,\r\n  ],\r\n  module: {\r\n    rules: [{\r\n      test: /\\.js|\\.jsx$/,\r\n      use: [\r\n        'babel-loader',\r\n        'eslint-loader'\r\n      ],\r\n      exclude: /node_modules/\r\n    }, {\r\n      test: /\\.css$/,\r\n      use: vendorExtract.extract(['css-loader'])\r\n    }, {\r\n      test: /\\.less$/,\r\n      use: vendorExtract.extract({\r\n        fallback: 'style-loader',\r\n        use: [{\r\n          loader: 'css-loader'\r\n        },{\r\n          loader: 'less-loader',\r\n          options: {\r\n            sourceMap: true,\r\n            modifyVars: theme // 用于自定义antd主题 覆盖其less变量\r\n          }\r\n        }]\r\n      }),\r\n      include: path.resolve(__dirname, 'node_modules')\r\n    }, {\r\n      test: /\\.scss$/,\r\n      use: appExtract.extract({\r\n        fallback: 'style-loader',\r\n        use: ['css-loader','sass-loader']\r\n      }),\r\n      include: APP_PATH\r\n    }, {\r\n      // 字体文件之类的需要这个loader支持\r\n      test: /\\.(eot|woff|woff2|svg|ttf)([\\?]?.*)$/,\r\n      use: ['file-loader'],\r\n      include: APP_PATH\r\n    }, {\r\n      test: /\\.(jpe?g|png|gif|svg)$/,\r\n      use: [{\r\n        loader: 'url-loader',\r\n        options: {\r\n          outputPath: 'images/',// 将图片放入build/images/目录下\r\n          limit: 8192// 小于1kb的图片采用base64编码 并以DATAUrl的形式嵌入页面\r\n        }\r\n      }],\r\n      include: APP_PATH\r\n    }]\r\n  }\r\n};\r\n\r\n```\r\n"},"./src/blogs/WebpackCommonProblem.md":function(r,n){r.exports="# 记录配置 Webpack 过程中碰到的问题以及解决方案\r\nPs: 基于 Webpack V4\r\n\r\n## Vue\r\n\r\n### 未配置 VueLoaderPlugin\r\n错误信息\r\n```\r\nERROR in ./src/component/App.vue\r\nModule Error (from ./node_modules/vue-loader/lib/index.js):\r\nvue-loader was used without the corresponding plugin.\r\nMake sure to include VueLoaderPlugin in your webpack config.\r\n```\r\n[参考文档](https://vue-loader.vuejs.org/guide/#manual-configuration)  \r\n解决方案\r\n```js\r\n// webpack.config.js\r\nconst VueLoaderPlugin = require('vue-loader/lib/plugin')\r\n\r\nmodule.exports = {\r\n\t// ...\r\n\tplugins: [\r\n\t\tnew VueLoaderPlugin() // 新增VueLoaderPlugin\r\n\t]\r\n\t// ...\r\n}\r\n```\r\n\r\n### 未安装 vue-template-compiler\r\n错误信息\r\n```\r\nERROR in ./src/component/App.vue\r\nModule build failed (from ./node_modules/vue-loader/lib/index.js):\r\nError: [vue-loader] vue-template-compiler must be installed as a peer dependency, \r\nor a compatible compiler implementation must be passed via options.\r\n```\r\n[参考文档](https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler#vue-template-compiler)  \r\n由于`vue-loader`内部实现需要依赖`vue-template-compiler`  \r\n但我们通过 npm 安装`vue-loader`时并未同时安装`vue-template-complier`  \r\n所以需要显示的在本地项目安装一下\r\n解决方案\r\n```\r\nnpm i vue-template-complier --save-dev\r\n```\r\n\r\n### 未安装配置css-loader\r\n错误信息\r\n```\r\nERROR in ./src/component/App.vue?vue&type=style&index=0&lang=css& \r\n(./node_modules/vue-loader/lib??vue-loader-options!./src/component/App.vue?vue&type=style&index=0&lang=css&) 24:0\r\nModule parse failed: Unexpected token (24:0)\r\nYou may need an appropriate loader to handle this file type.\r\n|\r\n|\r\n> .app {\r\n|       font-size: 24px;\r\n|       margin-top: 50%;\r\n```\r\n由于默认的`.vue`文件中`<style>`的lang属性值为`css`  \r\n所以`vue-loader`默认会将`<style>`块中的样式文件抽出作为 Css 文件提供给`webpack`加载  \r\n而不配置`css-loader`的话`webpack`是无法正确加载 Css 文件的\r\n解决方案\r\n```\r\nnpm i css-loader --save-dev\r\n```\r\n```js\r\n// webpack.config.js\r\nmodule.exports = {\r\n\t// ...\r\n\tmodule: {\r\n\t\trules: [{\r\n\t\t\ttest: /.css$/,\r\n\t\t\tuse: 'css-loader'\r\n\t\t}]\r\n\t}\r\n\t// ...\r\n}\r\n```\r\n凭以上配置虽然页面能正常访问，但会发现样式并不会生效\r\n```\r\nnpm i style-loader --save-dev\r\n```\r\n```js\r\n// webpack.config.js\r\nmodule.exports = {\r\n\t// ...\r\n\tmodule: {\r\n\t\trules: [{\r\n\t\t\ttest: /.css$/,\r\n\t\t\tuse: [\r\n\t\t\t\t'style-loader',\r\n\t\t\t\t'css-loader'\r\n\t\t\t]\r\n\t\t}]\r\n\t}\r\n\t// ...\r\n}\r\n```\r\n[Style Loader](https://webpack.js.org/loaders/style-loader/)  \r\n[Css Loader](https://webpack.js.org/loaders/css-loader/)  \r\nCss Loader 的作用是使我们可以在 Js 文件中通过 `import style from 'xxx.css'` 来告诉 webpack 这个文件对样式的依赖  \r\n这样当打包这个 Css 文件时也会将 xxx.css 算入其中  \r\n当这样并不能使样式文件被浏览器正确加载  \r\nStyle Loader 正是启到将依赖的样式文件通过在页面上插入 `<style>` 标签的形式注入到页面中  \r\n所以简单来讲 不做其他特殊配置的话 一定要同时使用这俩个 Loader 才能使得样式正确加载\r\n\r\n### 未正确配置项目所使用的 Vue 文件\r\n错误信息\r\n```\r\n// 页面报错\r\n[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. \r\nEither pre-compile the templates into render functions, or use the compiler-included build.\r\n```\r\n页面并未正常渲染，而是在 `HTML` 中出现了如下片段\r\n```html\r\n<html>\r\n<head>\r\n\t<title>Vue</title>\r\n</head>\r\n<body>\r\n\t\x3c!--function (a, b, c, d) { return createElement(vm, a, b, c, d, true); }--\x3e\r\n\t<script type=\"text/javascript\" src=\"main.js\"><\/script>\r\n</body>\r\n</html>\r\n```\r\n[参考文档](https://vuejs.org/v2/guide/installation.html#Explanation-of-Different-Builds)  \r\n这个问题出现主要是由于 Vue 对外提供了俩个版本的最终构造文件 Full(Runtime + Compiler) 以及 Runtime-only   \r\n俩者的区别就在于一个有 Compiler 另一个没有  \r\n此外，在 Vue 的 package.json 中可以看到 `\"module\": \"dist/vue.runtime.esm.js\"`  \r\n也就是说在使用 webpack 打包时 `import Vue from 'vue'` 默认使用的是 vue.runtime.esm.js 也就是 Rutime-only 的版本  \r\nCompiler 的主要作用在于将文件中的模版字符串转化为 render 函数（注意这里的文件不包括 .vue 文件 因为他们会被 vue-loader 自动预编译）  \r\n举例，在如下 Vue 应用的主入口文件中  \r\n```js\r\n// main.js\r\nimport Vue from 'vue'\r\n\r\n// 这种形式需要引用 Full(Runtime + Compiler)\r\nnew Vue({\r\n\tel: '#app',\r\n\ttemplate: '<div></div>'\r\n})\r\n\r\n// 引用 Runtime-only 即可\r\nnew Vue({\r\n\tel: '#app',\r\n\trendre(h) {\r\n\t\treturn h('div')\r\n\t}\r\n})\r\n```\r\n所以以上问题的解决方案有俩种  \r\n其一是如果我们确定不会在除 .vue 文件外使用 Vue 的 template  \r\n那么直接照常引入默认的 Runtime-only 版本即可  \r\n否则则需要我们显示的引入 Full(Runtime + Compiler) 版本  \r\n``` js\r\n// main.js\r\nimport Vue from 'vue/dist/vue.esm.js'\r\n```\r\n可以利用 webpack 的别名功能简化这个操作，也是官方推荐的方式\r\n```js\r\n// webpack.config.js\r\nmodule.exports = {\r\n\t// ...\r\n\tresolve: {\r\n\t\talias: {\r\n\t\t\t'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' for webpack 1\r\n\t\t\t// Ps: 最后的 $ 意味着完全匹配 也就是说只有在 import xx from 'vue' 时这条规则才会生效\r\n\t\t\t// import xx from 'vue/xx.js' 并不会触发以上规则\r\n\t\t}\r\n\t}\r\n\t// ...\r\n}\r\n```\r\n之后只要照常引用 `import Vue from 'vue'` 则会正确引入 Full(Runtime + Compiler) 版本\r\n\r\n### ES6 代码未正确经过Babel编译\r\n[参考文档](https://github.com/vuejs/babel-plugin-transform-vue-jsx)  \r\nPs: 基于 Babel V7  \r\n解决方案\r\n```\r\nnpm install\r\n  babel-plugin-syntax-jsx\r\n  babel-plugin-transform-vue-jsx\r\n  babel-helper-vue-jsx-merge-props\r\n  babel-preset-env\r\n  --save-dev\r\n```\r\n\r\n```js\r\n// babel.config.js\r\nmodule.exports = function (api) {\r\n\tapi.cache(true)\r\n\treturn {\r\n\t\tpresets: ['env'],\r\n\t\tplugins: ['transform-vue-jsx']\r\n\t}\r\n}\r\n\r\n// webpack.config.js\r\nmodule.exports = {\r\n\t// ...\r\n\tmodule: {\r\n\t\trules: [{\r\n\t\t\ttest: /.js$/,\r\n\t\t\tuse: 'babel-loader'\r\n\t\t}]\r\n\t}\r\n\t// ...\r\n}\r\n```\r\n\r\n### HMR未启用\r\n错误信息\r\n```\r\n// 如果在 devServer 中开启了 hot 确并未配置 HotModuleReplacementPlugin \r\n// 浏览器控制台会出现如下报错\r\nUncaught Error: [HMR] Hot Module Replacement is disabled.\r\n    at eval (webpack:///(:9000/webpack)/hot/dev-server.js?:7:8)\r\n    at Object../node_modules/webpack/hot/dev-server.js (main.js:485)\r\n    at __webpack_require__ (main.js:20)\r\n    at eval (webpack:///multi_(:9000/webpack)-dev-server/client?:2:1)\r\n    at Object.0 (main.js:578)\r\n    at __webpack_require__ (main.js:20)\r\n    at main.js:84\r\n    at main.js:87\r\n```\r\n\r\n[参考文档](https://webpack.js.org/guides/hot-module-replacement/)  \r\n解决方案\r\n```js\r\n// webpack.dev.config.js\r\nconst webpack = require('webpack')\r\n\r\nmodule.exports = {\r\n\t// ...\r\n\tdevServer: {\r\n\t\t// ...\r\n\t\thot: true\r\n\t},\r\n\tplugins: [\r\n\t\t// ...\r\n\t\tnew webpack.HotModuleReplacementPlugin()\r\n\t]\r\n\t// ...\r\n}\r\n```\r\n\r\n### CSS 中通过 `url(xxx)` 引入的的图片路径不正确\r\n当我们通过配置使得输出的静态文件放到不同目录下时很容易碰到这个问题  \r\n例如我们将打包后的文件分别放到js/css/images三个目录下  \r\n这时如果没有特意配置过的话被 `url-loader` 处理过后的图片引用路径通常会变为 `images/xxx.png`  \r\n如果是在根目录下的 HTML 中的文件下这样访问图片不会有问题  \r\n但如果是在 CSS 中的  `url(images/xxx.png)` 则会出现找不到图片的问题  \r\n因为这种形式的 URL 是一种相对路径  \r\n而 CSS 文件时放在 css 目录下的，而这个路径下并没有 images 文件夹  \r\n所以当然找不到正确的图片  \r\n这时可通过配置 `url-loader` 的 `publicPath` 为相对服务器根目录的相对路径来解决  \r\n关于 `publicPath` 有如下这些[配置方式](https://webpack.js.org/configuration/output/#output-publicpath)  \r\n```js\r\nmodule.exports = {\r\n\t//...\r\n\toutput: {\r\n\t\t// One of the below\r\n\t\tpublicPath: 'https://cdn.example.com/assets/', // CDN (always HTTPS)\r\n\t\tpublicPath: '//cdn.example.com/assets/', // CDN (same protocol)\r\n\t\tpublicPath: '/assets/', // server-relative\r\n\t\tpublicPath: 'assets/', // relative to HTML page\r\n\t\tpublicPath: '../assets/', // relative to HTML page\r\n\t\tpublicPath: '', // relative to HTML page (same directory)\r\n\t}\r\n}\r\n```\r\n\r\n## React\r\n\r\n\r\n## 优化\r\n\r\n### 关于 `optimization.moduleIds`\r\nWebpack V4 新引入的这条配置其功能相当于之前的 `xxxModuleIdsPlugin`  \r\n一共有 `natural/named/hashed/size/total-size` 这五个可选值  \r\n默认为 `false` 即以一个自增的数字作为 moduleId  \r\n首先要理解在 Webpack 中 module 的含义就是我们在代码里每一处 `import xx from 'xx'` 中的 xx 模块  \r\nmoduleId 即是 Webpack 在打包过程中赋予每一个模块的唯一 Id  \r\n个人认为在开发环境下将其设为 `named` 也就是每个模块的文件路径作为 Id 可以方便 Debug  \r\n在生产环境下将其设为 `hashed` 避免每次改动都导致所有模块的 Id 发生变化\r\n\r\n### 启用 Tree Shaking\r\nWebpack 提供了 Tree Shaking 的功能  \r\n帮助我们在打包的过程把无用的代码块移除，进一步减小包的体积  \r\n在V4中要正确启用这个功能需要确保下列这几点\r\n* 使用 ES6 的 `import` 以及 `export` 来管理 Module\r\n* `mode` 设为 `production`\r\n* 在 `package.json` 中加入 `\"sideEffects\": false` 或者 `\"sideEffects\": [\"*.css\"]` 避免不小心移除样式文件\r\n* 如果有使用 `@babel/preset-env` 注意在 .babelrc 中将其默认的配置 `\"modules\": \"commonjs\"` \r\n改为 `\"modules\": false` 也就是说不让 Babel 转义源码中的 ES6 Module 语法\r\n"},"./src/blogs/WebpackV3ToV4.md":function(r,n){r.exports="# Webpack V3 升级至 V4\r\n## 序\r\n半年没关注，最近突然发现Webpack的版本已经升到4.16.2了，为了紧跟潮流的步伐，决定将项目中使用的3.10.0来个升级\r\n\r\n## 步骤\r\n1. 安装`webpack`以及`webpack-cli` Ps: V4 开始将 CLI 抽离到了独立的 `webpack-cli` 项目中维护  \r\n所以现在需要分别安装俩个依赖\r\n2. 将项目中所有用到的`loader`以及`plugin`升级到最新\r\n3. 配置文件里新增 `mode: 'development'` or `mode: 'production'`\r\n4. 移除`webpack.optimize.UglifyJsPlugin`，现在webpack会在生产环境默认对js进行压缩\r\n5. 移除`extract-text-webpack-plugin`，v4推荐使用新的`mini-css-extract-plugin`来提取样式文件\r\n6. 引入`optimize-css-assets-webpack-plugin`以及`uglifyjs-webpack-plugin`，并在生产环境的配置文件下新增\r\n\r\n```js\r\nconst UglifyJsPlugin = require(\"uglifyjs-webpack-plugin\")\r\nconst OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\")\r\n\r\nmodule.exports = {\r\n\toptimization: {\r\n\t\tminimizer: [\r\n\t\t\t// 由于配置optimization会覆盖默认值 所以这里需要配一下UglifyJsPlugin\r\n\t\t\tnew UglifyJsPlugin({\r\n\t\t\t\tcache: true,\r\n\t\t\t\tparallel: true,\r\n\t\t\t}),\r\n\t\t\tnew OptimizeCSSAssetsPlugin({})\r\n\t\t]\r\n\t}\r\n}\r\n```\r\n7. 搞定\r\n\r\n## 总结\r\n升级过后打包和编译速度大概提升了15%左右（粗略比较）\r\n\r\n上述只是针对我之前项目配置的升级，并不完整，仅供参考\r\n\r\nWebpack官方有提供详细的迁移[文档](https://webpack.js.org/migrate/4/)\r\n\r\n遇到问题也可以通过报错信息很快定位到原因，再去相应的Github库上找一找解决办法，迁移过程还是比较顺利的\r\n"},"./src/blogs/XSS&CSRF.md":function(r,n){r.exports='# 关于 XSS 以及 CSRF\r\n\r\n## XSS (Cross-Site Scripting)\r\n\r\n### 攻击原理\r\n利用网站对用户输入的信任进行攻击  \r\n假设一个博客网站将用户的输入不经转义直接存入数据库，又原封不动的将数据库的内容插入页面中展示  \r\n这时候如果恶意用户在发布的一篇博文中加入了的一串脚本代码\r\n```html\r\n博客正文内容...\r\n<script>\r\n// 恶意脚本 窃取用户信息 跳转恶意网站 修改页面显示内容\r\n<\/script>\r\n```\r\n当其余用户浏览该篇博文时，由于未经过任何转义，恶意脚本和正文一起被插入页面的 DOM 节点中  \r\n脚本中的代码随即被浏览器加载执行，也就形成了一次 XSS 攻击\r\n\r\n### 防范方法\r\n不信任任何用户的输入，对所有用户输入进行转义后才存入数据库  \r\n所有用户输入的内容先进行转义再插入相应 DOM 节点  \r\nReact/Vue/Angular 等前端框架大多都默认进行了转义处理  \r\n例如在 React 中需要使用 `dangerouslySetInnerHTML={}` Vue 中需要使用 `v-html` 来插入未转义的内容  \r\n这些默认行为有时会使得开发者忽视掉防范 XSS 攻击，只要足够小心这类攻击其实可以被完全杜绝  \r\n此外，将 Cookie 设为 `HttpOnly` 可以阻止当进行 XSS 攻击的恶意脚本获取存储在 Cookie 中的敏感信息\r\n\r\n## CSRF (Cross-Site Request Forgery)\r\n\r\n### 攻击原理\r\n假设用户在登录了 `www.bank.com` 的同时打开了 `www.evil.com`  \r\n而攻击者恰好知道转账的接口为 `www.bank.com/transfer?to=AcountId&amount=99999`  \r\n这时候攻击者在 `www.evil.com` 的页面上隐藏了一个 `<img src="www.bank.com/transfer?to=AcountId&amount=99999">`  \r\n如果银行网站恰好仅仅简单的利用 Cookie 进行用户校验（当然大部分情况下银行网站不会这么傻）  \r\n由于 `<img>` 可以绕开 Same-Origin Policy 的限制  \r\n所以这个 GET 请求会正确发送并且携带上用户登录信息的相关 Cookie ，成功将钱转到了攻击者的账号  \r\n\r\n### 防范方法\r\n* 合理的设计 API ，GET 请求不应该进行带有 Side Effect 的操作\r\n* 利用 CSRF-Token 在每次请求时需要携带 Token 来校验权限\r\n* 在进行与钱相关的危险操作时需要再次输入密码（像支付宝、银行等应用的密码就会分为登录密码和付款密码）\r\n'},"./src/components/Blog/index.jsx":function(r,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var e=function(){function r(r,n){for(var t=0;t<n.length;t++){var e=n[t];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(r,e.key,e)}}return function(n,t,e){return t&&r(n.prototype,t),e&&r(n,e),n}}(),o=C(t("./node_modules/react/index.js")),s=C(t("./src/components/Markdown/index.jsx")),a=C(t("./src/blogs/WebpackBaseConfig.md")),c=C(t("./src/blogs/GulpPlugin.md")),i=C(t("./src/blogs/Symbol.md")),l=C(t("./src/blogs/Iterator.md")),u=C(t("./src/blogs/WebpackV3ToV4.md")),d=C(t("./src/blogs/Generator.md")),p=C(t("./src/blogs/ArrayAPI.md")),m=C(t("./src/blogs/ObjectAPI.md")),b=C(t("./src/blogs/Collections.md")),f=C(t("./src/blogs/Promise.md")),g=C(t("./src/blogs/PreventModalScroll.md")),h=C(t("./src/blogs/Redux.md")),y=C(t("./src/blogs/ReactRedux.md")),x=C(t("./src/blogs/BinaryTreeTraversal.md")),S=C(t("./src/blogs/SourceMapAndWebpack.md")),j=C(t("./src/blogs/WebpackCommonProblem.md")),w=C(t("./src/blogs/CrossOrigin.md")),v=C(t("./src/blogs/Npm.md")),k=C(t("./src/blogs/CookieAndWebStorage.md")),P=C(t("./src/blogs/XSS&CSRF.md"));function C(r){return r&&r.__esModule?r:{default:r}}t("./src/components/Blog/style.less");var R=[a.default,c.default,i.default,l.default,u.default,d.default,p.default,m.default,b.default,f.default,g.default,h.default,y.default,x.default,S.default,j.default,w.default,v.default,k.default,P.default],A=function(r){function n(){return function(r,n){if(!(r instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),function(r,n){if(!r)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?r:n}(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(r,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);r.prototype=Object.create(n&&n.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(r,n):r.__proto__=n)}(n,o.default.Component),e(n,[{key:"render",value:function(){return o.default.createElement("div",{className:"blogs"},R.map(function(r,n){return o.default.createElement("div",{className:"blog",key:n},o.default.createElement(s.default,{data:r}))}))}}]),n}();n.default=A},"./src/components/Blog/style.less":function(r,n,t){},"./src/components/Markdown/index.jsx":function(r,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var e=l(t("./node_modules/react/index.js")),o=l(t("./node_modules/marked/lib/marked.js")),s=l(t("./node_modules/highlight.js/lib/highlight.js")),a=l(t("./node_modules/highlight.js/lib/languages/javascript.js")),c=l(t("./node_modules/highlight.js/lib/languages/css.js")),i=l(t("./node_modules/highlight.js/lib/languages/xml.js"));function l(r){return r&&r.__esModule?r:{default:r}}t("./node_modules/highlight.js/styles/github.css"),t("./src/components/Markdown/style.less"),s.default.registerLanguage("javascript",a.default),s.default.registerLanguage("css",c.default),s.default.registerLanguage("xml",i.default),o.default.setOptions({highlight:function(r){return s.default.highlightAuto(r).value}}),n.default=function(r){return e.default.createElement("div",{className:"my-md",dangerouslySetInnerHTML:{__html:(0,o.default)(r.data)}})}},"./src/components/Markdown/style.less":function(r,n,t){}}]);