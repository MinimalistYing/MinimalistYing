(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{"./src/blogs/Ajax.md":function(n,e){n.exports="# Ajax (Asynchronous JavaScript And XML)\n\n## Ajax 是什么？\n在 Web 发展之初，客户端与服务端通常仅通过 `<form>` 表单进行数据交互  \n当表单被提交时页面会进行刷新，服务器端可能会根据提交的数据返回不同的 HTML  \n随着 Web Application 的功能愈加复杂，每次交互都需要刷新页面显然对用户来说体验很糟糕  \n这个时候 Ajax 出现了(2005 年左右开始渐渐被广为使用)，Ajax 在不刷新页面的情况下通过 HTTP 请求与服务器异步的交换数据 \n在浏览器中主要通过下面介绍的 `XMLHttpRequest` 对象来发起 Ajax 请求  \n(Ps: 名称中的 XML 其实很有误导性，只是因为该技术诞生之初时 XML 很火爆  \n大家可能本来认为 XML 会发展成为通用的数据交换格式，没想到现在 JSON 异军突起成为最流行的轻量格式，由此亦可见科技进步之快)\n\n## XMLHttpRequest API\n由于该 API 是依据 HTTP 协议设计的，所以我们首先要来了解一下关于 HTTP 请求及响应的几个组成部分  \n请求：\n* HTTP Method (Ps: GET/POST/DELETE...)\n* Request URL\n* Request Header\n* Request Body\n\n响应：\n* Response Status (Ps: 200 OK/404 Not Found)\n* Response Header\n* Response Body\n\n下例阐述了一个完整的 Ajax 流程，可以看出相应的 API 都是在获取或修改上述的几个值\n```js\n// 1. 实例化对象\nconst request = new XMLHttpRequest()\n\n// 2. 确定请求的 Method 以及 URL\n// 默认为异步请求 可以将第三个参数设为 false 来发起同步请求（不建议 同步请求会导致浏览器阻塞）\n// URL 支持相对路径 默认为相对当前 HTML 的 URL 可以通过 <base> 标签进行修改\n// 第四、五个参数可以分别为 username、password 这样会使得发起请求的 URL 变为\n// http://username:password@www.xx.com/api 用于进行用户鉴权（到目前为止还未碰到过这种形式 感觉应该用不到）\nrequest.open('POST', 'http://www.xx.com/api', true)\n\n// 3. 设置 Request Header\n// 类似 Cookie Content-Length User-Agent Date 等请求头是由浏览器自己设置的\n// 如果试图通过该方法设置这些请求头 浏览器会报错 Refused to set unsafe header \"XXX\"\n// 重复设置相同的 Request Header 并不会修改原先的值 而是在原有的值上新增\n// 例如 request.setRequestHeader('a', '1') request.setRequestHeader('a', '2')\n// 则请求头会包含 a: 1, 2\nrequest.setRequestHeader('Content-Type', 'application/json')\n\n// 4. 设置监听事件的回调函数\n// readyState 共有五个可能值\n// XMLHttpRequest.UNSENT 0 请求还未 open()\n// XMLHttpRequest.OPEND 1 请求已经 open()\n// XMLHttpRequest.HEADERS_RECEIVED 2 收到响应头\n// XMLHttpRequest.LOADING 3 收到响应体\n// XMLHttpRequest.DONE 4 请求完成\n// 理论上来说最合适的方式是通过 request.readyState === XMLHttpRequest.DONE 来判断请求是否完成\n// 但是由于 IE8 并不兼容 所以大多是情况下我们会通过 request.readyState === 4 来判断\nrequest.onreadystatechange = () => {\n\tif (request.readyState === 4) { // 响应已收到\n\t\tif (request.status === 200) {\n\t\t\t// 请求正确\n\t\t\t// 还可以通过 request.getAllResponseHeaders() 获取所有响应头\n\t\t\t// 不过该方法返回的是包含所有响应头的字符串 需要转化才能获得键值对\n\t\t\tconst type = request.getResponseHeader('Content-Type')\n\t\t\tif (type === 'text/plain') {\n\t\t\t\treturn request.reponseText\n\t\t\t} else if (type === 'application/json') {\n\t\t\t\treturn JSON.parse(request.response)\n\t\t\t} else if (type === 'application/xml') {\n\t\t\t\t// 应该用不到 暂时未碰到过以 XML 来作为数据交换格式\n\t\t\t\treturn request.reponseXML\n\t\t\t}\n\t\t} else {\n\t\t\t// 请求错误\n\t\t}\n\t}\n}\n\n// 5. 设置 Request Body 并正式发送请求\n// 请求体中的数据格式需要与请求头 Content-Type 中的一致\n// 该例中我们采用 JSON 作为数据交换格式 所以这里需要将对象讲过 JSON.stringify() 处理\n// 如果不需要传递 Request Body 可以 request.send(null)\nrequest.send(JSON.stringify(data))\n```\n除上述简单的请求响应过程外，XHR 还提供了更多的监听事件\n```js\n// 在主动调用 request.abort() 或者其余方式导致请求被丢弃的情况下触发\nrequest.onabort = () => {}\n// 当请求时长超过了 request.timeout 设置的时长时触发\nrequest.ontimeout = () => {}\n// 当发生 NetWork Error（Ps: 类似 DNS 解析错误/CORS 跨域失败）时触发\nrequest.onerror = () => {}\n// 请求完成时触发（Ps: 不考虑兼容性的情况下可以用这个取代监听 readystatechange ?）\nrequest.onload = () => {}\n\n// 规范要求一个请求在完成时必定且只能触发上述事件中的一个\n```\n\n当发起一个跨域请求并且希望其携带 Cookie 时，需要额外进行如下设置\n```js\nrequest.withCredentials = true\n```\n\n每个 `XMLHttpRequest` 的实例化对象代表了一对 request/reponse ，如果反复利用同一个对象会导致先前的请求被 `abort`  \n由于 HTTP 协议对一个请求有着（方法 / URL => 请求头 => 请求体）的先后顺序要求  \n`XMLHttpRequest` API 的调用顺序也有着相同顺序 open() => setRequestHeader() => send()  \n例如在 `open()` 之前调用 `setRequestHeader()` 会导致浏览器报错\n```\nUncaught DOMException: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n```\n\n当我们想利用 XHR 来上传文件时情况会更加复杂一点  \n首先要提的是早期的 XHR 并不支持文件上传，只能利用 `<form>` 表单加 `<input type=\"file\">` 来实现  \nIE10+ 才开始支持通过 XHR2 以及 `FromData` 来实现文件上传\n```js\nconst data = new FromData()\nconst dom = document.querySelector('input[type=\"file\"]')\ndata.append('filename', dom.files[0].name)\ndata.append('file', dom.files[0])\n\n// 监听上传进度\n// 同理 下载时可以直接通过 request.onprogress 来监听进度\nrequest.upload.onprogress = e => {\n\tif (e.lengthComputable) { // 如果支持统计内容长度\n\t\tconsole.log(`进度${e.loaded/e.total}`)\n\t}\n}\n// 上传完成\nrequest.upload.onload = () => {}\n// 利用 FormData 上传数据时 Content-Type 会被默认设为 multipart/form-data\nrequest.send(data)\n```\n\n## 总结\n通过上面这些例子不难看出 XMLHttpRequest 的 API 受时代所拖累，设计的并不完美  \n开发者使用起来显然也很麻烦，所以才出现了 jQuery 中的 `$.ajax()` 以及时下比较流行的 `axios` 等框架对其的封装  \n除开这些框架外更令人期待的是浏览器原生支持的 Fetch API  \n虽然目前的兼容性堪忧但是 Fetch 作为 *A modern replacement for XMLHttpRequest.*  \n相信在不久的将来会给我们带来更多方便\n"},"./src/blogs/ArrayAPI.md":function(n,e){n.exports="# Array's New API In ES6\n## Static Function\n\n### Array.of()\n大部分情况下我们都应该优先使用字面量的形式 `const a = [1, 2]` 来创建一个数组  \n但当我们定义了一个自己的 Array 子类，并且想要创建子类的数组时就只能通过构造器来实例化了\n```js\nclass MyArr extends Array {\n\tmax() {\n\t\tlet max = this[0]\n\t\tthis.map(item => {\n\t\t\tmax = Math.max(item, max)\n\t\t})\n\t\treturn max\n\t}\n}\n\nconst a = new MyArr(1, 2, 3)\na.max() // 3\n```\n一般情况下上例做法也不会有问题，但是当只传入一个参数时就会产生 empty slots（可能是因为历史原因？）\n```js\nconst b = new MyArr(3) // 通过这种方式生成的不是 [3] 而是 [empty * 3]\nb.length // 3\nb.max() // undefined\n```\n使用 `Array.of()` 来实例化新数组可以避免上述问题\n```js\nconst c = MyArr.of(3) // [3]\nc.length // 1\nc.max() // 3\n```\n\n### Array.from()\n`Array.from` 可用于数组的转化，假设我们有一个 Array-Like Object\n```js\nconst o = {\n\tlength: 2,\n\t0: 'hello',\n\t1: 'world'\n}\n\nconst a = Array.from(o)\nconst b = Array.prototype.slice.call(o) // 以往的方式\n```\n可以看到，在 ES6 中我们可以很方便的将其转化为一个真正的数组，并且不用担心会产生 empty slots\n```js\nconst o = {\n\tlength: 2,\n\t0: 'hello'\n}\n\nconst a = Array.from(o) // [\"hello\", undefined]\nconst b = Array.prototype.slice.call(o) // [\"hello\", empty]\n```\n该方法的第一个参数可以是任意 Iterable 的对象，并将其迭代产生的值依次放到一个数组中返回\n```js\n// 可用于复制数组\nconst arr = [1, 2, 3]\nconst arrCopy = Array.from(arr) // 更简洁 更易理解\nconst arrCopy2 = arr.slice() // 以往的方式\n```\n该方法的第二个参数可以接受一个函数，并依次对每一个值通过函数处理后再放到结果数组中\n```js\nconst arr = [1, 2, 3]\nconst arrCopy = Array.from(arr, item => item + 1) // [2, 3, 4]\n```\n\n## Prototype Method\n\n### copyWithin(target, start, end)\n该方法可以将数组的一部分复制到该数组特定位置，并覆盖原值  \n会直接修改原数组而不是产生一个新数组\n```js\nlet arr = [1, 2, 3, 4, 5]\n// 可以看到不明确提供 start 和 end 参数时该方法会从下标0处开始尽可能的拷贝更多的值\narr.copyWithin(1) // [1, 1, 2, 3, 4]\n\narr = [1, 2, 3, 4, 5]\narr.copyWithin(1, 0) // [1, 1, 2, 3, 4]\n\narr = [1, 2, 3, 4, 5]\narr.copyWithin(1, 0, 0)  // [1, 2, 3, 4, 5]\n\narr = [1, 2, 3, 4, 5]\narr.copyWithin(1, 0, 1)  // [1, 1, 3, 4, 5]\n\narr = [1, 2, 3, 4, 5]\n// 拷贝过程并不是严格的按照从左到右一个个执行的\n// 若果严格按照顺序执行的话，程序的结果应该是[1, 2, 2, 2, 2]\n// 可以假定执行过程如下\n// [1, 2, 2, 4, 5]\n// [1, 2, 2, 2, 5]\n// [1, 2, 2, 2, 2]\narr.copyWithin(2, 1) // [1, 2, 2, 3, 4]\n```\n### fill(value, start, end)\n该方法可以向数组中的指定位置填充值\n```js\n// 未明确指定start和end时会尽可能的填充更多的值\nnew Array(3).fill('hello') // ['hello', 'hello', 'hello']\n[null, null, null].fill('hello', 1) // [null, 'hello', 'hello']\n[null, null, null].fill('hello', 1, 2) // [null, 'hello', null]\n```\n\n### find()\n以往我们想要判断数组中是否包含某个元素通常是借助 `indexOf()`\n```js\nconst arr = [1, '2', {name: 'hello'}]\narr.indexOf(1) !== -1 // true\narr.indexOf('2') !== -1 // true\narr.indexOf(2) !== -1 // false\n```\n这种方法有几个缺点:\n* 通过严格的===来比较\n* 需要通过判断是否等于-1来得出我们要的布尔值结果\n* 不能实现自定义的匹配条件\n\nES5 中新增的 `some()` 解决了上述问题\nPS: 当我们不需要自定义匹配条件，想利用全等来比较时  \n可以采用ES7新增的更便捷的方法 `Array.prototype.includes()`\n```js\nconst arr = [1, '2', {name: 'hello'}]\narr.some(v => v == 2) // true\narr.some(v => v.name === 'hello') // true\n\narr.includes(1) // true\n```\n大部分情况下这种方法都没有问题，但当我们想要直接获得正确匹配到的值  \n这时候就可以借助ES6的 `find()`\n```js\nconst arr = [1, '2', {name: 'hello'}]\narr.find(v => v == 2) // '2'\narr.find(v => v,name === 'hello') // {name: 'hello'}\narr.find(v => v === 666) // undefined\n```\n\n### findIndex()\n总结一下上述数组的查找方法，可以发现，当我们只想确定是否存在特定值时可以采用`some()`  \n当我们想拿到符合比较条件的值时可以采用 `find()`  \n如果我们想要拿到符合比较条件值的下标时就需要用到ES6的 `findIndex()`\n```js\nconst arr = [1, '2', {name: 'hello'}]\narr.findIndex(v => v == 2) // 1\narr.findIndex(v => v,name === 'hello') // 2\narr.findIndex(v => v === 666) // -1\n```\n不难发现该方法和 `indexOf()` 的差别仅在于可以自定义匹配条件\n\n### entries() values() keys()\n类似`Map` `Set`等ES6新增的 Collections，Array也提供了一系列的借助 Iterator 的迭代方法\n```js\nconst arr = [1, 2, 3]\n[...arr.values()] // [1, 2, 3]\n[...arr.entries()] // [[0, 1], [1, 2], [2, 3]]\n[...arr.keys()] // [0, 1, 2]\n```\n"},"./src/blogs/ArraySort.md":function(n,e){n.exports="# Array.prototype.sort() 在使用默认CompareFn时的问题\n\n## 起因\n在LeetCode上碰到一道算法题，需要先将数组中的数字从小到大进行排序  \n自信的直接通过`Array.prototype.sort()`进行排序，结果却让人费解  \n```js\nlet arr = [1, -2, 2, 34, 3]\narr.sort() // => [-2, 1, 2, 3, 34]\n// 暂时来看默认的排序算法是正确的 下面我们换一下数组内部的值\narr = [1, -1, 23, 2, 3]\narr.sort() // => [-1, 1, 2, 23, 3]\n// 可以看到结果并未正确的按从小到大的顺序排列\n```\n\n## Why\n查阅ECMA规范中的[sortcompare](http://www.ecma-international.org/ecma-262/6.0/#sec-sortcompare)  \n默认的比较函数会将数组中的值(除了`undefined`,因为它不能被转为字符串)先转为字符串后再进行排序  \n并且`undefined`会被视为最大的值，所以\n```js\nlet arr = [1, undefined, 23, 2, 3]\n// 因为 '3' > '23' > '2' > '1' \narr.sort() // => [1, 2, 23, 3, undefined]\n```\n\n## 延伸\n再查找相关资料的时候翻到了[这篇文章](https://segmentfault.com/a/1190000010630780)  \n里面又抛出了一个新问题\n```js\nconst data = [\n\t{value: 3}, \n\t{value: 2}, \n\t{value: undefined}, \n\t{value: 1}, \n\t{value: undefined}, \n\t{value: 4}\n]\n// => [1, 2, 3, 4, undefined, undefined]\ndata.map(x => x.value).sort((x, y) => x - y)\n// => [2, 3, undefined, 1, undefined, 4]\ndata.sort((x, y) => x.value - y.value).map(x => x.value)\n```\n可以看到先排序再扁平化和先扁平化再排序产出的结果是不一致的，虽然比较大小的逻辑相同  \n产生这个问题的原因就是因为值中出现了`undefined`而它和任何其它数字进行加减乘除操作得到的结果是`NaN`  \n而ECMA规范中规定的CompareFn必须返回的是一个数字(最好是1,-1,0)  \n对于给定的`compare(a,b)`希望a排前返回负数，希望b排前返回正数，希望顺序不变返回0  \n\n## 总结\n为了避免诸多问题，建议在使用`Array.prototype.sort()`时始终传入CompareFn  \n并考虑清楚对比值中可能出现的特殊情况(例如`undefined`/`null`等)\n"},"./src/blogs/Axios.md":function(n,e){n.exports="# Axios 源码解析\nAxios 是一个发送 Ajax 请求的类库  \n类似于 jQuery `$.ajax()` 以及 Angular `$http`   \n本文会针对其提供的特性对部分核心代码进行分析\n\n## Feature\n首先罗列一下 Axios 在对 `xhr` 进行封装的基础上提供的一些高级特性\n* `Promise` API\n* 支持通过 `Interceptor` 在请求前后进行一些公共业务操作（例如对错误的处理）\n* 支持通过 `transformData` 对请求参数以及响应结果做统一处理\n* 支持通过 `axios.defaults` 进行全局的默认配置\n* 支持通过 `axios.get() | axios.put()` 以及类似 Fetch API `axios(url, config)` 的调用形式\n* 支持统一设置请求的 `BaseURL`\n\n## Axios 如何支持多种调用形式\n```js\n// lib/axios.js\n// ...\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  // 使函数 \b`Axios.prototype.request` 内部的 this 指向上面通过构造函数实例化的 context 对象\n  // 注意这里的 instance 其实仍是一个函数\n  // 之所以这样做是为了可以像 axios(url, config) 这样直接调用\n  var instance = bind(Axios.prototype.request, context);\n\n  // 将 Axios.prototype 上定义的函数的 this 指向 context 并复制到 instance 上\n  // 这样就可以像 axios.get() axios.post() 一样来调用\n  utils.extend(instance, Axios.prototype, context);\n\n  // 将 context 的属性复制到 instance 函数上\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// 默认情况下 我们通过 import axios from 'axios' 引入的就是该对象\n// 更准确的说就是 createInstance 函数返回的 instance 函数\n// 也就是重新 bind 过 this 后的 Axios.prototype.request\nvar axios = createInstance(defaults);\n\n// ...\n```\n在 axios 中，不管我们采取何种形式调用，最终发起请求的都是 `Axios.prototype.request` \n```js\n// lib/core/Axios.js\n// ...\nAxios.prototype.request = function request(config) {\n  // 支持像 Fetch API 一样调用 axios(url, config)\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n  // ...\n};\n\n// 支持通过 axios.get() axios.post() 等方式快捷调用\n// delete get head options 默认不会在请求体中携带数据\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n// post put patch 可以在请求体中携带数据\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n```\n\n## Axios 如何支持统一设置请求的 BaseURL\n```js\n// lib/core/dispatchRequest.js\n// ...\nmodule.exports = function dispatchRequest(config) {\n  // ...\n\n  // 如果\b设置有 baseURL 并且传入的请求地址是相对路径  \n  // 则用 baseURL 与传入的地址拼接后作为最终的请求路径\n  // 通过 /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url) 来判断是否为绝对路径\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    // axios 会移除 BaseURL 末尾的 / 以及相对路径开头的 / 来进行拼接\n    // 所以 axios('/xxx') 和 axios('xxx') 其实是一样的\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // ...\n};\n```\n\n## Axios 如何支持 Promise\n```js\n// lib/adapters/xhr.js\n// ...\nmodule.exports = function xhrAdapter(config) {\n  // 比较简单 就是用 Promise 对 xhr 原生 API 做了一层封装\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var request = new XMLHttpRequest();\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    request.onreadystatechange = function handleLoad() {\n      // ...\n      // 请求完成后 resolve 或者 reject Promise\n      settle(resolve, reject, response);\n      // ...\n    };\n\n    // 发送请求\n    request.send(requestData);\n  });\n};\n```\n\n## Axios 如何支持 Interceptor\n```js\n// lib/core/Axios.js\n// ...\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  // 每个 Axios 的实例都包含了俩类拦截器 \n  // this.interceptors.request 以及 this.interceptors.response\n  // InterceptorManager 用于管理所有的拦截器 也就是维护一个数组\n  // 数组中的元素是一个类似 { fulfill: ()=>{}, reject: () => {}} 的对象\n  // 包含 Promise 处理成功函数以及失败函数\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\nAxios.prototype.request = function request(config) {\n  // ...\n  // 最终请求是在 dispatchRequest 中 通过 Adapter 发送的\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  // 将拦截函数放入调用链\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  // 此时的 chain 是一个包含了 Promise resolve reject 函数的数组\n  // 形如 [reqFulfill, reqReject, dispatchRequest, undefined. resFulfill, resReject]\n  // 以下代码其实就是为了形成一个链式的流程 类似\n  // Promise(config).then(reqFulfill, reqReject)\n  // .then(dispatch, undefined)\n  // .then(resFulfill, resReject)\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n```\n\n## Axios 如何支持 transformData\n```js\n// lib/core/dispatchRequest.js\n// ...\nmodule.exports = function dispatchRequest(config) {\n  // ...\n  // 请求发出前 transform request data\n  config.data = transformData(...);\n\n  // ...\n  // 请求完成后 transform response data\n  return adapter(config).then(function onAdapterResolution(response) {\n    // 请求成功 也就是 validateStatus 返回 true 默认响应码 200 - 300 为 true\n    response.data = transformData(...);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    // 请求失败\n    if (reason && reason.response) {\n      reason.response.data = transformData(...);\n    }\n\n    return Promise.reject(reason);\n  });\n};\n```\n\n## Axios 的默认设置\n```js\n// lib/defaults.js\n// ...\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nvar defaults = {\n  // 默认会根据请求参数的类型来适配请头中的 Content-Type\n  // 并且转化发起请求的数据格式\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) { // 对象转为 json 字符串\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n  // 默认如果请求返回的数据是字符串则转为 json\n  transformResponse: [function transformResponse(data) {\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n  // 默认响应码在 200 - 300 间才认为请求成功\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n// 默认接收 json 数据\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\n// post put patch 请求默认的 Content-Type 为 application/x-www-form-urlencoded\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n```\n\n## Axios 发起一个请求的流程\n1. `axios(config) | axios(url, config) | axios.get(url, config)` 启动一个请求\n2. 内部最终通过 `Axios.prototype.request(config)` 函数来启动请求\n3. 经过 Request Inteceptors 处理配置 / 请求头等\n4. 在 `dispatchRequest(config)` 中通过 `config.data = transformRequest(...)` 处理请求参数\n6. 在 `xhrAdapter` 中实例化 `XMLHttpRequest` 对象 发送 Ajax 请求\n7. 收到响应后 不管请求成功还是失败，通过 `response.data = transformResponse(...)` 处理请求返回数据\n8. 经过 Response Inteceptors 处理错误 / 响应头等\n9. 请求完成 `axios(config).then(res => {}).catch(err => {})` 在 `then` 或 `catch` 块中处理业务逻辑"},"./src/blogs/BinaryTreeTraversal.md":function(n,e){n.exports="# 二叉树的遍历\n所谓树的遍历即是按特定的顺序访问树中所有的节点  \n以下面这颗二叉树为例，我们来研究一下最常见的三种二叉树遍历方式  \n\n           1\n         /   \\\n        3     2\n       / \\     \\  \n      5   7     9 \n\n\n## 前序遍历 NLR\n根->左子树->右子树  \n访问节点值的操作在继续遍历左子树和右子树之前进行，所以叫前序  \n上例中的二叉树前序遍历结果 `135729`\n\n## 中序遍历 LNR\n左子树->根->右子树  \n访问节点值的操作在遍历左子树之后遍历右子树之前进行，所以叫中序  \n上例中的二叉树中序遍历结果 `537129`\n\n## 后续遍历 LRN\n左子树->右子树->根  \n访问节点值的操作在遍历左子树和右子树之后进行，所以叫后序  \n上例中的二叉树后序遍历结果 `573921`\n\n## 代码实现\n```js\nfunction traverse(node) {\n\tconsole.log(node.value) // 前序\n\t\n\tif (node.left) {\n\t\ttraverse(node.left)\n\t}\n\t\n\tconsole.log(node.value) // 中序\n\t\n\tif (node.right) {\n\t\ttraverse(node.right)\n\t}\n\t\n\tconsole.log(node.value) // 后序\n}\n```\n\n## 总结\n其实类似上述的遍历方式应该一共有6种，包括NLR/NRL/LNR/RNL/LRN/RLN  \n但由于其中存在俩俩对称  \n所以通常只说先遍历左子树的前/中/后序遍历(NLR/LNR/LRN)这三种遍历方式  \n从代码实现中不难看出，对于这三种方式我们对树节点的递归过程是一致的  \n区别仅在于我们在递归中何时去访问具体的节点值  \n所以这三种遍历方式中的前/中/后其实指的正是我们是在遍历之前、之中还是之后去访问具体的节点值\n"},"./src/blogs/BinaryTreeType.md":function(n,e){n.exports="# 常见的二叉树类型\n\n## 满二叉树\n除最后一层的节点外每个节点都有俩个子节点\n```\n           1\n         /   \\\n        3     2\n       / \\   / \\ \n      5   7 8   9 \n```\n\n## 完全二叉树\n除最后一层外每层节点全满，且最后一层节点全部靠左排列  \n满二叉树一定是完全二叉树\n```\n           1\n         /   \\\n        3     2\n       / \\   / \n      5   7 8 \n```\n\n## 平衡二叉树 （AVL Tree）\n空树或者左右子树高度最多相差一层且左右子树都为平衡二叉树\n```\n           1\n         /   \\\n        3     2\n       / \\   \n      5   7 \n```\n"},"./src/blogs/Collections.md":function(n,e){n.exports="# New Collections In ES6\n\n## Map\n以往当我们需要一种键/值对形式的数据结构时通常使用的是原生的 Object\n```js\nconst o = {}\no[1] = 1\no['a'] = 'a'\nconsole.log(o) // { 1: 1, a: 'a'}\no['1'] = 2\nconsole.log(o) // {1: 2, a: 'a'}\n\nconst map = {}\nconst x = { a: 1 }\nconst y = { b: 2 }\nmap[x] = 1\nmap[y] = 2\n// 因为x.toString() === '[object Object]'\nconsole.log(map) // {[object Object]: 2}\n```\n可以看到这种方法有一个缺陷，由于 Object 的 Key 只能是字符串  \n这样生成的 Map 同样只能以字符串作为键  \nES6 提供了对 Map 的原生支持，它可以将任何数据类型作为 Key\n```js\nconst map = new Map()\nconst x = { a: 1 }\n// 支持链式调用\nmap.set(x, 1).set(2, 2).set('2', '2string')\n\t.set(Symbol.for('sym'), 'symbol').set(true, true)\n\nmap.get(x) // 1\nmap.get(2) // 2\nmap.get('2') // 2string\nmap.get(Symbol.for('sym')) // 'symbol'\nmap.get(true) // true\n\nmap.size // 5\n\nmap.delete(true)\nmap.delete(x)\nmap.delete('2')\n\nmap.size // 2\n\nmap.has(2) // true\nmap.has(Symbol.for('sym')) // true\n\n[...map.keys()] // [2, Symbol(sym)]\n[...map.values()] // [2, \"symbol\"]\n[...map.entries()] // [[2, 2], [Symbol(sym), \"symbol\"]]\n\nmap.clear()\nmap.size // 0\n```\nMap 的实例是 Iterable 的，并且其默认的 Iterator 与 `map.entries()` 返回的结果一致  \n所以以下方法都可以用于拷贝产生一个新的 Map\n```js\nconst map = new Map()\nconst copy2 = new Map(map.entries())\nconst copy1 = new Map(map) // 推荐 更简洁\n```\n\n## WeakMap\nWeakMap 的大部分行为与 Map 一致，主要区别在于 WeakMap 对内存分配机制的特殊处理  \nWeakMap 的 Key 只能是 Object ，并且当作为 Key 的 Object 被 GC 回收后  \n其存储在 WeakMap 中的 Entry 也会随之被销毁  \nWeakMap 相较 Map 而言只提供了 `set()` `get()` `delete()` `has()` 四个有限的API  \n尤其适用于需要把不受我们控制的对象(例如 DOM 对象)作为 Key 值的情况\n\n## Set\nES6 新增的 Set 用于存储一系列不重复的值  \n其判断是否重复的规则除了 Set 会认为 +0 等与 -0 外都与 `Object.is()` 相同\n```js\nconst set = new Set()\nconst x = { a: 1 }\nconst y = { b: 2 }\n// 支持链式调用\nset.add(x).add(y).add(x)\n\nset.size // 2\n\nset.delete(y)\nset.size // 1\n\nset.has(x) // true\nset.clear()\nset.size // 0\n\nset.add(1).add('1').add(2);\n[...set.keys()] // [1, \"1\", 2]\n[...set.values()] // [1, \"1\", 2]\n[...set.entries()] // [[1, 1], [\"1\", \"1\"], [2, 2]]\n```\n与 Map 不同的是 Set 实例的默认 Iterator 与 `values()` 相同  \n可以利用 Set 来进行数组去重\n```js\nconst arr = [1, 1, 2, 3, 3, 4, '4']\nconst unique = [...new Set(arr)]\nconsole.log(unique) // [1, 2, 3, 4, \"4\"]\n```\n\n## WeakSet\n同 WeakMap 类似，WeakSet 中存储的值只能是 Object\n并且当 Object 被 GC 后 WeakSet 也会自动将其从集合中删除\n"},"./src/blogs/CookieAndWebStorage.md":function(n,e){n.exports="# Cookie 和 WebStorage\n\n## 为什么需要客户端存储\n* 记录用户登录状态，当用户下次访问时不必重新登录\n* 存储一些用户对应用的自定义偏好设置，例如主题色、表格每页默认显示条数等\n* 一些广告商需要通过客户端端存储的一些用户行为数据来做一些更个性化的推荐\n\n恰当的利用客户端存储可以很好的优化用户体验\n\n## Cookie\n\n### Cookie 是什么\nCookie 其实就是网站存储在客户端的一些数据  \n这些数据会自动的被加到网站发起的每个 HTTP 请求的 Request Header 中  \n通常情况下服务端和客户端都可以对 Cookies 进行 CRUD 操作  \n[点这里查看 Cookie 协议](https://tools.ietf.org/html/rfc6265#section-5.2.1)\n\n### 如何在前端新增 Cookie\n```js\n// 最简单的设置方式 属性全部采用默认值\ndocument.cookie = 'name=value'\n// 自定义 Cookie 属性\ndocument.cookie = 'test=111; max-age=3600; domain=xx.com; path=/;'\n```\n注意一次只能同时新增一个 Cookie\n\n### 如何在前端修改或删除 Cookie\n```js\n// 修改 test 为 222\ndocument.cookie = 'test=222; max-age=7200; domain=xx.com; path=/'\n// 删除 test\ndocument.cookie = 'test=; max-age=0; domain=xx.com; path=/'\n```\n这里要注意的是要确保 `domain` 以及 `path` 与待修改 Cookie 设置的一致  \n因为 Cookie 其实是在同一个域名和路径下唯一  \n例如我们访问 `www.a.com/test/xx.html`  \n可以同时存在 `test=1; domain=a.com; path=/test` 以及 `test=1; domain=a.com; path=/`  \n这俩个 name 相同但是 path 不同的同名 Cookie  \n所以只有 `name` `domain` `path` 这三个值都相同时才能确定一个 Cookie\n\n### 如何读取 Cookie\n通过 `document.cookie` 获取到的是所有数据  \n类似 `name1=value1; name2=value2` 的字符串  \n要拿来使用的话还需通过一系列字符串操作将需要的值取出\n\n### 如何判断 Cookie 是否启用\n由于 Cookie 涉及到用户的隐私，用户可以手动禁止浏览器使用 Cookie  \n绝大多数浏览器都可以通过以下代码来判断用户是否禁用 Cookie  \n```js\nnavigator.cookieEnabled\n```\nPs: 经本人测试 禁用 Cookie 后 Github 淘宝 等都无法正常访问  \n感觉现在大多数用户都不会去禁用 Cookie，不然会有一堆网站访问不了\n\n### 关于 Cookie 的属性\n* domain  \n指定 Cookie 存储在哪个域名下 默认为当前服务器的域名  \n当然也遵循同源策略 例如在 `www.son.a.com` 页面下    \n我们可以设置 Cookie 的 domain 为 `a.com`  \n这样在 `www.another.a.com` 页面也可以获取到该 Cookie  \n但是不能在该页面试图去操作 domain 为 `b.com` 的 Cookie\n* path  \n指定 Cookie 存储在哪个路径下 默认为当前 URI 中的路径  \n例如在 `www.a.com/page/one.html` 我们按默认属性设置了一个Cookie  \n那么在 `www.a.com/page/two.html` `www.a.com/page/son/three.html`  \n这些页面下都可以获取这个 Cookie  \n但是在 `www.a.com/another/four.html` 页面上便无法得到这个 Cookie  \n可以将 path 设为 `/` 使得访问当前域名下所有路径的网页都能拿到设置的 Cookie\n* max-age 最大存储时间 以秒为单位 默认当浏览器 Session 结束时清除\n* expires 存储失效的 GMT 时间 默认当浏览器 Session 结束时清除\n* secure 包含该属性的 Cookie 只能通过 HTTPS 传输\n* httponly  \n只能在服务端进行设置  \n包含该属性的 Cookie 只会在 Request Headers 中出现  \n前端无法通过 `document.cookie` 查看修改\n\n### 关于 Cookie 中的保留字符\n由于 `;` `,` `空格` 在 Cookie 中有特殊含义  \n所以当存储的数据中包含这些特殊字符时  \n需要在存储前通过 `encodeURIComponent` 进行编码  \n读取前通过 `decodeURIComponent` 进行解码\n\n### Cookie 的优缺点\n优点：\n* 适合用于存放需要每个请求都必须携带的数据\n* 服务端也可以直接操作 Cookie\n* 可以通过 domain 以及 path 控制数据存储的范围\n\n缺点：\n* 容量有限，规范只要求每个域名下最低提供 4kb 的存储空间\n* 每次请求都会携带，如果存放了大量不必要的数据很显然会影响页面性能\n* 不安全，永远不要在 Cookie 中存放用户的敏感数据\n* 前端 API 不友好，CRUD 都是通过 `document.cookie` 进行，没有提供相关操作的方法\n\n# WebStorage\n\n## WebStorage 是什么\nWebStorage 是 HTML5 新增的客户端存储机制  \n分为 `LocalStorage` 以及 `SessionStorage`  \nIE8+ 以及各现代浏览器对其都有良好的支持  \n[点这里查看 WebStorage 规范](https://html.spec.whatwg.org/multipage/webstorage.html#storage)\n\n## LocalStorage\n永久存储（除非浏览器缓存被清除）在当前域下，遵循同源策略  \n如果在一个浏览器打开多个窗口访问同一域名的网站  \n那么这多个窗口中的 LocalStorage 是共享的\n\n## SessionStorage\n存储周期为当前 Session ，同样遵循同源策略  \n要注意这里的 Session 和 Cookie 的默认存储 Session 不同  \nSessionStorage 针对的是浏览器的每个窗口，而不是整个浏览器的进程  \n正因如此，与 LocalStorage 不同的是，多个窗口下的同域名网站，其 SessionStorage 也是分开存储的  \nPs：要注意的是如果在一个窗口内访问的网站通过 `<iframe>` 内嵌了俩个同域名网站  \n那么这俩个 `<iframe>` 内嵌站点的 SessionStorage 是共享的\n\n## API\n```\n// sessionStorage 与 localStorage 一致\nlocalStorage.a = 'test1' // 新增或修改\nlocalStorage.a // 读取\nlocalStorage['a'] // 读取\n\nlocalStorage.setItem(a, 'test3') // 新增\nlocalStorage.getItem(a) // 读取\nlocalStorage.removeItem(a) // 删除\nlocalStorage.clear() // 清空所有\nlocalStorage.key(index) // 获取指定 index 存储键值对的 key\nlocalStorage.length // 总共存储的键值对数量\n```\n可以看到通过类似操作普通对象一样来操作 WebStorage  \n通常来说这种方式更为简洁  \n但是也有类似 `clear()` `removeItem()` 等操作只能通过 API 进行\n\n## Storage Event\nWebStorage 还提供了事件机制，用于监听存储发生的变化  \n当打开俩个窗口访问同域网站，如果在其中一个窗口中修改了存储数据  \n在另一个窗口中可以通过如下代码监听到存储改变的事件  \n```js\n// 会被 setItem() removeItem() clear() 触发\nwindow.addEventListener('storage', e => {\n\t/**\n\t\te: {\n\t\t\tkey, // 发生改变的 key\n\t\t\tnewValue, // 旧值\n\t\t\toldValue, // 新值\n\t\t\turl, // 触发变化的文档 URL\n\t\t\t...\n\t\t}\n\t*/\n\t// 当事件是由 clear() 触发时 key/newVlue/oldValue 都为 null\n})\n```\n要注意的是这个事件只有在本地存储真的发生变化时才会触发  \n也就是说假设已经通过 `localStorage.a = 'test'` 设置了本地存储中 `a` 的值为 `test`  \n那么再次执行 `localStorage.a = 'test'` 并不会触发事件  \n并且通过 `localStorage.removeItem('notExist')` 试图移除一个不存在的属性时也不会触发事件  \nPs:（由于 SessionStorage 是基于浏览器窗口存储，所以只有当使用 `<iframe>` 处理内嵌页面时才可能会触发事件）  \n这个机制可以用于实现应用的广播功能，当用户在一个窗口的页面进行操作时同步对另一个窗口的页面做出修改  \n例如用户在一个窗口中修改了应用的主题色，我们通过 `localStorage.color = 'red'` 来保存这一改变  \n另一个窗口通过监听到 `localStorage` 的变化同步的将应用的主题色也修改为 `red`\n\n\n## WebStorage 的优势\n* 每个域下允许存储超过 5MB 的数据（各个浏览器有所不同）\n* 更友好的 API\n\n\n## 其它注意事项\n* 不管是 Cookie 还是 WebStorage 都是与浏览器相关的  \n也就意味着在 Chrome 浏览器中存储的数据，当用户切换为 FireFox 浏览时就无法获取  \n当然这应该是小概率事件，毕竟大多数人习惯于使用同一种浏览器\n* 当浏览器设置 Cookie 失败时并不会报错，这个过程是静默的  \n例如当你试图跨域的去设置 Cookie 时只会发现不生效，但不会在控制台中看到相应错误信息\n* 虽然 WebStorage 的规范希望能支持对类似数组对象等结构化数据进行存储  \n但目前为止大多数浏览器仅支持字符串作为 Value  \n传入非字符串的值会被强制转化为字符串  \n例如试图通过 `localStorage.o = {a: 1}` 存储一个对象  \n会发现实际存储的是 `o: \"[object Object]\"`\n\n"},"./src/blogs/CrossOrigin.md":function(n,e){n.exports="# 关于跨域\n\n## 什么叫跨域?\n提到跨域首要要说的就是浏览器的同源策略（Same origin policy）  \n在浏览器中无法通过 JavaScript 获取不同域下的 Cookie/LocalStorage/IndexDB  \n无法操纵或读取不同域页面下的 DOM（例如无法获取通过 iframe 内嵌页面的 DOM）  \n无法向不同域的服务器发起 AJAX 请求  \n所谓的同域指的是域名/协议/端口号完全一致  \n就算父域名相同子域名不同也算跨域  \n例如从 `http://www.a.xx.com` 向 `http://www.b.xx.com` 发起请求也算跨域请求  \n当我们通过 XHR 向不同域的地址发起请求时就会碰到跨域问题  \n这时候如果接收请求的服务器未经过特殊配置，通常我们会在控制台中看到如下错误信息  \n```\nXMLHttpRequest cannot load xxx.\nNo 'Access-Control-Allow-Origin' header is present on the requested resource.\nOrigin 'xxx' is therefore not allowed access.\n```\n\n## 为什么浏览器会限制跨域请求?\n浏览器对跨域请求进行限制主要是出于安全方面的考虑  \n可以假想一下没有同源策略会引发什么样的问题  \n假设我们正在访问一个正常网站 a.com 同时打开了另一个恶意站点 b.com  \n如果没有同源限制，那么 b.com 页面上执行的恶意脚本文件即可获得我们所有的 Cookie/LocalStorage 中存放的数据  \n通常我们会把登录相关的信息放在其中，还有可能存放一些用户的隐私数据  \n这时 b.com 通过得到的登录相关信息又可以伪装成已登录的正常用户  \n通过向 a.com 发起请求并携带上这些登录信息，攻击者甚至可以窃取更多存在服务器端的关键数据  \n而 a.com 会认为这些请求是一个普通的已登录用户发出的  \n更危险的是由于一切操作都由脚本执行，普通用户根本感知不到这个过程\n\n## 怎样才能发起一个正确的跨域请求?\n由于现今前后端分离的架构，在大多数情况下我们的前端工程不会和后端工程部署在同一域名下  \n这个时候想前后端能进行正常交互就需要我们采取一些特殊的方法来绕过浏览器对跨域的限制  \n\n### JSONP（JSON with Padding）\n由于页面中静态资源的加载并不会受到同源策略的限制  \nJSONP 正是利用 `<script>` 想页面中注入代码来实现跨域请求  \n假设我们需要向 `http//www.a.com/api` 发起跨域请求  \n客户端通过动态创建一个 `<script>` 标签并插入页面\n```html\n<script src=\"http//www.a.com/api?jsonp=cb\"><\/script>\n```\n这样一个标签，浏览器就可以向该 URL 发起请求  \n需要注意的是正是因为 JSONP 是通过这种方式向服务端请求的  \n所以 JSONP 只能发起 GET 请求  \n并且请求返回的类型（Content-Type）应该为 `text/javascript`  \n请求中的参数 `?jsonp=cb` 是为了告诉服务端前端时使用哪个回调函数来处理请求返回的数据  \n服务端需要将数据嵌套进这个函数中再返回  \n例如返回的真实数据为 `{ a: 1 }`  \n那么服务端在请求中需要返回的 Javascript 代码片段应该为 `cb({ a: 1 })`  \n正因如此 JSONP 的命名是 JSON with Padding 因为需要服务端进行字符串 Padding 操作  \n并且返回的数据恰好就是 JSON 格式，不需要经过 `JSON.parse()`  \n这样当客户端收到这个代码片段并去执行时，我们便可以在先前定义好的 `cb()` 函数中接受到数据  \n类似 Jquery 等库提供的 JSONP 功能其实就是对上述过程的一种封装\n\n### CORS (Cross-Origin Resource Sharing)\nW3C 在 2014 年正式推出了 CORS 协议来更好的解决跨域问题  \nCORS 把请求分为简单请求和复杂请求  \n复杂请求在发送正式请求之前会先发一个被称作 Preflight 的预校验 `OPTIONS` 请求  \n只有当一个请求是\n* GET\n* HEAD\n* POST\n\n以上三种请求之一并且请求头只包含\n* Accept\n* Accept-Language\n* Content-Type (Ps: 且值只能为 `application/x-www-form-urlencoded` 或 `multipart/form-data` 或 `text/plain`)\n* Content-Language\n\n如上几种时才会被认为是简单请求  \n对于前端来说需要做的支持操作仅仅在于当需要 CORS 请求支持携带 Cookie 等认证信息时  \n因为 CORS 请求默认不会携带这些信息  \n将 `xhr` 的 `withCredentials` 设为 `true`  \n```js\nconst xhr = new XMLHttpRequest()\nxhr.withCredentials = true\n```\n以我目前的项目经历来看，碰到的跨域问题大都是后台配置有误，前端在这方面能做的有限  \n下面介绍一下 CORS 用于验证跨域请求的一些相关 `HTTP Headers`  \n请求头：\n* Origin （请求来源域名也就是发起请求页面的域名）\n* Access-Control-Request-Method （在预校验请求时预校验的 OPTIONS 请求中携带 告知服务端真实请求的类型）\n* Access-Control-Request-Headers （同上 在预校验请求中携带 告知服务端真实请求会携带的自定义请求头）\n\n响应头：\n* Access-Control-Allow-Origin （必备 当前接口允许的请求来源域名 当设为 * 时 请求不能携带 Cookie 等鉴权信息）\n* Access-Control-Allow-Headers （预校验请求返回 告知浏览器所有允许携带的自定义请求头）\n* Access-Control-Allow-Methods （预校验请求返回 告知浏览器所有服务端支持的请求类型）\n* Access-Control-Allow-Crendentials （可选 当需要传递 Cookie 时设为 true）\n* Access-Control-Max-Age (预校验请求返回  告知浏览器在一段时间内缓存 不必再次发起预校验请求)\n* Access-Control-Expose-Headers （前端能通过 `xhr.getResponseHeader()` 获取到哪些请求头的具体值）\n"},"./src/blogs/Generator.md":function(n,e){n.exports="# Generator in ES6\n## 序\nGenerator 不同于一般的函数，它可以在执行过程中被暂停然后在稍后的任意时刻恢复执行，并且在过程中可以与外界双向传递数据\n\n## 如何写一个简单的 Generator\n```js\nfunction *foo() {\n\treturn 'hello'\n}\n\nconst it = foo()\nit.next() // { value: 'hello', done: true}\n```\n与普通函数的不同的是调用一个 Generator 并不会立即执行函数体，而是返回一个 Iterator 来控制该函数的执行\n\n## 如何写一个有意义的 Generator\nGenerator 最大的用途在于暂停函数逻辑的执行，需要借助 ES6 新增的关键字 `yield` 来实现\n```js\nfunction *foo() {\n\tconst a = yield 'hello'\n\tconsole.log(a)\n\t\n\tconst b = yield 'world'\n\tconsole.log(b)\n\t\n\treturn 'finish'\n}\n```\n下面来依次执行上述 Generator，看看每一步的结果\n```js\nconst it = foo() // 获得 Generator 返回的 Iterator\nit.next('step 1')\n// {value: \"hello\", done: false}\n```\n初次执行，代码会停在 `const a = yield 'hello'` 处，`'hello'` 作为返回值被抛到函数外\n\n需要注意的是此时 `next()`  中的参数还未真正传入函数，因为 **yield** 将自身替换为外部传入值的时机是在代码恢复执行时\n```js\nit.next('step 2')\n// 'step 2'\n// {value: \"world\", done: false}\n```\n第二次执行，代码会停在 `const b = yield 'world'` 处，我们在 `next()` 中传入的 `'step2'` 被赋值给变量 `a`\n\n可以看做 `yield 'hello'` 被替换成了 `'step2'` ，`'world'` 作为返回值被抛出\n```js\nit.next('step 3')\n// 'step 3'\n// {value: \"finish\", done: true}\n```\n最后一次执行，`'step3'` 被赋值给变量 `b` ，Generator 执行完毕，`'finish'` 作为返回值被抛出\n\n## `yield *`\n**yield delegation** 可以把当前 Generator 的控制委派给另一个 Iterator  \n```js\nfunction *foo() {\n\tyield *[1, 2, 3]\n}\nfor (v of foo()) {\n\tconsole.log(v) // 1 2 3\n}\n```\n"},"./src/blogs/GulpPlugin.md":function(n,e){n.exports='# 如何编写一个自己的GulpPlugin\n\n```\nconst through = require("through-gulp"),\n\tfs = require("fs")\n\nfunction myPlugin() {\n\treturn through(function(file, encoding, callback) {\n\t\tlet result, origin\n\t\t\n\t\t// 传入的文件为空\n\t\tif (file.isNull()) {\n\t\t\tthrow "Please Check Files!"\n\t\t}\n\n\t\t// buffer对象可以直接操作\n\t\tif (file.isBuffer()) {\n\t\t\t//拿到单个文件buffer             \n\t\t\tfile.contents = new Buffer(file.contents.toString("utf-8"),"utf-8")\n\t\t}\n\t\t \n\t\t// stream流是不能操作的,可以通过fs.readFileSync\n\t\tif (file.isStream()) {\n\t\t\t// 同步读取\n\t\t\tfile.contents = new Buffer(s.readFileSync(file.path).toString("utf-8"),"utf-8")\n\t\t}\n\n\t\torigin = file.contents.toString("utf-8") // 转化为字符串\n\t\tresult = doYourPluginWork(origin) // 处理源文件 实现插件的逻辑\n\t\tfile.contents = new Buffer(result) // 将源文件的内容替换为插件处理完之后的内容\n\n\t\tthis.push(file)\n\t\tcallback() // 声明文件已处理完毕\n\t}, function(callback) {\n\t\tcallback() // 声明文件已处理完毕\n\t})\n}\n\nmodule.exports = myPlugin\n```\n'},"./src/blogs/Iterator.md":function(n,e){n.exports="# Iterator in ES6\n## Iterator 与 Iterable\nIterator 可以看做一个拥有固定格式的对象，可供 ES6 新增的遍历 `for of` 和解构 `...` 等消费，并按顺序依次产出结果，样例如下\n```js\n// 除了以下俩个值外也可以额外返回更多的自定义属性\nconst IteratorResult = {\n\tvalue: ..., // 每次迭代产出的真实值\n\tdone: ..., // true|false true代表迭代结束 与true相对应的value一般建议为undefined\n}\n\nconst Iterator = {\n\t// 必须 用于返回每次迭代的结果集\n\tnext() { return IteratorResult},\n\t// 可选 提前结束迭代时做相应的资源清理操作并返回最后的结果集\n\treturn() {},\n\t// 可选 抛出异常信息并返回最后的结果集\n\tthrow() {}\n}\n```\n一个对象如果实现了 Iterable 接口则被称为 Iterabel 对象(简单来说就是对象上有一个 key 为 `Symbol.iterator` 的方法并且这个的返回值为 Iterator)\n```js\nconst Iterable = {\n\t[Symbol.iterator]() {return Iterator}\n}\n```\n\n## 如何构造一个简单的 Iterable 对象\n```js\nlet rand = Math.random()\n// 会随机产生一串数字的Iterable对象\nconst iterable = {\n\t// 必备!!! 这样才能使该对象 Iterable\n\t[Symbol.iterator]() {return this},\n\t// 依次去获取数据\n\tnext() {\n\t\tif (rand > 0.5) {\n\t\t\trand = Math.random()\n\t\t\treturn {\n\t\t\t\tvalue: rand,\n\t\t\t\tdone: false\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tdone: true\n\t\t\t}\n\t\t}\n\t}\n}\n// 该对象可以用 for of 遍历\nfor (let value of iterable) {\n\tconsole.log(value)\n}\n```\n\n## 如何构造一个完整的 Iterable 对象\n```js\n// 该对象可以步进的产生对数据的每一步累加结果\nconst stepAccumulator = {\n\t[Symbol.iterator]() {\n\t\tlet sum = 0\n\t\tlet index = 0\n\t\tconst data = this.data.slice()\n\t\tlet done = false\n\t\treturn {\n\t\t\t// 使迭代器(Iterator)本身可迭代(Iterable)\n\t\t\t[Symbol.iterator]() { return this },\n\t\t\tnext() {\n\t\t\t\tconst value = sum += data[index]\n\t\t\t\tindex++\n\t\t\t\tif (index <= data.length && !done) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tdone: false\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\treturn(v) {\n\t\t\t\tconsole.log('abandoned')\n\t\t\t\tdone = true\n\t\t\t\treturn {\n\t\t\t\t\tvalue: v,\n\t\t\t\t\tdone: true\n\t\t\t\t}\n\t\t\t},\n\t\t\tthrow(e) {\n\t\t\t\tconsole.log('error')\n\t\t\t\tdone = true\n\t\t\t\treturn {\n\t\t\t\t\tvalue: e,\n\t\t\t\t\tdone: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tdata: []\n}\n// 设置数据\nstepAccumulator.data = [1, 2, 3]\nconsole.log(...stepAccumulator) // 1 3 6\n\n// 1 3 'abandoned'\nfor (let v of stepAccumulator) {\n\tconsole.log(v)\n\tif (v > 1) break\n}\n\nconst it = stepAccumulator[Symbol.iterator]()\nit.next() // { value:1, done: false }\nit.throw('!!!') // 'error' { vallue:'!!!', done: true }\nit.next() // { done: true }\n```\n* `return()` 和 `throw()` 都可以通过 **Iterator** 调用，并且调用后意味着迭代终止，之后便不能通过该迭代器获取到更多的值\n* 一般来说 **Iterable** 对象支持同时生成多个 **Iterator**，且相互间的迭代不会互相影响，当然你也可以把迭代器设为单例\n* 任何一种取消或者提前终止迭代的操作都会使 **Iterator** 自动调用 `return()` 来处理相关清理工作\n\n## ES6 原生支持的 Iterable 数据结构\n包括 `String` `Map` `Set` `Array` 等\n```js\nconst str = 'abc'\nconst arr = [1, 2, 3]\nconst map = new Map()\nmap.set('a', 1)\nmap.set('b', 2)\nfor (let v of str) {\n\tconsole.log(v) // 'a' 'b' 'c'\n}\nfor (let v of arr) {\n\tconsole.log(v) // 1 2 3\n}\nfor (let v of map) {\n\tconsole.log(v) // ['a', 1] ['b', 2]\n}\n```\n"},"./src/blogs/ObjectAPI.md":function(n,e){n.exports="## Object's New API In ES6\n\n### Object.is()\n该方法用于比较俩个值是否相等，基本的比较逻辑与 `===` 一致但是更加严格\n```js\nconst x = NaN\nconst y = 0\nconst z = -0\n\nx === x // false\nObject.is(x, x) // true\ny === z // true\nObject.is(y, z) // false\n```\n当不需要考虑这几种特殊情况时，直接用 `===` 比较更方便\n\n### Object.getOwnPropertySymbols()\nES6 新增的 `Symbol` 可以作为对象上的特殊属性使用  \n有时我们可能希望只获得一个对象上的所有 `Symbol` 属性，排除其他普通属性  \n这个时候就可以借助该方法\n```js\nconst o = {\n\tfoo: 'hello',\n\t[ Symbol('bar') ]: 'world'\n}\n\nconst symbols = Object.getOwnPropertySymbols(o) // [Symbol(bar)]\no[symbols[0]] // 'world'\n```\n\n### Object.setPrototypeOf()\n该方法提供了一种更优雅的方式来修改一个对象的原型\n```js\nconst o1 = {\n\tbar: 1\n}\nconst o2 = {\n\tfoo: 2\n}\n\nObject.setPrototypeOf(o1, o2)\no1.foo // 2\no1.__proto__ === o2 // true\n\n// 将o1设置为无原型对象 类似 const o = Object.create(null)\n// 这种做法通常是为了获得一个纯净的对象来作为 Map 使用\n// 现在ES6新增了原生的 Map 结构 可以考虑避免使用这种技巧\nObject.setPrototypeOf(o1, null)\no1.__proto__ // undefined\n```\n\n### Object.assign()\n由于 React / Vue / Angular 等数据驱动的前端框架的流行  \n这个方法在平常项目中使用频率很高，用于将一系列对象中的值复制到目标对象中  \n并且会对各对象相同 key 的 (enumerable) 值按先后顺序进行覆盖\n```js\nlet o1 = { a: 1 }\nlet o2 = { b: 2 }\n\nObject.assign({}, o1, o2) // { a: 1, b: 2 }\n\nObject.defineProperty(o2, 'c', {\n\tvalue: 3,\n\tenumerable: false\n})\n\nObject.defineProperty(o2, 'd', {\n\tvalue: 4,\n\tenumerable: true\n})\n\n// 可以看到 enumerable 为 false 的属性不会被拷贝\nObject.assign({}, o1, o2) // { a: 1, b: 2, d: 4}\n\no2[Symbol('bar')] = 5\n// Symbol 属性也会被拷贝\nObject.assign({}, o1, o2) // { a: 1, b: 2, d: 4, Symbol(bar): 5}\n```\n值得注意的是，该方法的拷贝过程是浅拷贝  \n类似于对每个属性进行 `target = src` 的赋值  \n所以碰到数组、对象之类的复杂数据结构时要多加小心\n"},"./src/blogs/PreventModalScroll.md":function(n,e){n.exports="# 如何阻止模态框 (Modal / Popup / Dialog) 弹出后 Body 可滚动\n\n## 序\n\n当模态框的遮罩层为透明时，鼠标或手指在模态框内容区进行操作  \n此时如果被遮罩层挡住的 Body 内容仍会滚动会造成视觉上的干扰  \n为了最佳的用户体验，我们需要想办法禁止这种默认的行为\n\n## 设置Body的样式 `overflow: hidden`\n在模态框弹出时通过\n```js\n// 弹出\ndocument.body.style.overflow = 'hidden'\n// 关闭\ndocument.body.style.overflow = 'initial'\n```\n修改 `<body>` 的样式使得滚动条消失，Bootstrap 的 Modal 采取的就是这种方式  \n缺点在于滚动条消失会导致页面向右偏移约 20px，以填充滚动条消失的空白  \n在 PC 端会有比较明显的感觉，对用户体验还是稍有影响  \n另外移动端的大多浏览器对给 `<body>` 设置 `overflow: hidden` 并不感冒  \n绝大多数情况下这种方式在移动端不起作用(亲测 ios Chrome 下无效)\n\n## 通过 Javascript 禁止滚动事件的默认行为\n```js\nfunction preventScroll(e) {\n\te.preventDefault()\n}\n\n// 弹出\n// { passive: false }是因为Chrome对相应事件做了优化 如果不设置会导致页面报错\n// Unable to preventDefault inside passive event listener due to target being treated as passive. \n// See https://www.chromestatus.com/features/5093566007214080\ndocument.body.addEventListener('mousewheel', preventScroll, { passive: false })\ndocument.body.addEventListener('touchmove', preventScroll, { passive: false })\n\n// 关闭\ndocument.body.removeEventListener('mousewheel', preventScroll)\ndocument.body.removeEventListener('touchmove', preventScroll)\n```\n如果模态框的内容区中没有可滚动的元素，那么这个方案是可行的  \n如果有的话会发现内容区中元素的滚动也被一并禁止了\n\n## 进一步优化方案\n由于我们不想禁止掉所有元素的滚动，可以考虑在需要滚动的元素上加一个特定类  \n当触发事件的元素是该允许滚动的元素或者其子元素时，不去 preventDefault\n```js\nfunction preventScroll(e) {\n\t// 只有容器中类名包含 scroll-able 的元素以及子元素允许滚动\n\tif (!e.path.find(dom => dom.classList && dom.classList.contains('scroll-able'))) {\n\t\te.preventDefault()\n\t\te.stopPropagation()\n\t}\n}\n```\n"},"./src/blogs/Promise.md":function(n,e){n.exports="# Promise In ES6\n\n## 序\n以往我们通常用回调函数来处理异步编程  \n但类似下例中嵌套过深的回调会使程序的可读性很差（也就是人们通常说的 Callback Hell）  \n```js\nfunction foo(cb) {\n\tasyncFunc1(() => {\n\t\tcb()\n\t\tasyncFunc2(() => {\n\t\t\tcb()\n\t\t\tasyncFun3(() => {\n\t\t\t\tcb()\n\t\t\t})\n\t\t})\n\t})\n}\n```\n`Promise` 的出现为开发者提供了一种更优雅的方式来处理异步编程\n\n## 如何构造一个 `Promise`\n```js\nconst p = new Promise((resolve, reject) => {\n\tconst rand = Math.random()\n\tsetTimeout(() => {\n\t\tif (rand > 0.5) {\n\t\t\tresolve('finish')\n\t\t} else {\n\t\t\treject('err')\n\t\t}\n\t}, 3000)\n})\n\n// 在3秒后输出 'finish' or 'err'\np.then(res => console.log(res))\n.catch(err => console.log(err))\n\n// 同上\np.then(res => console.log(res), err => console.log(err))\n```\n一个 `Promise` 最终只会有俩种状态 **fulfilled** 或 **rejected**  \n前者可以在 `then()` 的第一个参数中获得处理完成的结果  \n后者可以在 `then()` 的第二个参数或者 `catch()` 中获得处理失败的原因  \n每一个 `Promise` 只会被 resolve(fulfill 或 reject)一次  \n并且一旦当 `Promise` 执行完毕，它就成为了一个不可变的值  \n\n## 为什么说 `Promise` 更优雅\n`Promise` 支持链式调用  \n我们将上例中重写一遍 高下立判\n```js\nasyncFunc1().then(res => {\n\treturn asyncFunc2()\n}).then(res => {\n\treturn asyncFunc3()\n}).then(res => {\n\tconsole.log(res)\n})\n```\n\n## Promise API\n\n### Promise.resolve() 和 Promise.reject()\n```js\nconst p1 = Promise.resolve(1)\nconst p2 = new Promise(resolve => resolve(1))\n\nconst p3 = Promise.reject(1)\nconst p4 = new Promise((resolve, reject) => reject(1))\n```\n可以通过 `Promise.resolve()` 将 thenable 对象转为真正的 `Promise` 对象  \n如果你以前用了类似 `Promise` 语法的异步处理库  \n现在想将其行为转成和 `Promise` 一致时可能会用到\n\n### Promise.all([...])\n该方法的入参是一个包含多个 Promise 对象的数组  \n它会等到其中所有的 Promise 完成(fulfilled)后将结果集返回  \n或者其中任意一个 Promise 失败(rejected)后将错误抛出\n```js\nconst p1 = 1\nconst p2 = Promise.resolve(2)\nconst p3 = new Promise((resolve, reject) => {\n\tsetTimeout(() => {\n\t\tresolve(3)\n\t}, 3000)\n})\n\n// 3s 后输出 [1, 2, 3]\nPromise.all([p1, p2, p3]).then(res => console.log(res))\n\nconst e1 = new Promise((resolve, reject) => {\n\tsetTimeout(() => {\n\t\treject('err')\n\t}, 1000)\n})\n\n// 1s 后输出 \"err\"\nPromise.all([p1, p2, p3, e1])\n.then(res => console.log(res))\n.catch(err => console.log(err))\n```\n\n### Promise.race([...])\n与 `Promise.all()` 不同，该方法只会取入参中所有 Promise 中最快返回的结果  \n不管是接受(resolve)或是拒绝(reject)  \n其余 Promise 的处理结果都会被忽略\n```js\nconst p1 = new Promise((resolve, reject) => {\n\tsetTimeout(() => {\n\t\tresolve(1)\n\t}, 1000)\n})\nconst p2 = new Promise((resolve, reject) => {\n\tsetTimeout(() => {\n\t\tresolve(2)\n\t}, 2000)\n})\n// 1s 后输出 1\n// 无论执行多少遍都是该结果 永远不会输出2\nPromise.race([p1, p2]).then(res => console.log(res))\n```\n要注意的是当传入空数组时 `Promise.all([])` 会立即执行完毕  \n而 `Promise.race([])` 会永远处于等待状态，所以建议永远别这么使用 Promise\n\n## `async` + `await` （ES7）\n当 ES6 的 Generator 与 Promise 共同使用时可以产生一些更酷的特性  \n让我们能够像写同步代码一样去实现异步过程  \n但是需要实现一个特殊的 Runner 来执行这个 Generator  \nES7新增了语法糖 `async` 以及 `await` 来帮助我们更便捷的使用这一特性\n```js\nfunction asyncFunc1() {\n\treturn new Promise((resolve, reject) => {\n\t\tsetTimeout(() => {\n\t\t\tresolve('1 done')\n\t\t}, 3000)\n\t})\n}\n\nfunction asyncFunc2() {\n\treturn new Promise((resolve, reject) => {\n\t\tsetTimeout(() => {\n\t\t\tresolve('2 done')\n\t\t}, 3000)\n\t})\n}\n\nfunction asyncFunc3() {\n\treturn new Promise((resolve, reject) => {\n\t\tsetTimeout(() => {\n\t\t\tresolve('3 done')\n\t\t}, 3000)\n\t})\n}\n\nasync function main() {\n\tconst res1 = await asyncFunc1()\n\tconsole.log(res1)\n\tconst res2 = await asyncFunc2()\n\tconsole.log(res2)\n\tconst res3 = await asyncFunc3()\n\tconsole.log(res3)\n}\n\n// 3s后 \"1 done\"\n// 再3s后 \"2 done\"\n// 再3s后 \"3 done\"\nmain()\n```\n可以看到，相较于 `Promise.then(...).then(...)`  \n这种方式让异步程序的执行过程更加一目了然\n需要注意的一点是 `await` 只能出现在 `async` 函数中  \n也就是说直接出现在最外层代码中的 `const res = await fetch('xxx')` 是错误的  \n除此之外，`await` 还可以和 `Promise.all()` 一起使用\n```js\nasync function test() {\n\tconst allRes = await Promise.all([\n\t\tfetch('aaa'),\n\t\tfetch('bbb')\n\t])\n}\n```\n"},"./src/blogs/ReactRedux.md":function(n,e){n.exports="# React-Redux 从入门到后悔\n\n## 序\nRedux作为一个简单的用于管理应用状态的工具，可以与任何其它的前端框架共用  \n当然，尤其适用于数据驱动视图的框架(Vue/React/Angular)  \n为了避免让我们自己将Redux的Store一层一层往子组件传递  \n然后在一遍遍通过subscribe来监听Store的变化并去修改组件的状态  \nReact-Redux利用高阶组件(HOC)  \n将上述逻辑封装到了`<Provider>`以及`connect()`俩个简单的API中  \n当开发者想在React中使用Redux时，React-Redux将会是必不可少的帮手\n\n## How to use\n首先，用Redux提供的`<Provider>`包裹根组件\n```js\n// 新建Redux的Store\nconst store = createStore(reducers)\n\nReactDOM.render(\n\t<Provider store={store}>\n\t\t<App />\n\t</Provider>,\n\tdocument.getElementById('root')\n)\n```\n然后通过\n```js\nconnect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])(Comp)\n```\n这样就能得到注入Redux后的新组件  \n如果不传入`mapStateToProps`，则不会在该组件中去监听`store`的变化  \n如果不传入`mapDispatchToProps`，则默认只将`dipatch`注入组件  \n```js\nexport default connect()(Comp)\n```\n将`dispatch`注入组件  \n这样在组件中就可以通过`this.props.dispatch(action)`来修改Redux的`store`  \n但不会去监听`store`的变化\n```js\nexport default connect(state => state)(Comp)\n```\n监听所有`store`的的变化，并注入`dispatch`  \n不建议这么做，会降低程序的效率\n```js\nconst mapStateToProps = (state, ownProps) => {\n\treturn { all: state.total + ownProps.total }\n}\nexport default connect(mapStateToProps)(Comp)\n```\n注入`all`以及`dispatch`，并且监听`store`的变化  \n当`store`中的`total`或者组件自身的`total`发生变化时都会重绘组件\n```js\nconst mapDispatchToProps = dispatch => {\n\treturn {\n\t\taddTodo: todo => dispatch(todoActionCreator(todo))\n\t\t// 可以在此处借助bindActionCreators\n\t\t// addTodo: bindActionCreators(todoActionCreator, dispatch)\n\t}\n}\nexport default connect(null, mapDispatchToProps)(Comp)\n```\n不监听`store`  \n在组件中可以通过调用`this.props.addTodo('xx')`来改变应用状态\n\n## 源码中学习到的小技巧\nReact-Redux 默认通过以下方法来比较组件的Props是否相等  \n如果不等则意味着组件需要进行重绘\n```js\n// 通过hasOwn.call(xx, xx)\n// 相较于xx.hasOwnProperty(xx) 更简洁？\nconst hasOwn = Object.prototype.hasOwnProperty\n\n// Object.is()的Polyfill\nfunction is(x, y) {\n\tif (x === y) {\n\t\t// Object.is(0, -0) => false\n\t\treturn x !== 0 || y !== 0 || 1 / x === 1 / y \n\t} else {\n\t\t// Object.is(NaN, NaN) => true\n\t\treturn x !== x && y !== y\n\t}\n}\n\nexport default function shallowEqual(a, b) {\n\tif (is(a, b)) return true\n\t\n\t// 如果a或者b不是object 并且Object.is(a, b) => false\n\t// 则认为a和b不等\n\tif (typeof a !== 'object' || a === null ||\n\t\ttypeof b !== 'object' || b === null\n\t) {\n\t\treturn false\n\t}\n\t\n\tconst keysA = Object.keys(a)\n\tconst keysB = Object.keys(b)\n\t\n\t// 在a和b都是object的情况下\n\t// 如果a与b的所有key值相同 并且与之对应的value都满足Object.is(v1, v2) => true\n\t// 则也认为a和b相等\n\tif (keysA.length !== keysB.length) return false\n\tfor (let i = 0; i < keysA.length; i++) {\n\t\tif (!hasOwn.call(b, keysA[i]) ||\n\t\t\t!is(objA[keysA[i]], objB[keysA[i]])\n\t\t) {\n\t\t\treturn false\n\t\t}\n\t}\n\t\n\treturn true\n}\n```\n\n*********\n\nReact的PropTypes除了进行如下的基础校验\n```js\nnumber string object bool func\narray\nsymbol\nnode // 任何可以被当作节点绘制的类型\nelement // React Element\n```\n还可以利用相关API进行更严格的格式校验\n```js\nMyComponent.propTypes = {\n\t// 指定值中的其中一个 类似枚举类型\n\txx: PropTypes.oneOf(['News', 'Photos']),\n\t// 特定实例\n\txx: PropTypes.instanceOf(Foo),\n\t// 多种可选基础类型\n\txx: PropTypes.oneOfType([\n\t\tPropTypes.string,\n\t\tPropTypes.number\n\t]),\n\t// 只包含特定类型值的数组\n\txx: PropTypes.arrayOf(PropTypes.number),\n\t// 只包含特定类型值的对象\n\txx: PropTypes.objectOf(PropTypes.number),\n\t// 必须包含指定属性的对象\n\txx: PropTypes.shape({\n\t\txx: PropTypes.number,\n\t\tyy: PropTypes.bool.isRequired\n\t}),\n\t// 只能包含指定属性的对象\n\txx: PropTypes.exact({\n\t\txx: PropTypes.number,\n\t\tyy: PropTypes.bool.isRequired\n\t}),\n\t// 任意值\n\txx: PropTypes.any.isRequired\n}\n```\n\n*********\n\nReact 的高阶组件(HOC)并不会自动将被包裹组件的静态方法自动继承到新返回的组件中  \n会导致以下问题\n```js\nWrappedComponent.staticMethod = () => {}\n\nconst EnhancedComponent = HOC(WrappedComponent)\nEnhancedComponent.staticMethod // => undefined\n```\n可以借助[hoist-non-react-statics](https://github.com/mridgway/hoist-non-react-statics)来解决这个问题\n```js\nimport hoistNonReactStatic from 'hoist-non-react-statics'\n\nconst EnhancedComponent = hoistNonReactStatic(HOC(WrappedComponent), WrappedComponent)\nEnhancedComponent.staticMethod // => () => {}\n```\n"},"./src/blogs/Redux.md":function(n,e){n.exports="# Redux 从入门到放弃\n\n## 基本概念\n当我们通过各类MVVM框架(React / Vue / Angular)开发复杂的单页应用(SPA)时  \n随之而来碰到的问题是对应用中各种状态的管理  \n每个组件都有各自的状态，当任意一个组件的状态发生变更，同时也可能需要触发另一个组件状态的变更  \n当这种耦合关系越来越多的时候，我们会发现很难去寻找一个状态发生变更的原由  \n并且当组件层级过深时，一层层的在组件间传递 props 也显得颇为繁琐  \nRedux 的出现给开发者提供了一种更优雅的管理前端应用状态的解决方案  \n当然相应的代价是需要引入一些冗余的语法( boilerplate )  \nRedux 的核心是以下三个原则:  \n* Single source of truth: 每个 Redux App 应该只有一个全局唯一的 Store\n* State is read-only: Store 中存储的状态只能通过 Dispatch Action 来进行修改  \n这样通过一些工具开发者可以很清楚的看到状态发生变更的时机以及每次所发生的改变  \n甚至进行 Time Travel 来回到某个 Action 执行前的状态  \n亦或是再次重新提交这个 Action 来观察其行为对应用的影响  \n* Changes are made with pure functions: Reducer 是 Pure Function  \n\n### Actions\n不同于直接去修改应用的状态，例如 React 中的 `this.setState()`  \nRedux 推崇通过 Dispacth Action 来修改状态  \nAction 是一个携带了操作类型以及具体数据的简单对象( Plain Object )  \n```js\nconst action = {\n\t// 操作类型 用于描述该次操作的用意\n\t// 通常由下划线分隔的大写字符组成\n\t// 当有很多 action 时建议将 type 提取成常量放到单独文件维护\n\ttype: 'ADD_PEOPLE',\n\t// 具体操作的数据\n\tpeople: {\n\t\tname: 'a'\n\t}\n}\n```\n以上 Action 中的数据是固定的，可以实现一个 ActionCreator 来根据参数动态的生成 Action  \n```js\nconst actionCreator = people => ({\n\ttype: 'ADD_PEOPLE',\n\tpeople\n})\n```\n注意最终还是需要通过 `store.dispatch(action)` 将 Action 派发至 Reducer 中才能进行应用状态的变更  \n\n### Reducer\nReducer 用于定义如何根据收到的不同 Action 去改变应用的状态  \nReducer 应该是一个 Pure Function , 意味着不应该在其中进行由副作用的操作  \n并且当入参相同时其返回值应该总是相同的  \n```js\n// 注意需要给我们的应用设置一个初始化的 initalState\n// 如果未指定 Redux 会开发环境下给出警告\nfunction reducer(state = initalState, action) {\n\tswitch(action.type) {\n\t\tcase 'ADD_PEOPLE':\n\t\t\treturn { ...state, ...{ people: action.people } }\n\t\t// 在遇到未知的 Action 时需要将原先的 state 直接返回\n\t\tdefault:\n\t\t\treturn state\n\t}\n}\n```\n\n### Store\n每一个应用都只能有一个唯一的 Store  \n通过 `createStore(reducers)` 来生成  \n用于维护应用的所有 State ，以及提供一些静态方法用于改变、获取当前状态  \n```js\nstore.getState() // 获取当前状态\nstore.dispatch(action) // 提交action来改变当前状态\nconst unsubscribe = store.subscribe(listener) // 监听事件\nunsubscribe() // 取消监听\n```\n\n## 进阶以及源码(v4.0.0)\n为了看起来更加精简，本文仅仅会对一些核心代码进行分析  \n所以展示的只是不完整的代码片段，例如一些校验性质的代码就会被省略\n\n### Middleware\nRedux 的中间件使开发者可以在每次 `dispatch(action)` 前后加上一些特定的逻辑  \n例如 logging/routing 等，中间件的写法如下  \n```js\nconst middleware = store => next => action => {\n\t// 在dispatch前执行的逻辑\n\t// ...\n\t\n\tconst result = next(action)\n\t\n\t// ...\n\t// 在dispatch完成后执行的逻辑\n\treturn result\n}\n```\n\n### compose.js\n在 Redux 的 applyMiddleware 中会用到，函数式编程中常见  \n可以将传入的函数从右至左依次执行  \n并且每个函数执行的结果会作为下一个函数的参数  \n例如 `compose(a, b, c)(arg)` 执行起来同 `a(b(c(arg)))`\n```js\nexport function compose(...funcs) {\n\t// 如果没有传入任何参数 则直接返回一个会将第一个参数返回的函数\n\tif (funcs.length === 0) {\n\t\treturn arg => arg\n\t}\n\t\n\t// 如果参数只有一个函数则直接将该函数返回\n\tif (funcs.lenth === 1) {\n\t\treturn funcs[0]\n\t}\n\t\n\t// 关于 Array.prototype.reduce \n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\n\treturn funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n\n----------- 下面都是分析  --------------\n\n// 我们来试试 funcs.reduce 是如何来实现逻辑的\nconst first = () => console.log(1)\nconst second = () => console.log(2)\nconst third = () => console.log(3)\nconst funcs = [first, second, third]\n\n// 分解开来看\n// 第一次 reduce 相当于\n// (first, second) => (...args) => first(second(...args))\n// 其返回结果是\n// (...args) => first(second(...args))\n// 第二次 reduce 执行时的 accumulator 及第一次的返回结果\n// 所以 (accumulator, third) => (...args) => accumulator(third(...args))\n// 返回结果是 \n// (...args) => accumulator(third(...args))\n// 将 accumulator 替换后就相当于\n// (...args) => first(second(third(...args))\nconst re = funcs.reduce((a, b) => (...args) => a(b(...args)))\n\n// 上述代码中有一个地方要理解一下\n// const test = (...args) => f(...args)\n// 在参数中的...其实起到的是收集的作用，会将我们调用时传入的所有参数放到args这个数组中\n// 而在 f(...args) 中的...起到的是解构的作用\n// 又会将 args 数组中的所有元素依次作为参数传到f这个函数中\n// 假设我们 test(1, 2, 3) 这样调用则其返回结果其实就是 f(1, 2, 3)\n// 所以这种做法其实就是在我们不确定一个函数入参个数的情况下\n// 将所有入参原封不动的按照原有顺序传入到调用函数中\n// 按照老的方式其实就是借助 arguments 来实现\n// es6\nconst test = (...args) => f(...args)\n// Babel 编译后\nvar test = function test() {\n\treturn f.apply(undefined, arguments)\n}\n\n// 从上述分析可以得出 re 其实就等同于\n// (...args) => first(second(third(...args))\n// 当我们调用 re() 就等同于\n// first(second(third())\n// 所以输出是 3 2 1\nre() // 3 2 1\n\n// 通过对传入函数的特殊处理 可以使这个过程变为正序\n// Redux 的 middleWare 就是借助这种原理\nconst a = next => arg => { console.log(arg); next('b'); }\nconst b = next => arg => { console.log(arg); next('c'); }\nconst c = next => arg => { console.log(arg); next('d'); }\nconst d = arg => console.log(arg)\n\n// 'a' 'b' 'c' 'd'\ncompose(a,b,c)(d)('a')\n// 继续分解来看一下 首先是compose(a, b, c)\n// 从上述分析得出的结论来看也就是等同于\n// (...args) => a(b(c(...args)))\n// 然后是compose(a,b,c)(d) 所以入参为函数d\n// 也就是等同于a(b(c(d)))\n// 第一步c(d) 返回 re1 = arg => {console.log(arg); d('d')}\n// 第二步b(c(d)) 也就是b(re1) 返回 re2 = arg => { console.log(arg); re1('c'); }\n// 第三步a(b(c(d))) 也就是a(re2) 返回 re3 = arg => { console.log(arg); re2('b'); }\n// 所以compose(a,b,c)(d) 返回的就是 arg => { console.log(arg); re2('b'); }\n// 最后一步compose(a,b,c)(d)('a') 相当于\n// console.log('a'); re2('b')\n// 再把所有的结果展开\n// console.log('a'); console.log('b'); console.log('c'); console.log('d');\n```\n\n### applyMiddleware\n对外提供应用中间件的接口\n```js\nexport default function applyMiddleware(...middlewares) {\n\t// 注意 applyMiddleware 是一个高阶函数\n\t// 返回值是一个入参为 createStore 的函数\n\treturn createStore => (...args) => {\n\t\t// 当需运用中间件时 createStore 在此处真正执行\n\t\tconst store = createStore(...args)\n\t\t\n\t\t// 只提供给中间件有限的 API 而不是全部 store\n\t\tconst middlewareAPI = {\n\t\t\tgetState: store.getState,\n\t\t\tdispatch: (...args) => dispatch(...args)\n\t\t}\n\t\t// 要注意此时如果在 middleware 中执行 middlewareAPI.dispatch() 会抛出错误\n\t\t// 由于 Redux 规定 middleware 形如 store => next => action => {} 的函数\n\t\t// 这样处理过后在 chain 中存放的便是形如 next => action => {} 的函数\n\t\tconst chain = middlewares.map(middleware => middleware(middlewareAPI))\n\t\t// 这里的 dispatch 是已经实现了中间件逻辑后的 dispatch 方法\n\t\tdispatch = compose(...chain)(store.dispatch)\n\t\t\n\t\t// 这里利用了解构会去重的特性\n\t\t// 会将 store.dispatch 覆盖为包含中间件逻辑的新 dispatch\n\t\treturn {\n\t\t\t...store,\n\t\t\tdispatch\n\t\t}\n\t}\n}\n```\n\n### utils/isPlainObject.js\n该工具函数用于判断一个 Action 是不是 Plain Object    \n所谓的 Plain Object 指的是直接通过 `{}` 或者 `new Object()` 生成，原型链上并没有其它对象的 Object\n```js\n// 大体上就相当于 Object.getPrototypeOf(obj) === Object.prototype\nexport function isPlainObject(obj) {\n\t// 如果对象都不是当然也不是PlainObject\n\t// 这里注意的是 obj === null 这个判断\n\t// 因为在Js中 typeof null === 'object'\n\tif (typeof obj !== 'object' || obj === null) return false\n\t\n\t// lodash 中的 isPlainObject 多了这个逻辑\n\t// 主要考虑到这个特殊情况 const o = Object.create(null)\n\t// 此处的o应该也满足条件 isPlainObject(o) // => true\n\tif (Object.getPrototypeOf(obj) === null) {\n\t\treturn true\n\t}\n\t\n\tlet proto = obj\n\t// 因为 Object.getPrototypeOf(Object.prototype) === null\n\t// 所以当循环结束时 proto 指向的其实就是Object.prototype\n\t// 也就是说此时的 proto === Object.prototype\n\twhile (Object.getPrototypeOf(proto) !== null) {\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\t\n\t// 如果传入对象的 prototype 与 Object.prototype 一致\n\t// 则认为该对象是 Plain Object\n\t// 所以最终的判断逻辑其实与 obj.__proto__ === Object.prototype 类似\n\t// 上面的代码更多的是在考虑 edge case\n\t// 至于这里为什么不使用 Object.getPrototypeOf(obj) === Object.prototype\n\t// 可以戳这里 https://github.com/reduxjs/redux/pull/2599#issuecomment-342849867\n\treturn Object.getPrototypeOf(obj) === proto\n}\n```\nPs: `lodash.isPlainObject` 逻辑与上述代码基本一致  \n同样是 Redux 的开发者 *timdorr* 提的 PR\n\n### index.js\n```js\n// ...\n\n// 建立一个函数名为 isCrushed 的空函数\nfunction isCrushed() {}\n\n// 如果当前的环境不是生成环境但采用了压缩过后的代码则提示开发者\n// 因为压缩混淆后的代码会将函数改变为类似 function f() {} 以减小代码体积\nif (process.env.NODE_ENV !== 'production' && \n\ttypeof isCrushed.name === 'string' &&\n\tisCrushed.name !== 'isCrushed'\n) {\n\twarning('...')\n}\n\n// 以下为 Redux 所有对外提供的 API\nexport {\n\tcreateStore,\n\tcombineReducers,\n\tbindActionCreators,\n\tapplyMiddleware,\n\tcompose,\n\t__DO_NOT_USE__ActionTypes\n}\n```\n\n### createStore.js\nRedux 应用的主入口  \n```js\n// reducer 必传 通常来讲是我们通过 combineReducers 将所有 ruducer 集成到一起后的主函数\n// preloaderState 可选 可以传入的应用初始状态\n// enhancer 可选 也就是 applyMiddleware() 的返回结果\nexport default function createStore(reducer, preloadedState, enhancer) {\n\t// 由于 preloadedState 参数是可选的 所以这里考虑的是这么一种情况\n\t// createStore(reducer, applyMiddleware())\n\t// 这样在不传入 preloadedState 时就不用像 createStore(reducer, null, applyMiddleware()) 这样调用\n\tif (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n\t\tenhancer = preloadedState\n\t\tpreloadedState = undefined\n\t}\n\t\n\t// 有传入 enhancer 也就是有使用中间件(applyMiddleware)\n\tif (typeof enhancer !== 'undefined') {\t\t\n\t\t// 有使用中间件的话 需要在 applyMiddleware 去 createStore\n\t\t// applyMiddleware() 返回的是一个形如 createStore => (...args) => {} 的函数\n\t\t// 所以这里会对enhancer(cerateStore)返回的结果再次传入参数(reducer, preloaderState)调用\n\t\treturn enhancer(createStore)(reducer, preloaderState)\n\t}\n\t\n\t// 利用闭包存储当前的 Reducer\n\t// 这样就稍后才可通过 replaceReducer() 方法替换掉当前使用的 Reducer\n\tlet currentReducer = reducer\n\t\n\t// 同上 整个 Redux 应用的状态树都是利用闭包存储的\n\tlet currentState = preloadedState\n\t\n\t// 这里要注意 多存了一份当前监听事件函数的备份\n\tlet currentListeners = []\n\tlet nextListeners = currentListeners\n\t\n\t// 用于标识当前是否正在执行 dispatch() 操作\n\tlet isDispatching = false\n\t\n\t// 确保 nextListeners 存的是 currentListeners 的备份 而不是引用\n\tfunction ensureCanMutateNextListeners() {\n\t\tif (nextListeners === currentListeners) {\n\t\t\tnextListeners = currentListeners.slice()\n\t\t}\n\t}\n\t\n\t// 简单的把当前闭包所存储的应用状态返回出去\n\tfunction getState() {\n\t\t// 正在执行 dispatch 操作时不能获取当前状态\n\t\t// 因为当前状态可能会被正在执行的 dispatch() 操作改变\n\t\tif (isDispatching) {\n\t\t\tthrow new Error('...')\n\t\t}\n\t\t\n\t\treturn currentState\n\t}\n\t\n\t// 注册监听事件 在每次 dispath 时都会调用所有注册过的函数\n\tfunction subscribe(listener) {\n\t\t// 正在执行dispatch操作时不允许新注册监听事件\n\t\tif (isDispatching) {\n\t\t\tthrow new Error('...')\n\t\t}\n\t\t\n\t\t// 这里同样利用了闭包\n\t\t// 每次调用都会有独立的 isSubscribed 状态\n\t\t// 与每个 listener 一一对应\n\t\tlet isSubscribed = true\n\t\t\n\t\tensureCanMutateNextListeners()\n\t\tnextListeners.push(listener)\n\t\t\n\t\treturn function unsubscribe(){\n\t\t\t// 避免重复取消监听 例如\n\t\t\t// const off = store.subscribe(...)\n\t\t\t// off()\n\t\t\t// off()\n\t\t\tif (!isSubscribed) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t\n\t\t\t// 正在执行 dispatch 操作时不允许取消监听\n\t\t\tif (isDispatching) {\n\t\t\t\tthrow new Error('...')\n\t\t\t}\n\t\t\t\n\t\t\t// 代表这个 listener 已经取消监听了\n\t\t\tisSubscribed = false\n\t\t\t\n\t\t\tensureCanMutateNextListeners()\n\t\t\t// 这里也利用了闭包 先找到当前闭包存储的入参 listerner 在数组中的下标\n\t\t\tconst index = nextListeners.indexOf(listener)\n\t\t\t// 移除数组中对应下标存储的元素\n\t\t\tnextListeners.splice(index, 1)\n\t\t}\n\t}\n\t\n\tfunction dispatch(action) {\n\t\t// 阻止开发者在 reducer 中去调用 dispatch\n\t\tif (isDispatching) {\n\t\t\tthrow new Error('...')\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tisDispatching = true\n\t\t\t// currentReducer 就是当前 Redux 正在使用的 Reducer\n\t\t\t// 将当前状态树和 action 传入 返回经 reducer 处理过后的新状态树\n\t\t\tcurrentState = currentReducer(currentState, action)\n\t\t} finally {\n\t\t\t// 无论 reducer 处理过程中是否出错 都需要更改 flag\n\t\t\t// 代表本次 dispatch 操作结束 否则接下来 redux 就没法用了\n\t\t\tisDispatching = false\n\t\t}\n\t\t\n\t\t// 这里要注意执行顺序\n\t\t// 每次 dispatch 都会将当前的 currentListeners 指向 nextListeners\n\t\t// 所以每次执行的其实都是最新的 nextListeners 当中存储的的监听事件\n\t\t// 这里就可以理解 ensureCanMutateNextListeners() 的用处\n\t\t// 每次新增监听或取消监听时都要确保 nextListeners 是 currentListener 的拷贝\n\t\t// 这样保证在 dispatch 过程中的 currentListerner 不会发生变化\n\t\t// 例如如果我们在一个 listener 函数中去新 subscribe 或者 unsubscribe\n\t\t// 都不会立马生效 而是只有等到下一次 dispatch 才会生效\n\t\tconst listeners = (currentListeners = nextListeners)\n\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t// 注意这里的用法 并没有直接像 listeners[i]() 这样调用\n\t\t\t// 因为这样的话 listener 中的 this 会指向 listeners 而不是 window\n\t\t\tconst listener = listeners[i]\n\t\t\tlistener()\n\t\t}\n\t\t\n\t\t// 将传入的 action 原封不动返回\n\t\t// 感觉基本来说不会用到这个函数的返回值\n\t\treturn action\n\t}\n\t\n\t// 替换当前正在使用的 Reducer\n\tfunction replaceReducer(nextReducer) {\t\n\t\t// 直接将闭包的存储指向新的 Reducer\n\t\tcurrentReducer = nextReducer\n\t\t// dispatch 一个 REPLACE Action 来重新生成新的状态树\n\t\tdispatch({ type: ActionTypes.REPLACE })\n\t}\n\t\n\t// dispatch 一个 INIT Action 初始化生成Redux的状态树\n\tdispatch({ type: ActionTypes.INIT })\n\t\n\t// 对外主要就提供了四个 API\n\treturn {\n\t\tdispatch,\n\t\tsubscribe,\n\t\tgetState,\n\t\treplaceReducer,\n\t\t[$$observable]: observable // 私有的 用于测试 这里不具体展开\n\t}\n}\n```\n\n### combineReducer.js\n由于在大型应用中我们需要管理一个复杂的状态树  \n如果将所有的 Action 处理逻辑写在同一个 Reducer 中会很难维护  \n所以大多数情况下我们的项目中会有很多个不同的 Reducer 文件  \n而 Redux 的 `createStore(reducer)` 只接受一个 RootReducer 作为参数  \n所以这个时候就需要借助 Redux 提供的这个工具方法将所有的子 Reducer 合为最终的 RootReducer\n其主要作用如下  \n```js\n// 应用的状态树\nconst state = {\n\ta: '',\n\tb: ''\n}\n\nconst reducerA = (a, action) => {}\nconst reducerB = (b, action) => {}\n// 自己手动来生成 RootReducer\nconst rootReducer = (state, action) => {\n\treturn {\n\t\ta: reducerA(state.a, action),\n\t\tb: reducerB(state.b, action)\n\t}\n}\n// 借助 combineReducer\n// 入参中的 key 需要与 state 中的 key 相对应\n// 子 Reducer 的函数名可以任意 并无影响\nconst rootReducer = combineReducer({\n\ta: reducerA,\n\tb: reducerB\n})\n```\n下面看看源码\n```js\n// ...\n\n// 将多个子 reducer 组合返回一个 root reducer 函数\nexport default function combineReducers(reducers) {\n\t// 拿到入参对象的所有 key\n\tconst reducerKeys = Object.keys(reducers)\n\tconst finalReducers = {}\n\t\n\tfor (let i = 0; i < reducerKeys.length; i++) {\n\t\tconst key = reducerKeys[i]\n\t\n\t\t// 确保 fianalReducers 中的每个 value 都是一个函数\n\t\tif (typeof reducers[key] === 'function') {\n\t\t\tfinalReducers[key] = reducers[key]\n\t\t}\n\t}\n\tconst finalReducerKeys = Object.keys(finalReducers)\n\t\t\n\treturn function combination(state = {}, action) {\n\t\tlet hasChanged = false\n\t\tconst nextState = {}\n\t\tfor (let i = 0; i < finalReducerKeys.length; i++) {\n\t\t\tconst key = finalReducerKeys[i]\n\t\t\tconst reducer = finalReducers[key]\n\t\t\tconst previouStateForKey = state[key]\n\t\t\tconst nextStateForKey = reducer(previousStateForKey, action)\n\t\t\t// Reducer 处理过后的状态不能返回为空\n\t\t\tif (typeof nextStateForKey === 'undefined') {\n\t\t\t\tthrow new Error('...')\n\t\t\t}\n\t\t\tnextState[key] = nextStateForKey\n\t\t\t// 判断经 Reducer 处理后的状态前后是否发生变化\n\t\t\thasChanged = hasChanged || nextStateForKey !== previousStateForKey\n\t\t}\n\t\t// 注意 对于 Redux 而言 整个状态树中只要有一处发生变化 则视为其有过变化\n\t\treturn hasChanged ? nextState : state\n\t}\n}\n```\n\n### bindActionCreators.js\n在 Redux 中我们需要先生成 `Action` 然后再将其 `dispatch` 至 `Reducer` 来触发状态的改变  \n如果你觉得分俩步操作过于繁琐就可以通过 `bindActionCreators` 将这俩步操作绑定在一起  \n```js\nfunction bindActionCreator(actionCreator, dispatch) {\n\t// 返回一个函数 执行会先 Create Action  \n\t// 然后 dispatch 这个生成的 Action\n\treturn function () {\n\t\tdispatch(actionCreator.apply(this, arguments))\n\t}\n}\n\nexport default bindActionCreators(actionCreators, dispatch) {\n\t// 传入单个 Creator\n\t// 直接返回绑定后的 Creator\n\tif (typeof actionCreators === 'function') {\n\t\treturn bindActionCreator(actionCreators, dispatch)\n\t}\n\t\n\tconst keys = Object.keys(actionCreators)\n\t// 用于存储绑定后的 Creator\n\tconst boundActionCreators = {}\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i]\n\t\tconst actionCreator = actionCreators[key]\n\t\tif (typeof actionCreator === 'function') {\n\t\t\t// 依次绑定每一个 Creator\n\t\t\tboundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n\t\t}\n\t}\n\t// 将绑定后的结果返回\n\treturn boundActionCreators\n}\n```\n"},"./src/blogs/SourceMapAndWebpack.md":function(n,e){n.exports='# 关于 Source Map 以及 Webpack 中 Devtool 的相关配置\n\n## Source Map 是什么\n为了提升 Web App 的性能，通常我们会把源码压缩混淆后再发布到服务器上  \n当 App 出现问题时这些压缩过后的代码就会使得我们很难具体定位到错误出现在哪  \nSource Map 的出现正是为了解决这个难题  \n通过在压缩后的代码中加入如下注释\n```js\n// 注意此处的 sourceMappingURL 支持 http uri 以及 data uri 俩种形式\n//# sourceMappingURL=/path/to/script.js.map\n```\n并在压缩混淆同时生成相应的 map 文件\n```js\n{\n    version: 3,\n    file: "script.js.map",\n    sources: [\n        "a.js",\n        "b.js",\n        "c.js"\n    ], // 所有源文件的路径\n    sourceRoot: "/",\n    names: ["foo", "bar", "func"], // 所有源文件中出现的变量名 函数名\n\t// 关键所在 具体原理就不管了 有点复杂 大致是通过 Base64-VQL 编码做映射\n    mappings: "AABASD,ASDFDSA,OAAOC,OAAO..."\n}\n```\n这样浏览器就可以反向定位到错误具体出现在源码中的哪个文件的哪一行中  \nPs: [关于原理](https://www.codercto.com/a/31149.html)\n\n## 关于 Source Map 的几个问题以及解答\n### 为什么在浏览器的 network 中看不到下载 .map 文件的请求\n浏览器默认只会在打开开发者工具时才去请求 .map 文件  \n所以在 network 中看不到记录\n[Stackoverflow](https://stackoverflow.com/questions/44315460/when-do-browsers-download-sourcemaps#)\n\n### 如果将 .map 文件也发布到公开的服务器上，普通用户能否利用 Source Map 看到源文件\n很不幸，答案是会的  \n更不幸的是，通过 .map 文件以及压缩后的代码可以反向生成源代码  \n这意味着在公开的生产环境下我们不应该去使用 Source Map  \n因为这样相当于把整个 App 的源码暴露在外，是一种很危险的行为  \n建议在类似预发环境(也就是与正式环境相同但是是私有的环境)下来利用 Source Map 进行 Debug  \nPs: 还可以通过服务器端的配置来禁止普通用户下载 .map 文件，这样就可以安全的把 .map 文件也放到正式环境上\n\n### Source Map 对开发环境的意义何在\n开发环境我们通常不会采用混淆代码，对于简单的 Javascript 应用可能意义并不大  \n但当我们在开发 React App 或者 Vue App 时  \nSource Map 可以将我们 Webpack 打包后的文件直接映射为源代码中的 .jsx/.vue 文件  \n而不利用 Source Map 我们就只能去 Debug 编译过后的文件  \n所以即是在开发环境下，Source Map 也是能给我们提供很大帮助的\n\n## Webpack 的 Devtool\nWebpack 中可以通过这项配置来决定具体使用何种 Source Map  \n默认值为 `false` 也就是不启用 Source Map  \n从方便 Debug 的角度从差到好排列，Webpack 一共提供了如下几种形式的 Source Map\n* bundled code // 不开启 浏览器中只能看到打包过后的代码\n* generated code // 可以看到打包前的每个 Module 但是看到的是 Webpack 处理后的文件\n* transformed code // 可以看到打包前的每个 Module 但是看到的是经过 Loader 编译过后的文件\n* original source // 可以看到源码\n* (lines only) // 只定位到行 不定位到列\n* without source content // 不暴露源文件 但是仍会暴露目录结构 可以在错误信息中看到源码对应的出错行列\n\n关于 Devtool 的配置大致由如下几种关键字组合而来，每个关键字代表着不同特性\n* eval // 编译速度最快\n* inline // 不生成 .map 文件 以DataURL的形式嵌入\n* cheap // 只定位到行 transformed code\n* cheap-module // 只定位到行 original source\n\n就目前来说  \n个人感觉在开发环境下设为 `cheap-module-eval-source-map`  \n可以获得较好的 Debug 体验，以及较快的编译速度  \n在预发环境下设为 `source-map` 可以获得最完整的映射  \n在正式环境下设为 `false` 避免源文件暴露  \n当然碰到具体问题时可以进行调整  \n要记住 Source Map 的终极目的是为了方便开发者定位问题  \n所以只要能帮助我们找到问题的配置就是好配置\n\nPs: Webpack V4 中，当 mode 设为 \'production\' 时  \n默认使用的 `uglifyjs-webpack-plugin` 会默认设置 `sourceMap: true`  \n当我们手动去新配置 `uglifyjs-webpack-plugin` 时会覆盖掉默认配置  \n所以要注意像如下配置一样加上 `sourceMap: true` 否则 Souce Map 会不生效\n```js\n// webpack.prod.config.js\nconst UglifyJsPlugin = require("uglifyjs-webpack-plugin")\n\nmodule.exports = {\n\t// ...\n\tmode: \'production\',\n\toptimization: {\n\t\tminimizer: [\n\t\t\tnew UglifyJsPlugin({\n\t\t\t\t// ...\n\t\t\t\tsourceMap: true // 注意这里!!!!!!\n\t\t\t\t// ...\n\t\t\t})\n\t\t]\n\t}\n\t// ...\n}\n```\n'},"./src/blogs/Symbol.md":function(n,e){n.exports="# Symbols in ES6\n`Symbol`是 ES6 (时隔多年) 新增的一种 **primitive type** ，可以把它看做一种自动生成 **唯一字符串** 的机制，它的真实值在代码中无法直接获得\n\n## 如何生成 Symbol\n```js\n// 最基础的方式\nconst a = Symbol()\n\n// 可以传入一串描述该 Symbol 用途的字符串作为参数\nconst b = Symbol('some description text')\n\n// 从全局的 Symbol 库中查询所需的结果\n// 如果未找到则新建一个并返回\n// 这种方式较以上直接构造 Symbol 的优点在于\n// 可以不必在外部作用域中专门维护一个变量用于存储生成的 Symbol\nconst c = Symbol.for('my Symbol')\n\n// 由于 Symbol 全局存在\n// 为了尽量避免命名冲突 可以在描述中添加前缀\nconst d = Symbol.for('prefix.Symbol')\n```\n\n## 如何判断一个值是否为 Symbol\n```js\nconst sym = Symbol()\n// 推荐方式\ntypeof sym === 'symbol'// true\n\n// 并不是一种类与实例化对象的关系 无法通过以下方法判断\nsym instanceof Symbol // false\n```\n\n## 如何获取 Symbol 的描述\n```js\nconst a = Symbol('desc a')\nconst b = Symbol.for('desc b')\n\nSymbol.keyFor(a) // undefined\nSymbol.keyFor(b) // desc b\n\na.toString() // Symbol(desc a)\nb.toString() // Symbol(desc b)\n```\n通过上述对比，个人感觉用 `Symbol.for()` 来生成 `Symbol` 好像更加合适  \n不仅可以少声明一个变量，并且能更方便的获得其描述\n\n## Symbol 的使用场景\n借助 `Symbol` 来实现单例模式\n```js\nconst Instance = Symbol.for('instance')\nfunction singleton() {\n\tif (singleton[Instance]) {\n\t\treturn singleton[Instance]\n\t}\n\t\n\treturn singleton[Instance] = {}\n}\nconst a = singleton()\nconst b = singleton()\na === b // true\n```\n\n如果将上例中的 Symbol 替换成任意一个 Magic String 对逻辑的实现并无影响  \n所以从个人经验来看 暂时还未碰到有必须要使用 Symbol 的场景  \n\n```js\nconst o = {\n\tfoo: 1,\n\t[Symbol.for('bar')]: 2\n}\nObject.getOwnPropertyNames(o) // ['foo']\nObject.getOwnPropertySymbols(o) // [Symbol(for)]\nObject.keys(o) // ['foo']\nfor (let key in o ){\n\tconsole.log(key) // 'foo'\n}\n```\n\n可以看到，虽然 Symbol 作为对象的 key 不会被当作普通的键值被遍历  \n但还是可以通过 `Object.getOwnPropertySymbols()` 来获得  \n所以通过 Symbol 并不能实现私有属性的需求\n\n## Built-in Symbols\n个人认为 ES6 自身提供的 Built-in Symbols 可能才是最常见的使用方式，例如 `Symbol.iterator`:\n```js\nconst arr = [1, 2, 3]\narr[Symbol.iterator] // native function\nconst it = arr[Symbol.iterator]() // 获得数组的 Iterator\n```\n值得一提的是这些内部的 Symbol 并不是像自定义的那样注册到全局库中  \n而是作为 Symbol 构造函数的静态属性存在\n"},"./src/blogs/VueVsReact.md":function(n,e){n.exports="# React 与 Vue 的一些对比\nPs: 根据个人经验总结 有些结论可能并不客观\n\n## React\n* 单向数据流 申明式视图\n* 官方提供的 API 较为简单 大多数功能交给开源社区扩展 例如 Redux / React-Router 等\n* CSS 样式文件与组件文件分离\n* 实现表单以及表单验证时的写法较为繁琐\n* 父子组件通信 Props Down 只能向下单向传递\n* 推崇 JSX 语法 也就是 CSS HTML 全都写在 JSX 中\n* React-Router 不支持钩子函数 需要自己实现\n\n## Vue\n* 数据双向绑定\n* 核心团队统一维护较为全面的 API\n* 支持单文件组件 CSS / HTML / Javascript 都可以写在同一文件中 个人更喜欢 Vue 提供的 `scoped` 样式特性  \n相较于 React 借助 PostCSS 的 Style In CSS 写法感觉更简明一点\n* 由于双向绑定的存在 可以更方便的实现表单以及表单验证功能\n* 父子组件通信 Props Down / Events Up 可以双向通信\n* 虽然都在单文件组件中 但是 CSS / HTML / Javascript 都是分开写的\n* Vue-Router 支持钩子函数 用起来很方便\n"},"./src/blogs/WebpackBaseConfig.md":function(n,e){n.exports="# Webpack(v3.8.1)\n```\nconst path = require('path')\nconst webpack = require('webpack')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst pkg = require(path.join(__dirname, 'package.json'))// package.json\n\n// 定义项目中的一些文件夹路径\nconst APP_PATH = path.resolve(__dirname, 'src')\n\nlet theme = {}\n// pkg.theme存的是项目中antd主题文件的路径\n// 这里是 ./antd-theme.js\nif (pkg.theme && typeof(pkg.theme) === 'string') {\n  theme = require(path.resolve(__dirname, pkg.theme))\n}\n\nmodule.exports = {\n  entry: path.resolve(APP_PATH, 'index.jsx'),\n  // 暂时本地开发环境的不配output好像影响不大\n  // 后期遇到问题再配\n  resolve: {\n    // 配置这个后引用node_modules中的依赖包不用加路径 直接import xx from ('antd')即可\n    modules: [\n      'node_modules'\n    ],\n    //后缀 配了这个就可以在import时 import xx from (./test) 而不用 import xx from (./test.jsx)\n    extensions: ['.js', '.jsx', '.json', '.scss']\n  },\n  module: {\n    rules: [{\n      test: /\\.js|\\.jsx$/,\n      use: [\n        'babel-loader',\n        'eslint-loader'\n      ],\n      exclude: /node_modules/\n    }, {\n      test: /\\.css$/,\n      use: ['css-loader']\n    }, {\n      test: /\\.less$/,\n      use: [{\n        loader: 'style-loader'\n      },{\n        loader: 'css-loader'\n      },{\n        loader: 'less-loader',\n        options: {\n          sourceMap: true,\n          modifyVars: theme // 用于自定义antd主题 覆盖其less变量\n        }\n      }],\n      include: path.resolve(__dirname, 'node_modules')\n    }, {\n      test: /\\.scss$/,\n      use: [\n        'style-loader',\n        'css-loader',\n        'sass-loader'\n      ],\n      include: APP_PATH\n    }, {\n      // 字体文件之类的需要这个loader支持\n      test: /\\.(eot|woff|woff2|svg|ttf)([\\?]?.*)$/,\n      use: ['file-loader'],\n      include: APP_PATH\n    }, {\n      test: /\\.(jpe?g|png|gif|svg)$/,\n      use: [{\n        loader: 'url-loader',\n        options: {\n          limit: 8192// 小于1kb的图片采用base64编码 并以DATAUrl的形式嵌入页面\n        }\n      }],\n      include: APP_PATH\n    }]\n  },\n  devServer: {\n    contentBase: './build',\n    historyApiFallback: true,\n    hot: true,// 开启HMR\n    inline: true,\n    compress: true,// 开启gzip\n    port: 8080\n  },\n  plugins: [\n    new webpack.NamedModulesPlugin(),// 用于确保多次build生成的bundle名称不变\n    new HtmlWebpackPlugin({\n      template: 'index.html'// 以根目录下的index.html为模版\n    }),\n    new webpack.HotModuleReplacementPlugin()// HMR所需\n  ],\n  devtool: 'cheap-module-eval-source-map'\n}\n\n```\n生产环境\n```\nconst path = require('path')\nconst webpack = require('webpack')\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst CleanWebpackPlugin = require('clean-webpack-plugin')\nconst ROOT_PATH = path.resolve(__dirname)\nconst APP_PATH = path.resolve(ROOT_PATH, 'src')\n\nconst pkg = require(path.join(__dirname, 'package.json'))// package.json\nlet theme = {}\n// pkg.theme存的是项目中antd主题文件的路径\n// 这里是 ./antd-theme.js\nif (pkg.theme && typeof(pkg.theme) === 'string') {\n  theme = require(path.resolve(__dirname, pkg.theme))\n}\n// 用于提取自己写的css\nconst appExtract = new ExtractTextPlugin({filename: 'app.[contenthash].css', allChunks: true})\n// 用于提取依赖包的css(主要是Antd)\nconst vendorExtract = new ExtractTextPlugin({filename: 'vendor.css', allChunks: true})\n\nmodule.exports = {\n  entry: {\n    app: path.resolve(APP_PATH, 'index.jsx'),\n    vendor: ['react', 'axios']\n  },\n  output: {\n    path: path.resolve(__dirname, 'build'),\n    publicPath: '/',\n    filename: '[name].[chunkhash].js',\n    chunkFilename: '[name].[chunkhash:5].chunk.js',\n  },\n  resolve: {\n    // 配置这个后引用node_modules中的依赖包不用加路径 直接import xx from ('antd')即可\n    modules: [\n      'node_modules'\n    ],\n    //后缀 配了这个就可以在import时 import xx from (./test) 而不用 import xx from (./test.jsx)\n    extensions: ['.js', '.jsx', '.json', '.scss']\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        warnings: false\n      }\n    }),\n    // 与NamedModulesPlugin 但更适用于生成环境\n    new webpack.HashedModuleIdsPlugin(),\n    // 部分依赖包(React)会在非生产环境中包含一些提示、警告的代码来帮助开发者解决问题\n    // 在生产环境通过配置这个可以阻止生成这些代码 减小bundle的size\n    new webpack.DefinePlugin({ 'process.env.NODE_ENV': JSON.stringify('production') }),\n    // 变动频率小的外部依赖包\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'vendor'\n    }),\n    // webpack的运行环境所需\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'runtime'\n    }),\n    new HtmlWebpackPlugin({\n      template: 'index.html'// 以根目录下的index.html为模版\n    }),\n    new CleanWebpackPlugin('build'),\n    appExtract,\n    vendorExtract,\n  ],\n  module: {\n    rules: [{\n      test: /\\.js|\\.jsx$/,\n      use: [\n        'babel-loader',\n        'eslint-loader'\n      ],\n      exclude: /node_modules/\n    }, {\n      test: /\\.css$/,\n      use: vendorExtract.extract(['css-loader'])\n    }, {\n      test: /\\.less$/,\n      use: vendorExtract.extract({\n        fallback: 'style-loader',\n        use: [{\n          loader: 'css-loader'\n        },{\n          loader: 'less-loader',\n          options: {\n            sourceMap: true,\n            modifyVars: theme // 用于自定义antd主题 覆盖其less变量\n          }\n        }]\n      }),\n      include: path.resolve(__dirname, 'node_modules')\n    }, {\n      test: /\\.scss$/,\n      use: appExtract.extract({\n        fallback: 'style-loader',\n        use: ['css-loader','sass-loader']\n      }),\n      include: APP_PATH\n    }, {\n      // 字体文件之类的需要这个loader支持\n      test: /\\.(eot|woff|woff2|svg|ttf)([\\?]?.*)$/,\n      use: ['file-loader'],\n      include: APP_PATH\n    }, {\n      test: /\\.(jpe?g|png|gif|svg)$/,\n      use: [{\n        loader: 'url-loader',\n        options: {\n          outputPath: 'images/',// 将图片放入build/images/目录下\n          limit: 8192// 小于1kb的图片采用base64编码 并以DATAUrl的形式嵌入页面\n        }\n      }],\n      include: APP_PATH\n    }]\n  }\n};\n\n```\n"},"./src/blogs/WebpackCommonProblem.md":function(n,e){n.exports="# 记录配置 Webpack 过程中碰到的问题以及解决方案\nPs: 基于 Webpack V4\n\n## Vue\n\n### 未配置 VueLoaderPlugin\n错误信息\n```\nERROR in ./src/component/App.vue\nModule Error (from ./node_modules/vue-loader/lib/index.js):\nvue-loader was used without the corresponding plugin.\nMake sure to include VueLoaderPlugin in your webpack config.\n```\n[参考文档](https://vue-loader.vuejs.org/guide/#manual-configuration)  \n解决方案\n```js\n// webpack.config.js\nconst VueLoaderPlugin = require('vue-loader/lib/plugin')\n\nmodule.exports = {\n\t// ...\n\tplugins: [\n\t\tnew VueLoaderPlugin() // 新增VueLoaderPlugin\n\t]\n\t// ...\n}\n```\n\n### 未安装 vue-template-compiler\n错误信息\n```\nERROR in ./src/component/App.vue\nModule build failed (from ./node_modules/vue-loader/lib/index.js):\nError: [vue-loader] vue-template-compiler must be installed as a peer dependency, \nor a compatible compiler implementation must be passed via options.\n```\n[参考文档](https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler#vue-template-compiler)  \n由于`vue-loader`内部实现需要依赖`vue-template-compiler`  \n但我们通过 npm 安装`vue-loader`时并未同时安装`vue-template-complier`  \n所以需要显示的在本地项目安装一下\n解决方案\n```\nnpm i vue-template-complier --save-dev\n```\n\n### 未安装配置css-loader\n错误信息\n```\nERROR in ./src/component/App.vue?vue&type=style&index=0&lang=css& \n(./node_modules/vue-loader/lib??vue-loader-options!./src/component/App.vue?vue&type=style&index=0&lang=css&) 24:0\nModule parse failed: Unexpected token (24:0)\nYou may need an appropriate loader to handle this file type.\n|\n|\n> .app {\n|       font-size: 24px;\n|       margin-top: 50%;\n```\n由于默认的`.vue`文件中`<style>`的lang属性值为`css`  \n所以`vue-loader`默认会将`<style>`块中的样式文件抽出作为 Css 文件提供给`webpack`加载  \n而不配置`css-loader`的话`webpack`是无法正确加载 Css 文件的\n解决方案\n```\nnpm i css-loader --save-dev\n```\n```js\n// webpack.config.js\nmodule.exports = {\n\t// ...\n\tmodule: {\n\t\trules: [{\n\t\t\ttest: /.css$/,\n\t\t\tuse: 'css-loader'\n\t\t}]\n\t}\n\t// ...\n}\n```\n凭以上配置虽然页面能正常访问，但会发现样式并不会生效\n```\nnpm i style-loader --save-dev\n```\n```js\n// webpack.config.js\nmodule.exports = {\n\t// ...\n\tmodule: {\n\t\trules: [{\n\t\t\ttest: /.css$/,\n\t\t\tuse: [\n\t\t\t\t'style-loader',\n\t\t\t\t'css-loader'\n\t\t\t]\n\t\t}]\n\t}\n\t// ...\n}\n```\n[Style Loader](https://webpack.js.org/loaders/style-loader/)  \n[Css Loader](https://webpack.js.org/loaders/css-loader/)  \nCss Loader 的作用是使我们可以在 Js 文件中通过 `import style from 'xxx.css'` 来告诉 webpack 这个文件对样式的依赖  \n这样当打包这个 Css 文件时也会将 xxx.css 算入其中  \n当这样并不能使样式文件被浏览器正确加载  \nStyle Loader 正是启到将依赖的样式文件通过在页面上插入 `<style>` 标签的形式注入到页面中  \n所以简单来讲 不做其他特殊配置的话 一定要同时使用这俩个 Loader 才能使得样式正确加载\n\n### 未正确配置项目所使用的 Vue 文件\n错误信息\n```\n// 页面报错\n[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. \nEither pre-compile the templates into render functions, or use the compiler-included build.\n```\n页面并未正常渲染，而是在 `HTML` 中出现了如下片段\n```html\n<html>\n<head>\n\t<title>Vue</title>\n</head>\n<body>\n\t\x3c!--function (a, b, c, d) { return createElement(vm, a, b, c, d, true); }--\x3e\n\t<script type=\"text/javascript\" src=\"main.js\"><\/script>\n</body>\n</html>\n```\n[参考文档](https://vuejs.org/v2/guide/installation.html#Explanation-of-Different-Builds)  \n这个问题出现主要是由于 Vue 对外提供了俩个版本的最终构造文件 Full(Runtime + Compiler) 以及 Runtime-only   \n俩者的区别就在于一个有 Compiler 另一个没有  \n此外，在 Vue 的 package.json 中可以看到 `\"module\": \"dist/vue.runtime.esm.js\"`  \n也就是说在使用 webpack 打包时 `import Vue from 'vue'` 默认使用的是 vue.runtime.esm.js 也就是 Rutime-only 的版本  \nCompiler 的主要作用在于将文件中的模版字符串转化为 render 函数（注意这里的文件不包括 .vue 文件 因为他们会被 vue-loader 自动预编译）  \n举例，在如下 Vue 应用的主入口文件中  \n```js\n// main.js\nimport Vue from 'vue'\n\n// 这种形式需要引用 Full(Runtime + Compiler)\nnew Vue({\n\tel: '#app',\n\ttemplate: '<div></div>'\n})\n\n// 引用 Runtime-only 即可\nnew Vue({\n\tel: '#app',\n\trendre(h) {\n\t\treturn h('div')\n\t}\n})\n```\n所以以上问题的解决方案有俩种  \n其一是如果我们确定不会在除 .vue 文件外使用 Vue 的 template  \n那么直接照常引入默认的 Runtime-only 版本即可  \n否则则需要我们显示的引入 Full(Runtime + Compiler) 版本  \n``` js\n// main.js\nimport Vue from 'vue/dist/vue.esm.js'\n```\n可以利用 webpack 的别名功能简化这个操作，也是官方推荐的方式\n```js\n// webpack.config.js\nmodule.exports = {\n\t// ...\n\tresolve: {\n\t\talias: {\n\t\t\t'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' for webpack 1\n\t\t\t// Ps: 最后的 $ 意味着完全匹配 也就是说只有在 import xx from 'vue' 时这条规则才会生效\n\t\t\t// import xx from 'vue/xx.js' 并不会触发以上规则\n\t\t}\n\t}\n\t// ...\n}\n```\n之后只要照常引用 `import Vue from 'vue'` 则会正确引入 Full(Runtime + Compiler) 版本\n\n### ES6 代码未正确经过Babel编译\n[参考文档](https://github.com/vuejs/babel-plugin-transform-vue-jsx)  \nPs: 基于 Babel V7  \n解决方案\n```\nnpm install\n  babel-plugin-syntax-jsx\n  babel-plugin-transform-vue-jsx\n  babel-helper-vue-jsx-merge-props\n  babel-preset-env\n  --save-dev\n```\n\n```js\n// babel.config.js\nmodule.exports = function (api) {\n\tapi.cache(true)\n\treturn {\n\t\tpresets: ['env'],\n\t\tplugins: ['transform-vue-jsx']\n\t}\n}\n\n// webpack.config.js\nmodule.exports = {\n\t// ...\n\tmodule: {\n\t\trules: [{\n\t\t\ttest: /.js$/,\n\t\t\tuse: 'babel-loader'\n\t\t}]\n\t}\n\t// ...\n}\n```\n\n### HMR未启用\n错误信息\n```\n// 如果在 devServer 中开启了 hot 确并未配置 HotModuleReplacementPlugin \n// 浏览器控制台会出现如下报错\nUncaught Error: [HMR] Hot Module Replacement is disabled.\n    at eval (webpack:///(:9000/webpack)/hot/dev-server.js?:7:8)\n    at Object../node_modules/webpack/hot/dev-server.js (main.js:485)\n    at __webpack_require__ (main.js:20)\n    at eval (webpack:///multi_(:9000/webpack)-dev-server/client?:2:1)\n    at Object.0 (main.js:578)\n    at __webpack_require__ (main.js:20)\n    at main.js:84\n    at main.js:87\n```\n\n[参考文档](https://webpack.js.org/guides/hot-module-replacement/)  \n解决方案\n```js\n// webpack.dev.config.js\nconst webpack = require('webpack')\n\nmodule.exports = {\n\t// ...\n\tdevServer: {\n\t\t// ...\n\t\thot: true\n\t},\n\tplugins: [\n\t\t// ...\n\t\tnew webpack.HotModuleReplacementPlugin()\n\t]\n\t// ...\n}\n```\n\n### CSS 中通过 `url(xxx)` 引入的的图片路径不正确\n当我们通过配置使得输出的静态文件放到不同目录下时很容易碰到这个问题  \n例如我们将打包后的文件分别放到js/css/images三个目录下  \n这时如果没有特意配置过的话被 `url-loader` 处理过后的图片引用路径通常会变为 `images/xxx.png`  \n如果是在根目录下的 HTML 中的文件下这样访问图片不会有问题  \n但如果是在 CSS 中的  `url(images/xxx.png)` 则会出现找不到图片的问题  \n因为这种形式的 URL 是一种相对路径  \n而 CSS 文件时放在 css 目录下的，而这个路径下并没有 images 文件夹  \n所以当然找不到正确的图片  \n这时可通过配置 `url-loader` 的 `publicPath` 为相对服务器根目录的相对路径来解决  \n关于 `publicPath` 有如下这些[配置方式](https://webpack.js.org/configuration/output/#output-publicpath)  \n```js\nmodule.exports = {\n\t//...\n\toutput: {\n\t\t// One of the below\n\t\tpublicPath: 'https://cdn.example.com/assets/', // CDN (always HTTPS)\n\t\tpublicPath: '//cdn.example.com/assets/', // CDN (same protocol)\n\t\tpublicPath: '/assets/', // server-relative\n\t\tpublicPath: 'assets/', // relative to HTML page\n\t\tpublicPath: '../assets/', // relative to HTML page\n\t\tpublicPath: '', // relative to HTML page (same directory)\n\t}\n}\n```\n\n## React\n\n\n## 优化\n\n### 关于 `optimization.moduleIds`\nWebpack V4 新引入的这条配置其功能相当于之前的 `xxxModuleIdsPlugin`  \n一共有 `natural/named/hashed/size/total-size` 这五个可选值  \n默认为 `false` 即以一个自增的数字作为 moduleId  \n首先要理解在 Webpack 中 module 的含义就是我们在代码里每一处 `import xx from 'xx'` 中的 xx 模块  \nmoduleId 即是 Webpack 在打包过程中赋予每一个模块的唯一 Id  \n个人认为在开发环境下将其设为 `named` 也就是每个模块的文件路径作为 Id 可以方便 Debug  \n在生产环境下将其设为 `hashed` 避免每次改动都导致所有模块的 Id 发生变化\n\n### 启用 Tree Shaking\nWebpack 提供了 Tree Shaking 的功能  \n帮助我们在打包的过程把无用的代码块移除，进一步减小包的体积  \n在V4中要正确启用这个功能需要确保下列这几点\n* 使用 ES6 的 `import` 以及 `export` 来管理 Module\n* `mode` 设为 `production`\n* 在 `package.json` 中加入 `\"sideEffects\": false` 或者 `\"sideEffects\": [\"*.css\"]` 避免不小心移除样式文件\n* 如果有使用 `@babel/preset-env` 注意在 .babelrc 中将其默认的配置 `\"modules\": \"commonjs\"` \n改为 `\"modules\": false` 也就是说不让 Babel 转义源码中的 ES6 Module 语法\n"},"./src/blogs/WebpackV3ToV4.md":function(n,e){n.exports="# Webpack V3 升级至 V4\n## 序\n半年没关注，最近突然发现 Webpack 的版本已经升到 4.16.2 了，为了紧跟潮流的步伐，决定将项目中使用的 3.10.0 来个升级\n\n## 步骤\n1. 安装`webpack`以及`webpack-cli` Ps: V4 开始将 CLI 抽离到了独立的 `webpack-cli` 项目中维护  \n所以现在需要分别安装俩个依赖\n2. 将项目中所有用到的`loader`以及`plugin`升级到最新\n3. 配置文件里新增 `mode: 'development'` or `mode: 'production'`\n4. 移除`webpack.optimize.UglifyJsPlugin`，现在 webpack 会在生产环境默认对代码进行压缩\n5. 移除`extract-text-webpack-plugin`，v4推荐使用新的`mini-css-extract-plugin`来提取样式文件\n6. 引入`optimize-css-assets-webpack-plugin`以及`uglifyjs-webpack-plugin`，并在生产环境的配置文件下新增\n\n```js\nconst UglifyJsPlugin = require(\"uglifyjs-webpack-plugin\")\nconst OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\")\n\nmodule.exports = {\n\toptimization: {\n\t\tminimizer: [\n\t\t\t// 由于配置optimization会覆盖默认值 所以这里需要配一下UglifyJsPlugin\n\t\t\tnew UglifyJsPlugin({\n\t\t\t\tcache: true,\n\t\t\t\tparallel: true,\n\t\t\t}),\n\t\t\tnew OptimizeCSSAssetsPlugin({})\n\t\t]\n\t}\n}\n```\n7. 搞定\n\n## 总结\n升级过后打包和编译速度大概提升了15%左右（粗略比较）\n\n上述只是针对我之前项目配置的升级，并不完整，仅供参考\n\nWebpack官方有提供详细的迁移[文档](https://webpack.js.org/migrate/4/)\n\n遇到问题也可以通过报错信息很快定位到原因，再去相应的Github库上找一找解决办法，迁移过程还是比较顺利的\n"},"./src/blogs/WhyPreflight.md":function(n,e){n.exports="# 为什么 CORS 需要在跨域请求前进行预校验 (Preflight)\n大家都知道浏览器在发起复杂跨域请求前会先发送一个 `OPTIONS` 请求来进行预校验  \n校验通过后才会正式将携带参数的请求发送给服务器  \n平时谈论的大多是什么情况下会需要预校验  \n不知道大家有没有仔细考虑过浏览器为什么会这么做？  \n不这么做会不会导致什么问题？\n\n下面先来看看 [W3C 协议](https://www.w3.org/TR/cors/#preflight-request) 中的说法：\n> To protect resources against cross-origin requests that could not originate from certain user agents  \nbefore this specification existed a preflight request is made to ensure that the resource is aware of this specification.\n\n光看这段文字可能大家还是一头雾水，下面让我们用一个例子来更加形象的描述一下这个问题  \n假设浏览器并不会发送预检验（Preflight）请求，而是直接发送正式请求来判断是否允许跨域  \n我们向服务器发送一个跨域的 `DELETE` 请求 `https://www.a.com/deleteuser?id=123` 来删除一个用户  \n\n## 服务端正确设置了 CORS\n\n这种情况下无论是否先发起预检验请求都没有问题  \n假设不发送，服务器也可以直接根据正式请求的来源域以及请求头来判断是否接受该跨域请求  \n未通过则返回告诉浏览器不允许该跨域请求  \n反之请求通过了跨域校验则继续按正常流程处理  \n\n## 服务端未正确设置 CORS\n\n比如服务端使用的仍是在 CORS 出现前开发的代码  \n这个时候如果浏览器不做预检验，直接将真实请求发至服务器来判断是否满足跨域条件  \n服务器接受到了如上的 `DELETE` 请求，由于并未设置过 CORS  \n也就是说服务器会默认浏览器发来的请求都是满足同源策略的  \n便直接将该请求当作普通请求进行处理  \n在这种情况下浏览器的同源策略就不攻自破了\n\n## 预检验请求为什么能解决这个问题 \n\n大家都知道，预检验请求是一个不携带任何具体参数的 `OPTIONS` 请求  \n采用 CORS 的服务器会正确的根据请求头来判断是否接受该跨域请求，并返回相应的响应告知浏览器  \n未采用的服务器接受到请求也会正常处理  \n但是返回的响应中不会正确的包含 Access-Control-Allow-* 等响应头   \n浏览器接收到预检验请求的响应后会根据响应头来判断是否支持跨域  \n只有当响应头满足 CORS 的相关设置才会继续发送正式的跨域请求\n"},"./src/blogs/XSS&CSRF.md":function(n,e){n.exports='# 关于 XSS 以及 CSRF\n\n## XSS (Cross-Site Scripting)\n\n### 攻击原理\n利用网站对用户输入的信任进行攻击  \n假设一个博客网站将用户的输入不经转义直接存入数据库，又原封不动的将数据库的内容插入页面中展示  \n这时候如果恶意用户在发布的一篇博文中加入了的一串脚本代码\n```html\n博客正文内容...\n<script>\n// 恶意脚本 窃取用户信息 跳转恶意网站 修改页面显示内容\n<\/script>\n```\n当其余用户浏览该篇博文时，由于未经过任何转义，恶意脚本和正文一起被插入页面的 DOM 节点中  \n脚本中的代码随即被浏览器加载执行，也就形成了一次 XSS 攻击\n\n### 防范方法\n不信任任何用户的输入，对所有用户输入进行转义后才存入数据库  \n所有用户输入的内容先进行转义再插入相应 DOM 节点  \nReact/Vue/Angular 等前端框架大多都默认进行了转义处理  \n例如在 React 中需要使用 `dangerouslySetInnerHTML={}` Vue 中需要使用 `v-html` 来插入未转义的内容  \n这些默认行为有时会使得开发者忽视掉防范 XSS 攻击，只要足够小心这类攻击其实可以被完全杜绝  \n此外，将 Cookie 设为 `HttpOnly` 可以阻止进行 XSS 攻击的恶意脚本获取存储在 Cookie 中的敏感信息\n\n## CSRF (Cross-Site Request Forgery)\n\n### 攻击原理\n假设用户在登录了 `www.bank.com` 的同时打开了 `www.evil.com`  \n而攻击者恰好知道转账的接口为 `http://www.bank.com/transfer?to=AcountId&amount=99999`  \n这时候攻击者在 `www.evil.com` 的页面上隐藏了一个标签 `<img src="www.bank.com/transfer?to=AcountId&amount=99999" style="display: none">`  \n如果银行网站恰好仅仅简单的利用 Cookie 进行用户校验（当然大部分情况下银行网站不会这么傻）  \n由于 `<img>` 的 `src` 属性可以绕开 Same-Origin Policy 的限制进行跨域请求  \n所以这个 GET 请求会正确发送并且携带上用户登录信息的相关 Cookie ，成功将钱转到了攻击者的账号  \n\n### 防范方法\n* 合理的设计 API ，GET 请求不应该进行会造成 Side Effect 的操作\n* 利用 CSRF-Token 在每次请求时需要携带 Token 来校验权限\n* 在进行转账、支付等危险操作时需要再次输入密码（像支付宝、银行等应用的密码就会分为登录密码和付款密码）\n'},"./src/components/Blog/index.jsx":function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),r=E(t("./node_modules/react/index.js")),s=E(t("./node_modules/iscroll/build/iscroll.js")),a=E(t("./src/components/Markdown/index.jsx")),i=E(t("./src/blogs/WebpackBaseConfig.md")),c=E(t("./src/blogs/GulpPlugin.md")),l=E(t("./src/blogs/Symbol.md")),u=E(t("./src/blogs/Iterator.md")),d=E(t("./src/blogs/WebpackV3ToV4.md")),p=E(t("./src/blogs/Generator.md")),m=E(t("./src/blogs/ArrayAPI.md")),f=E(t("./src/blogs/ObjectAPI.md")),b=E(t("./src/blogs/Collections.md")),g=E(t("./src/blogs/Promise.md")),h=E(t("./src/blogs/PreventModalScroll.md")),y=E(t("./src/blogs/Redux.md")),x=E(t("./src/blogs/ReactRedux.md")),S=E(t("./src/blogs/BinaryTreeTraversal.md")),j=E(t("./src/blogs/SourceMapAndWebpack.md")),w=E(t("./src/blogs/WebpackCommonProblem.md")),v=E(t("./src/blogs/CrossOrigin.md")),P=E(t("./src/blogs/CookieAndWebStorage.md")),R=E(t("./src/blogs/XSS&CSRF.md")),k=E(t("./src/blogs/Ajax.md")),A=E(t("./src/blogs/BinaryTreeType.md")),C=E(t("./src/blogs/ArraySort.md")),O=E(t("./src/blogs/WhyPreflight.md")),M=E(t("./src/blogs/VueVsReact.md")),T=E(t("./src/blogs/Axios.md"));function E(n){return n&&n.__esModule?n:{default:n}}t("./src/components/Blog/style.less");var L=[T.default,M.default,O.default,C.default,A.default,k.default,R.default,P.default,v.default,w.default,j.default,S.default,x.default,y.default,h.default,g.default,b.default,f.default,m.default,p.default,d.default,u.default,l.default,c.default,i.default],q=function(n){function e(){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e);var n=function(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return n.switch=function(e){window.innerWidth>=1024?(n.setState({moveout:!0}),setTimeout(function(){n.setState({nowReading:e,moveout:!1})},500)):n.setState({nowReading:e})},n.state={categories:L.map(function(n){return{name:n.slice(2,n.indexOf("\n"))}}),nowReading:0,showCategory:!1},n}return function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}(e,r.default.Component),o(e,[{key:"componentDidMount",value:function(){window.innerWidth>=1024&&setTimeout(function(){return new s.default(document.getElementById("category"),{mouseWheel:!0,scrollbars:!0,fadeScrollbars:!0})})}},{key:"render",value:function(){var n=this;return r.default.createElement("div",{className:"blogs"},L.map(function(e,t){return t===n.state.nowReading&&r.default.createElement("div",{className:n.state.moveout?"blog out":"blog",key:t},r.default.createElement(a.default,{data:e}))}),r.default.createElement("div",{id:"category",className:this.state.showCategory?"category-box show":"category-box"},r.default.createElement("ul",{className:"blogs-category"},this.state.categories.map(function(e,t){return r.default.createElement("li",{key:t,onClick:function(){return n.switch(t)}},e.name)}))),r.default.createElement("div",{className:this.state.showCategory?"category-toggle show":"category-toggle",onClick:function(){return n.setState(function(n){return{showCategory:!n.showCategory}})}}))}}]),e}();e.default=q},"./src/components/Blog/style.less":function(n,e,t){},"./src/components/Markdown/index.jsx":function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=l(t("./node_modules/react/index.js")),r=l(t("./node_modules/marked/lib/marked.js")),s=l(t("./node_modules/highlight.js/lib/highlight.js")),a=l(t("./node_modules/highlight.js/lib/languages/javascript.js")),i=l(t("./node_modules/highlight.js/lib/languages/css.js")),c=l(t("./node_modules/highlight.js/lib/languages/xml.js"));function l(n){return n&&n.__esModule?n:{default:n}}t("./node_modules/highlight.js/styles/github.css"),t("./src/components/Markdown/style.less"),s.default.registerLanguage("javascript",a.default),s.default.registerLanguage("css",i.default),s.default.registerLanguage("xml",c.default),r.default.setOptions({highlight:function(n){return s.default.highlightAuto(n).value}}),e.default=function(n){return o.default.createElement("div",{className:"my-md",dangerouslySetInnerHTML:{__html:(0,r.default)(n.data)}})}},"./src/components/Markdown/style.less":function(n,e,t){}}]);