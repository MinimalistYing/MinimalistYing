<!DOCTYPE html><html><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0">
	<meta name="baidu-site-verification" content="e7Xf8PjkZ4">
	<meta name="description" content="小影子的博客，记录工作经验，分享前端技术~">
	<meta name="keyword" content="博客 前端 技术 Blog FrontEnd Experience">
	<title>MinimalistYing.io</title>
	<script charset="utf-8" src="https://hmcdn.baidu.com/static/tongji/plugins/UrlChangeTracker.js"></script><script src="https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb"></script><script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb";
			var s = document.getElementsByTagName("script")[0]; 
			s.parentNode.insertBefore(hm, s);
		})();
	</script>
<link rel="shortcut icon" href="favicon.ico"><link href="main.ba348b966d7b4dc69e1d.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="0.34dc1d228a2b3001916f.css"><script charset="utf-8" src="0.9d82b534399ca40448c9.bundle.js"></script><script charset="utf-8" src="5.4749751c69454854f14e.bundle.js"></script><link rel="stylesheet" type="text/css" href="2.721caad03960dfd5486b.css"><script charset="utf-8" src="2.eb5aa1b17eba139d4749.bundle.js"></script></head>
<body>
	<div id="app"><div><header><h3 class="header-title">MinimalistYing.io</h3><nav><ul><li><a href="/index.html">博客</a></li><li><a href="/memo.html">备忘</a></li><li><a href="https://codepen.io/MinimalistYing" target="_blank">代码库</a></li><li><a href="https://leetcode.com/MinimalistYing" target="_blank">Leetcode</a></li><li><a href="https://stackoverflow.com/users/8459774/minimalistying" target="_blank">StackOverflow</a></li><li><a href="https://github.com/MinimalistYing" target="_blank">Github</a></li></ul></nav></header><div class="blogs"><div class="blog"><div class="my-md"><h1 id="-css-cascading-style-sheets-">浅谈 CSS（Cascading Style Sheets) 之层叠</h1>
<p>对页面上的每一个元素来说，通常会有很多样式应用于其上<br>但是一个元素不可能背景色既是红色又是绿色<br>所以当样式定义发生冲突时浏览器会通过如下规则来判断最终采取哪条规则来渲染元素  </p>
<ol>
<li>重要性 Importance</li>
<li>特殊性 Specificity</li>
<li>先后顺序 Order</li>
</ol>
<p>整个过程就称为样式的层叠 (Cascade)</p>
<h2 id="-">重要性</h2>
<p>重要规则（包含关键字 <code>!important</code>）优先于普通规则<br>例如页面包含如下样式  </p>
<pre><code class="language-css"><span class="hljs-selector-tag">p</span> { <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span> }</code></pre>
<p>那么无论你在何处以什么样的选择器去定义另外的 <code>color</code> 只要不使用 <code>!important</code> 段落的字体颜色最终都是红色  </p>
<p>如果是俩条重要规则发生冲突呢 ？<br>首先根据来源判断：读者定义的重要规则 &gt; 开发人员定义的重要规则  </p>
<p>如果把普通规则也加入排序的话：<br>读者定义的重要规则 &gt; 开发人员定义的重要规则 &gt; 开发人员定义的普通规则 &gt; 读者定义的普通规则 &gt; 浏览器默认规则  </p>
<p>如果俩条重要规则的来源相同呢 ？<br>那么先考虑特殊性（下文会讲）：特殊性高 &gt; 特殊性低  </p>
<p>如果特殊性也一致呢 ？<br>考虑规则在样式表中的先后顺序 ： 后定义 &gt; 先定义</p>
<p>Ps: 通常来说不建议使用 <code>!important</code> 除非你需要覆盖一些不受你控制的内联样式</p>
<h2 id="-">特殊性</h2>
<p>特殊性通常是针对选择器而言<br>首先我们定义 <code>0 0 0 0</code> 的特殊性最低<br><code>0 1 0 0</code> 的特殊性比 <code>0 0 2 0</code> 要高<br><code>0 0 2 0</code> 的特殊性比 <code>0 0 0 3</code> 要高  </p>
<p>内联样式没有选择器 特殊性永远为 <code>1 0 0 0</code><br>所以内联样式比所有定义在外部样式表中的样式特殊性都要高<br>规则中每出现一个 ID 选择期特殊性增加 <code>0 1 0 0</code><br>每出现一个类选择器/伪类选择器/属性选择器特殊性增加 <code>0 0 1 0</code><br>每出现一个元素选择器/伪元素选择器增加 <code>0 0 0 1</code><br>连接符/通配符特殊性为 <code>0 0 0 0</code><br>继承而来的规则没有特殊性  </p>
<p>Ps: 需要特别注意的一点是特殊性为 <code>0 0 0 0</code> 和没有特殊性是不一样的<br>简单来讲就是通配符设置的样式会覆盖掉元素继承而来的样式，这点很容易导致问题，所以通常不建议使用通配符来设置页面样式</p>
<p>下面举几个例子来更好的理解特殊性，有如下 HTML</p>
<pre><code class="language-html">&lt;div id=<span class="hljs-string">"box"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"parent"</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"content"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"son"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
&lt;<span class="hljs-regexp">/div&gt;</span></code></pre>
<p>又有如下几组样式</p>
<pre><code class="language-css"><span class="hljs-comment">/* 0 1 0 0 */</span>
<span class="hljs-selector-id">#content</span> {
  <span class="hljs-attribute">background</span>: red;
}
<span class="hljs-comment">/* 0 0 1 1 */</span>
<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.son</span> {
  <span class="hljs-attribute">background</span>: green;
}</code></pre>
<p>由于 <code>0 1 0 0</code> 的特殊性比 <code>0 0 1 1</code> 高，所以背景色为红色</p>
<pre><code class="language-css"><span class="hljs-comment">/* 0 2 0 0 */</span>
<span class="hljs-selector-id">#box</span> &gt; <span class="hljs-selector-id">#content</span> {
  <span class="hljs-attribute">background</span>: green;
}
<span class="hljs-comment">/* 0 1 2 1 */</span>
<span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.parent</span> &gt; <span class="hljs-selector-id">#content</span><span class="hljs-selector-attr">[class^=s]</span> {
  <span class="hljs-attribute">background</span>: red;
}</code></pre>
<p>由于 <code>0 2 0 0</code> 的特殊性比 <code>0 1 2 1</code> 要高，所以背景色为绿色</p>
<pre><code class="language-css"><span class="hljs-comment">/* 0 0 1 0 */</span>
<span class="hljs-selector-class">.parent</span> {
  <span class="hljs-attribute">background</span>: green;
}
<span class="hljs-comment">/* 0 0 1 1 */</span>
<span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:hover</span> {
  <span class="hljs-attribute">background</span>: red;
}</code></pre>
<p>由于 <code>0 0 1 1</code> 的特殊性比 <code>0 0 1 0</code> 要高，所以在鼠标 hover 时背景色会变为红色</p>
<h1 id="-">先后顺序</h1>
<p>如果一条规则的重要性/来源/特殊性都一致，则在样式表中越靠后出现的声明优先级越高</p>
<h1 id="-">总结</h1>
<p>对于作用于同一元素的任意俩条规则，想要判断哪条规则最终会生效的话<br>首先比较来源 &gt; 来源相同再比较重要性 &gt; 重要性相同再比较特殊性 &gt; 都相同最后比较先后顺序<br>这样最终总能确认哪一条规则会胜出</p>
</div></div><div id="category" class="category-box"><ul class="blogs-category"><li id="MoesifBug" class="">记一次 Chrome 更新导致插件故障引发的问题</li><li id="Frameworks" class="">关于前端框架选型的一些思考</li><li id="LowDesireSociety" class="">观后感：《低欲望社会》大前研一</li><li id="Cascading" class="selected">浅谈 CSS（Cascading Style Sheets) 之层叠</li><li id="Axios" class="">Axios 源码解析</li><li id="VueVsReact" class="">React 与 Vue 的一些对比</li><li id="WhyPreflight" class="">为什么 CORS 需要在跨域请求前进行预校验 (Preflight)</li><li id="ArraySort" class="">Array.prototype.sort() 在使用默认 CompareFn 时的问题</li><li id="BinaryTreeType" class="">常见的二叉树类型</li><li id="Ajax" class="">Ajax (Asynchronous JavaScript And XML)</li><li id="XSSCSRF" class="">关于 XSS 以及 CSRF</li><li id="CookieAndWebStorage" class="">Cookie 和 WebStorage</li><li id="CrossOrigin" class="">关于跨域</li><li id="WebpackCommonProblem" class="">记录配置 Webpack 过程中碰到的问题以及解决方案</li><li id="SourceMapAndWebpack" class="">关于 Source Map 以及 Webpack 中 Devtool 的相关配置</li><li id="BinaryTreeTraversal" class="">二叉树的遍历</li><li id="ReactRedux" class="">React-Redux 从入门到后悔</li><li id="Redux" class="">Redux 从入门到放弃</li><li id="PreventModalScroll" class="">如何阻止模态框 (Modal / Popup / Dialog) 弹出后 Body 可滚动</li><li id="PromiseBlog" class="">Promise In ES6</li><li id="Collections" class="">New Collections In ES6</li><li id="ObjectAPI" class=""> Object's New API In ES6</li><li id="ArrayAPI" class="">Array's New API In ES6</li><li id="Generator" class="">Generator in ES6</li><li id="WebpackV3ToV4" class="">Webpack V3 升级至 V4</li><li id="IteratorBlog" class="">Iterator in ES6</li><li id="SymbolBlog" class="">Symbols in ES6</li><li id="GulpPlugin" class="">如何编写一个自己的GulpPlugin</li><li id="WebpackBaseConfig" class="">Webpack(v3.8.1)</li></ul></div><div class="category-toggle"></div></div></div></div>
<script type="text/javascript" src="main.84657a3601e9c5baddaf.js"></script>
</body></html>