<!DOCTYPE html><html><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0">
	<meta name="baidu-site-verification" content="e7Xf8PjkZ4">
	<meta name="description" content="小影子的博客，记录工作经验，分享前端技术~">
	<meta name="keyword" content="博客 前端 技术 Blog FrontEnd Experience">
	<title>MinimalistYing.io</title>
	<script charset="utf-8" src="https://hmcdn.baidu.com/static/tongji/plugins/UrlChangeTracker.js"></script><script src="https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb"></script><script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb";
			var s = document.getElementsByTagName("script")[0]; 
			s.parentNode.insertBefore(hm, s);
		})();
	</script>
<link rel="shortcut icon" href="favicon.ico"><link href="main.ba348b966d7b4dc69e1d.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="0.ef1bd9dbce806a540650.css"><script charset="utf-8" src="0.e3fc404a03ea51474c0f.bundle.js"></script><script charset="utf-8" src="5.4749751c69454854f14e.bundle.js"></script><link rel="stylesheet" type="text/css" href="2.41696c5507cad7d5f341.css"><script charset="utf-8" src="2.510b9aa996f2336192b4.bundle.js"></script></head>
<body>
	<div id="app"><div><header><h3 class="header-title">MinimalistYing.io</h3><nav><ul><li><a href="/index.html">博客</a></li><li><a href="/memo.html">备忘</a></li><li><a href="https://codepen.io/MinimalistYing" target="_blank">代码库</a></li><li><a href="https://leetcode.com/MinimalistYing" target="_blank">Leetcode</a></li><li><a href="https://stackoverflow.com/users/8459774/minimalistying" target="_blank">StackOverflow</a></li><li><a href="https://github.com/MinimalistYing" target="_blank">Github</a></li></ul></nav></header><div class="blogs"><div class="blog"><div class="my-md"><h1 id="symbols-in-es6">Symbols in ES6</h1>
<p><code>Symbol</code>是 ES6 (时隔多年) 新增的一种 <strong>primitive type</strong> ，可以把它看做一种自动生成 <strong>唯一字符串</strong> 的机制，它的真实值在代码中无法直接获得</p>
<h2 id="-symbol">如何生成 Symbol</h2>
<pre><code class="language-js"><span class="hljs-comment">// 最基础的方式</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-built_in">Symbol</span>()

<span class="hljs-comment">// 可以传入一串描述该 Symbol 用途的字符串作为参数</span>
<span class="hljs-keyword">const</span> b = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'some description text'</span>)

<span class="hljs-comment">// 从全局的 Symbol 库中查询所需的结果</span>
<span class="hljs-comment">// 如果未找到则新建一个并返回</span>
<span class="hljs-comment">// 这种方式较以上直接构造 Symbol 的优点在于</span>
<span class="hljs-comment">// 可以不必在外部作用域中专门维护一个变量用于存储生成的 Symbol</span>
<span class="hljs-keyword">const</span> c = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'my Symbol'</span>)

<span class="hljs-comment">// 由于 Symbol 全局存在</span>
<span class="hljs-comment">// 为了尽量避免命名冲突 可以在描述中添加前缀</span>
<span class="hljs-keyword">const</span> d = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'prefix.Symbol'</span>)</code></pre>
<h2 id="-symbol">如何判断一个值是否为 Symbol</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> sym = <span class="hljs-built_in">Symbol</span>()
<span class="hljs-comment">// 推荐方式</span>
<span class="hljs-keyword">typeof</span> sym === <span class="hljs-string">'symbol'</span><span class="hljs-comment">// true</span>

<span class="hljs-comment">// 并不是一种类与实例化对象的关系 无法通过以下方法判断</span>
sym <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Symbol</span> <span class="hljs-comment">// false</span></code></pre>
<h2 id="-symbol-">如何获取 Symbol 的描述</h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'desc a'</span>)
<span class="hljs-keyword">const</span> b = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'desc b'</span>)

<span class="hljs-built_in">Symbol</span>.keyFor(a) <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">Symbol</span>.keyFor(b) <span class="hljs-comment">// desc b</span>

a.toString() <span class="hljs-comment">// Symbol(desc a)</span>
b.toString() <span class="hljs-comment">// Symbol(desc b)</span></code></pre>
<p>通过上述对比，个人感觉用 <code>Symbol.for()</code> 来生成 <code>Symbol</code> 好像更加合适<br>不仅可以少声明一个变量，并且能更方便的获得其描述</p>
<h2 id="symbol-">Symbol 的使用场景</h2>
<p>借助 <code>Symbol</code> 来实现单例模式</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> Instance = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'instance'</span>)
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">singleton</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (singleton[Instance]) {
        <span class="hljs-keyword">return</span> singleton[Instance]
    }

    <span class="hljs-keyword">return</span> singleton[Instance] = {}
}
<span class="hljs-keyword">const</span> a = singleton()
<span class="hljs-keyword">const</span> b = singleton()
a === b <span class="hljs-comment">// true</span></code></pre>
<p>如果将上例中的 Symbol 替换成任意一个 Magic String 对逻辑的实现并无影响<br>所以从个人经验来看 暂时还未碰到有必须要使用 Symbol 的场景  </p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o = {
    <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,
    [<span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'bar'</span>)]: <span class="hljs-number">2</span>
}
<span class="hljs-built_in">Object</span>.getOwnPropertyNames(o) <span class="hljs-comment">// ['foo']</span>
<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(o) <span class="hljs-comment">// [Symbol(for)]</span>
<span class="hljs-built_in">Object</span>.keys(o) <span class="hljs-comment">// ['foo']</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> o ){
    <span class="hljs-built_in">console</span>.log(key) <span class="hljs-comment">// 'foo'</span>
}</code></pre>
<p>可以看到，虽然 Symbol 作为对象的 key 不会被当作普通的键值被遍历<br>但还是可以通过 <code>Object.getOwnPropertySymbols()</code> 来获得<br>所以通过 Symbol 并不能实现私有属性的需求</p>
<h2 id="built-in-symbols">Built-in Symbols</h2>
<p>个人认为 ES6 自身提供的 Built-in Symbols 可能才是最常见的使用方式，例如 <code>Symbol.iterator</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
arr[<span class="hljs-built_in">Symbol</span>.iterator] <span class="hljs-comment">// native function</span>
<span class="hljs-keyword">const</span> it = arr[<span class="hljs-built_in">Symbol</span>.iterator]() <span class="hljs-comment">// 获得数组的 Iterator</span></code></pre>
<p>值得一提的是这些内部的 Symbol 并不是像自定义的那样注册到全局库中<br>而是作为 Symbol 构造函数的静态属性存在</p>
</div></div><div id="category" class="category-box"><ul class="blogs-category"><li id="MongoTooManyOpenFiles" class="">记一次解决 MongoDB Too Many Open Files 报错的心路历程</li><li id="MoesifBug" class="">记一次 Chrome 更新导致插件故障引发的问题</li><li id="Frameworks" class="">关于前端框架选型的一些思考</li><li id="LowDesireSociety" class="">观后感：《低欲望社会》大前研一</li><li id="Cascading" class="">浅谈 CSS（Cascading Style Sheets) 之层叠</li><li id="Axios" class="">Axios 源码解析</li><li id="VueVsReact" class="">React 与 Vue 的一些对比</li><li id="WhyPreflight" class="">为什么 CORS 需要在跨域请求前进行预校验 (Preflight)</li><li id="ArraySort" class="">Array.prototype.sort() 在使用默认 CompareFn 时的问题</li><li id="BinaryTreeType" class="">常见的二叉树类型</li><li id="Ajax" class="">Ajax (Asynchronous JavaScript And XML)</li><li id="XSSCSRF" class="">关于 XSS 以及 CSRF</li><li id="CookieAndWebStorage" class="">Cookie 和 WebStorage</li><li id="CrossOrigin" class="">关于跨域</li><li id="WebpackCommonProblem" class="">记录配置 Webpack 过程中碰到的问题以及解决方案</li><li id="SourceMapAndWebpack" class="">关于 Source Map 以及 Webpack 中 Devtool 的相关配置</li><li id="BinaryTreeTraversal" class="">二叉树的遍历</li><li id="ReactRedux" class="">React-Redux 从入门到后悔</li><li id="Redux" class="">Redux 从入门到放弃</li><li id="PreventModalScroll" class="">如何阻止模态框 (Modal / Popup / Dialog) 弹出后 Body 可滚动</li><li id="PromiseBlog" class="">Promise In ES6</li><li id="Collections" class="">New Collections In ES6</li><li id="ObjectAPI" class=""> Object's New API In ES6</li><li id="ArrayAPI" class="">Array's New API In ES6</li><li id="Generator" class="">Generator in ES6</li><li id="WebpackV3ToV4" class="">Webpack V3 升级至 V4</li><li id="IteratorBlog" class="">Iterator in ES6</li><li id="SymbolBlog" class="selected">Symbols in ES6</li><li id="GulpPlugin" class="">如何编写一个自己的GulpPlugin</li><li id="WebpackBaseConfig" class="">Webpack(v3.8.1)</li></ul></div><div class="category-toggle"></div></div></div></div>
<script type="text/javascript" src="main.8b767b8c1b3254221f2d.js"></script>
</body></html>