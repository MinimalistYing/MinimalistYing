<!DOCTYPE html><html><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0">
	<meta name="baidu-site-verification" content="e7Xf8PjkZ4">
	<meta name="description" content="小影子的博客，记录工作经验，分享前端技术~">
	<meta name="keyword" content="博客 前端 技术 Blog FrontEnd Experience">
	<title>MinimalistYing.io</title>
	<script charset="utf-8" src="https://hmcdn.baidu.com/static/tongji/plugins/UrlChangeTracker.js"></script><script src="https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb"></script><script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb";
			var s = document.getElementsByTagName("script")[0]; 
			s.parentNode.insertBefore(hm, s);
		})();
	</script>
<link rel="shortcut icon" href="favicon.ico"><link href="main.da41f8ae8d650f389d21.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="0.ef1bd9dbce806a540650.css"><script charset="utf-8" src="0.e3fc404a03ea51474c0f.bundle.js"></script><script charset="utf-8" src="5.4749751c69454854f14e.bundle.js"></script><link rel="stylesheet" type="text/css" href="2.41696c5507cad7d5f341.css"><script charset="utf-8" src="2.510b9aa996f2336192b4.bundle.js"></script></head>
<body>
	<div id="app"><div><header><h3 class="header-title">MinimalistYing.io</h3><nav><ul><li><a href="/index.html">博客</a></li><li><a href="/memo.html">备忘</a></li><li><a href="https://codepen.io/MinimalistYing" target="_blank">代码库</a></li><li><a href="https://leetcode.com/MinimalistYing" target="_blank">Leetcode</a></li><li><a href="https://stackoverflow.com/users/8459774/minimalistying" target="_blank">StackOverflow</a></li><li><a href="https://github.com/MinimalistYing" target="_blank">Github</a></li></ul></nav></header><div class="blogs"><div class="blog"><div class="my-md"><h1 id="redux-">Redux 从入门到放弃</h1>
<h2 id="-">基本概念</h2>
<p>当我们通过各类MVVM框架(React / Vue / Angular)开发复杂的单页应用(SPA)时<br>随之而来碰到的问题是对应用中各种状态的管理<br>每个组件都有各自的状态，当任意一个组件的状态发生变更，同时也可能需要触发另一个组件状态的变更<br>当这种耦合关系越来越多的时候，我们会发现很难去寻找一个状态发生变更的原由<br>并且当组件层级过深时，一层层的在组件间传递 props 也显得颇为繁琐<br>Redux 的出现给开发者提供了一种更优雅的管理前端应用状态的解决方案<br>当然相应的代价是需要引入一些冗余的语法( boilerplate )<br>Redux 的核心是以下三个原则:  </p>
<ul>
<li>Single source of truth: 每个 Redux App 应该只有一个全局唯一的 Store</li>
<li>State is read-only: Store 中存储的状态只能通过 Dispatch Action 来进行修改<br>这样通过一些工具开发者可以很清楚的看到状态发生变更的时机以及每次所发生的改变<br>甚至进行 Time Travel 来回到某个 Action 执行前的状态<br>亦或是再次重新提交这个 Action 来观察其行为对应用的影响  </li>
<li>Changes are made with pure functions: Reducer 是 Pure Function  </li>
</ul>
<h3 id="actions">Actions</h3>
<p>不同于直接去修改应用的状态，例如 React 中的 <code>this.setState()</code><br>Redux 推崇通过 Dispacth Action 来修改状态<br>Action 是一个携带了操作类型以及具体数据的简单对象( Plain Object )  </p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> action = {
    <span class="hljs-comment">// 操作类型 用于描述该次操作的用意</span>
    <span class="hljs-comment">// 通常由下划线分隔的大写字符组成</span>
    <span class="hljs-comment">// 当有很多 action 时建议将 type 提取成常量放到单独文件维护</span>
    type: <span class="hljs-string">'ADD_PEOPLE'</span>,
    <span class="hljs-comment">// 具体操作的数据</span>
    people: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'a'</span>
    }
}</code></pre>
<p>以上 Action 中的数据是固定的，可以实现一个 ActionCreator 来根据参数动态的生成 Action  </p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> actionCreator = <span class="hljs-function"><span class="hljs-params">people</span> =&gt;</span> ({
    <span class="hljs-attr">type</span>: <span class="hljs-string">'ADD_PEOPLE'</span>,
    people
})</code></pre>
<p>注意最终还是需要通过 <code>store.dispatch(action)</code> 将 Action 派发至 Reducer 中才能进行应用状态的变更  </p>
<h3 id="reducer">Reducer</h3>
<p>Reducer 用于定义如何根据收到的不同 Action 去改变应用的状态<br>Reducer 应该是一个 Pure Function , 意味着不应该在其中进行由副作用的操作<br>并且当入参相同时其返回值应该总是相同的  </p>
<pre><code class="language-js"><span class="hljs-comment">// 注意需要给我们的应用设置一个初始化的 initalState</span>
<span class="hljs-comment">// 如果未指定 Redux 会开发环境下给出警告</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state = initalState, action</span>) </span>{
    <span class="hljs-keyword">switch</span>(action.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'ADD_PEOPLE'</span>:
            <span class="hljs-keyword">return</span> { ...state, ...{ <span class="hljs-attr">people</span>: action.people } }
        <span class="hljs-comment">// 在遇到未知的 Action 时需要将原先的 state 直接返回</span>
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> state
    }
}</code></pre>
<h3 id="store">Store</h3>
<p>每一个应用都只能有一个唯一的 Store<br>通过 <code>createStore(reducers)</code> 来生成<br>用于维护应用的所有 State ，以及提供一些静态方法用于改变、获取当前状态  </p>
<pre><code class="language-js">store.getState() <span class="hljs-comment">// 获取当前状态</span>
store.dispatch(action) <span class="hljs-comment">// 提交action来改变当前状态</span>
<span class="hljs-keyword">const</span> unsubscribe = store.subscribe(listener) <span class="hljs-comment">// 监听事件</span>
unsubscribe() <span class="hljs-comment">// 取消监听</span></code></pre>
<h2 id="-v4-0-0-">进阶以及源码(v4.0.0)</h2>
<p>为了看起来更加精简，本文仅仅会对一些核心代码进行分析<br>所以展示的只是不完整的代码片段，例如一些校验性质的代码就会被省略</p>
<h3 id="middleware">Middleware</h3>
<p>Redux 的中间件使开发者可以在每次 <code>dispatch(action)</code> 前后加上一些特定的逻辑<br>例如 logging/routing 等，中间件的写法如下  </p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> middleware = <span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> next =&gt; <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> {
    <span class="hljs-comment">// 在dispatch前执行的逻辑</span>
    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">const</span> result = next(action)

    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// 在dispatch完成后执行的逻辑</span>
    <span class="hljs-keyword">return</span> result
}</code></pre>
<h3 id="compose-js">compose.js</h3>
<p>在 Redux 的 applyMiddleware 中会用到，函数式编程中常见<br>可以将传入的函数从右至左依次执行<br>并且每个函数执行的结果会作为下一个函数的参数<br>例如 <code>compose(a, b, c)(arg)</code> 执行起来同 <code>a(b(c(arg)))</code></p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">...funcs</span>) </span>{
    <span class="hljs-comment">// 如果没有传入任何参数 则直接返回一个会将第一个参数返回的函数</span>
    <span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> arg
    }

    <span class="hljs-comment">// 如果参数只有一个函数则直接将该函数返回</span>
    <span class="hljs-keyword">if</span> (funcs.lenth === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>]
    }

    <span class="hljs-comment">// 关于 Array.prototype.reduce </span>
    <span class="hljs-comment">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce</span>
    <span class="hljs-keyword">return</span> funcs.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))
}

----------- 下面都是分析  --------------

<span class="hljs-comment">// 我们来试试 funcs.reduce 是如何来实现逻辑的</span>
<span class="hljs-keyword">const</span> first = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)
<span class="hljs-keyword">const</span> second = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)
<span class="hljs-keyword">const</span> third = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)
<span class="hljs-keyword">const</span> funcs = [first, second, third]

<span class="hljs-comment">// 分解开来看</span>
<span class="hljs-comment">// 第一次 reduce 相当于</span>
<span class="hljs-comment">// (first, second) =&gt; (...args) =&gt; first(second(...args))</span>
<span class="hljs-comment">// 其返回结果是</span>
<span class="hljs-comment">// (...args) =&gt; first(second(...args))</span>
<span class="hljs-comment">// 第二次 reduce 执行时的 accumulator 及第一次的返回结果</span>
<span class="hljs-comment">// 所以 (accumulator, third) =&gt; (...args) =&gt; accumulator(third(...args))</span>
<span class="hljs-comment">// 返回结果是 </span>
<span class="hljs-comment">// (...args) =&gt; accumulator(third(...args))</span>
<span class="hljs-comment">// 将 accumulator 替换后就相当于</span>
<span class="hljs-comment">// (...args) =&gt; first(second(third(...args))</span>
<span class="hljs-keyword">const</span> re = funcs.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))

<span class="hljs-comment">// 上述代码中有一个地方要理解一下</span>
<span class="hljs-comment">// const test = (...args) =&gt; f(...args)</span>
<span class="hljs-comment">// 在参数中的...其实起到的是收集的作用，会将我们调用时传入的所有参数放到args这个数组中</span>
<span class="hljs-comment">// 而在 f(...args) 中的...起到的是解构的作用</span>
<span class="hljs-comment">// 又会将 args 数组中的所有元素依次作为参数传到f这个函数中</span>
<span class="hljs-comment">// 假设我们 test(1, 2, 3) 这样调用则其返回结果其实就是 f(1, 2, 3)</span>
<span class="hljs-comment">// 所以这种做法其实就是在我们不确定一个函数入参个数的情况下</span>
<span class="hljs-comment">// 将所有入参原封不动的按照原有顺序传入到调用函数中</span>
<span class="hljs-comment">// 按照老的方式其实就是借助 arguments 来实现</span>
<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">const</span> test = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> f(...args)
<span class="hljs-comment">// Babel 编译后</span>
<span class="hljs-keyword">var</span> test = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> f.apply(<span class="hljs-literal">undefined</span>, <span class="hljs-built_in">arguments</span>)
}

<span class="hljs-comment">// 从上述分析可以得出 re 其实就等同于</span>
<span class="hljs-comment">// (...args) =&gt; first(second(third(...args))</span>
<span class="hljs-comment">// 当我们调用 re() 就等同于</span>
<span class="hljs-comment">// first(second(third())</span>
<span class="hljs-comment">// 所以输出是 3 2 1</span>
re() <span class="hljs-comment">// 3 2 1</span>

<span class="hljs-comment">// 通过对传入函数的特殊处理 可以使这个过程变为正序</span>
<span class="hljs-comment">// Redux 的 middleWare 就是借助这种原理</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-function"><span class="hljs-params">next</span> =&gt;</span> arg =&gt; { <span class="hljs-built_in">console</span>.log(arg); next(<span class="hljs-string">'b'</span>); }
<span class="hljs-keyword">const</span> b = <span class="hljs-function"><span class="hljs-params">next</span> =&gt;</span> arg =&gt; { <span class="hljs-built_in">console</span>.log(arg); next(<span class="hljs-string">'c'</span>); }
<span class="hljs-keyword">const</span> c = <span class="hljs-function"><span class="hljs-params">next</span> =&gt;</span> arg =&gt; { <span class="hljs-built_in">console</span>.log(arg); next(<span class="hljs-string">'d'</span>); }
<span class="hljs-keyword">const</span> d = <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(arg)

<span class="hljs-comment">// 'a' 'b' 'c' 'd'</span>
compose(a,b,c)(d)(<span class="hljs-string">'a'</span>)
<span class="hljs-comment">// 继续分解来看一下 首先是compose(a, b, c)</span>
<span class="hljs-comment">// 从上述分析得出的结论来看也就是等同于</span>
<span class="hljs-comment">// (...args) =&gt; a(b(c(...args)))</span>
<span class="hljs-comment">// 然后是compose(a,b,c)(d) 所以入参为函数d</span>
<span class="hljs-comment">// 也就是等同于a(b(c(d)))</span>
<span class="hljs-comment">// 第一步c(d) 返回 re1 = arg =&gt; {console.log(arg); d('d')}</span>
<span class="hljs-comment">// 第二步b(c(d)) 也就是b(re1) 返回 re2 = arg =&gt; { console.log(arg); re1('c'); }</span>
<span class="hljs-comment">// 第三步a(b(c(d))) 也就是a(re2) 返回 re3 = arg =&gt; { console.log(arg); re2('b'); }</span>
<span class="hljs-comment">// 所以compose(a,b,c)(d) 返回的就是 arg =&gt; { console.log(arg); re2('b'); }</span>
<span class="hljs-comment">// 最后一步compose(a,b,c)(d)('a') 相当于</span>
<span class="hljs-comment">// console.log('a'); re2('b')</span>
<span class="hljs-comment">// 再把所有的结果展开</span>
<span class="hljs-comment">// console.log('a'); console.log('b'); console.log('c'); console.log('d');</span></code></pre>
<h3 id="applymiddleware">applyMiddleware</h3>
<p>对外提供应用中间件的接口</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyMiddleware</span>(<span class="hljs-params">...middlewares</span>) </span>{
    <span class="hljs-comment">// 注意 applyMiddleware 是一个高阶函数</span>
    <span class="hljs-comment">// 返回值是一个入参为 createStore 的函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">createStore</span> =&gt;</span> (...args) =&gt; {
        <span class="hljs-comment">// 当需运用中间件时 createStore 在此处真正执行</span>
        <span class="hljs-keyword">const</span> store = createStore(...args)

        <span class="hljs-comment">// 只提供给中间件有限的 API 而不是全部 store</span>
        <span class="hljs-keyword">const</span> middlewareAPI = {
            <span class="hljs-attr">getState</span>: store.getState,
            <span class="hljs-attr">dispatch</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> dispatch(...args)
        }
        <span class="hljs-comment">// 要注意此时如果在 middleware 中执行 middlewareAPI.dispatch() 会抛出错误</span>
        <span class="hljs-comment">// 由于 Redux 规定 middleware 形如 store =&gt; next =&gt; action =&gt; {} 的函数</span>
        <span class="hljs-comment">// 这样处理过后在 chain 中存放的便是形如 next =&gt; action =&gt; {} 的函数</span>
        <span class="hljs-keyword">const</span> chain = middlewares.map(<span class="hljs-function"><span class="hljs-params">middleware</span> =&gt;</span> middleware(middlewareAPI))
        <span class="hljs-comment">// 这里的 dispatch 是已经实现了中间件逻辑后的 dispatch 方法</span>
        dispatch = compose(...chain)(store.dispatch)

        <span class="hljs-comment">// 这里利用了解构会去重的特性</span>
        <span class="hljs-comment">// 会将 store.dispatch 覆盖为包含中间件逻辑的新 dispatch</span>
        <span class="hljs-keyword">return</span> {
            ...store,
            dispatch
        }
    }
}</code></pre>
<h3 id="utils-isplainobject-js">utils/isPlainObject.js</h3>
<p>该工具函数用于判断一个 Action 是不是 Plain Object<br>所谓的 Plain Object 指的是直接通过 <code>{}</code> 或者 <code>new Object()</code> 生成，原型链上并没有其它对象的 Object</p>
<pre><code class="language-js"><span class="hljs-comment">// 大体上就相当于 Object.getPrototypeOf(obj) === Object.prototype</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPlainObject</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-comment">// 如果对象都不是当然也不是PlainObject</span>
    <span class="hljs-comment">// 这里注意的是 obj === null 这个判断</span>
    <span class="hljs-comment">// 因为在Js中 typeof null === 'object'</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">'object'</span> || obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>

    <span class="hljs-comment">// lodash 中的 isPlainObject 多了这个逻辑</span>
    <span class="hljs-comment">// 主要考虑到这个特殊情况 const o = Object.create(null)</span>
    <span class="hljs-comment">// 此处的o应该也满足条件 isPlainObject(o) // =&gt; true</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getPrototypeOf(obj) === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }

    <span class="hljs-keyword">let</span> proto = obj
    <span class="hljs-comment">// 因为 Object.getPrototypeOf(Object.prototype) === null</span>
    <span class="hljs-comment">// 所以当循环结束时 proto 指向的其实就是Object.prototype</span>
    <span class="hljs-comment">// 也就是说此时的 proto === Object.prototype</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Object</span>.getPrototypeOf(proto) !== <span class="hljs-literal">null</span>) {
        proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(proto)
    }

    <span class="hljs-comment">// 如果传入对象的 prototype 与 Object.prototype 一致</span>
    <span class="hljs-comment">// 则认为该对象是 Plain Object</span>
    <span class="hljs-comment">// 所以最终的判断逻辑其实与 obj.__proto__ === Object.prototype 类似</span>
    <span class="hljs-comment">// 上面的代码更多的是在考虑 edge case</span>
    <span class="hljs-comment">// 至于这里为什么不使用 Object.getPrototypeOf(obj) === Object.prototype</span>
    <span class="hljs-comment">// 可以戳这里 https://github.com/reduxjs/redux/pull/2599#issuecomment-342849867</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getPrototypeOf(obj) === proto
}</code></pre>
<p>Ps: <code>lodash.isPlainObject</code> 逻辑与上述代码基本一致<br>同样是 Redux 的开发者 <em>timdorr</em> 提的 PR</p>
<h3 id="index-js">index.js</h3>
<pre><code class="language-js"><span class="hljs-comment">// ...</span>

<span class="hljs-comment">// 建立一个函数名为 isCrushed 的空函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCrushed</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// 如果当前的环境不是生成环境但采用了压缩过后的代码则提示开发者</span>
<span class="hljs-comment">// 因为压缩混淆后的代码会将函数改变为类似 function f() {} 以减小代码体积</span>
<span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp; 
    <span class="hljs-keyword">typeof</span> isCrushed.name === <span class="hljs-string">'string'</span> &amp;&amp;
    isCrushed.name !== <span class="hljs-string">'isCrushed'</span>
) {
    warning(<span class="hljs-string">'...'</span>)
}

<span class="hljs-comment">// 以下为 Redux 所有对外提供的 API</span>
<span class="hljs-keyword">export</span> {
    createStore,
    combineReducers,
    bindActionCreators,
    applyMiddleware,
    compose,
    __DO_NOT_USE__ActionTypes
}</code></pre>
<h3 id="createstore-js">createStore.js</h3>
<p>Redux 应用的主入口  </p>
<pre><code class="language-js"><span class="hljs-comment">// reducer 必传 通常来讲是我们通过 combineReducers 将所有 ruducer 集成到一起后的主函数</span>
<span class="hljs-comment">// preloaderState 可选 可以传入的应用初始状态</span>
<span class="hljs-comment">// enhancer 可选 也就是 applyMiddleware() 的返回结果</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStore</span>(<span class="hljs-params">reducer, preloadedState, enhancer</span>) </span>{
    <span class="hljs-comment">// 由于 preloadedState 参数是可选的 所以这里考虑的是这么一种情况</span>
    <span class="hljs-comment">// createStore(reducer, applyMiddleware())</span>
    <span class="hljs-comment">// 这样在不传入 preloadedState 时就不用像 createStore(reducer, null, applyMiddleware()) 这样调用</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> preloadedState === <span class="hljs-string">'function'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> enhancer === <span class="hljs-string">'undefined'</span>) {
        enhancer = preloadedState
        preloadedState = <span class="hljs-literal">undefined</span>
    }

    <span class="hljs-comment">// 有传入 enhancer 也就是有使用中间件(applyMiddleware)</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> enhancer !== <span class="hljs-string">'undefined'</span>) {        
        <span class="hljs-comment">// 有使用中间件的话 需要在 applyMiddleware 去 createStore</span>
        <span class="hljs-comment">// applyMiddleware() 返回的是一个形如 createStore =&gt; (...args) =&gt; {} 的函数</span>
        <span class="hljs-comment">// 所以这里会对enhancer(cerateStore)返回的结果再次传入参数(reducer, preloaderState)调用</span>
        <span class="hljs-keyword">return</span> enhancer(createStore)(reducer, preloaderState)
    }

    <span class="hljs-comment">// 利用闭包存储当前的 Reducer</span>
    <span class="hljs-comment">// 这样就稍后才可通过 replaceReducer() 方法替换掉当前使用的 Reducer</span>
    <span class="hljs-keyword">let</span> currentReducer = reducer

    <span class="hljs-comment">// 同上 整个 Redux 应用的状态树都是利用闭包存储的</span>
    <span class="hljs-keyword">let</span> currentState = preloadedState

    <span class="hljs-comment">// 这里要注意 多存了一份当前监听事件函数的备份</span>
    <span class="hljs-keyword">let</span> currentListeners = []
    <span class="hljs-keyword">let</span> nextListeners = currentListeners

    <span class="hljs-comment">// 用于标识当前是否正在执行 dispatch() 操作</span>
    <span class="hljs-keyword">let</span> isDispatching = <span class="hljs-literal">false</span>

    <span class="hljs-comment">// 确保 nextListeners 存的是 currentListeners 的备份 而不是引用</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureCanMutateNextListeners</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (nextListeners === currentListeners) {
            nextListeners = currentListeners.slice()
        }
    }

    <span class="hljs-comment">// 简单的把当前闭包所存储的应用状态返回出去</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getState</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// 正在执行 dispatch 操作时不能获取当前状态</span>
        <span class="hljs-comment">// 因为当前状态可能会被正在执行的 dispatch() 操作改变</span>
        <span class="hljs-keyword">if</span> (isDispatching) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'...'</span>)
        }

        <span class="hljs-keyword">return</span> currentState
    }

    <span class="hljs-comment">// 注册监听事件 在每次 dispath 时都会调用所有注册过的函数</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subscribe</span>(<span class="hljs-params">listener</span>) </span>{
        <span class="hljs-comment">// 正在执行dispatch操作时不允许新注册监听事件</span>
        <span class="hljs-keyword">if</span> (isDispatching) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'...'</span>)
        }

        <span class="hljs-comment">// 这里同样利用了闭包</span>
        <span class="hljs-comment">// 每次调用都会有独立的 isSubscribed 状态</span>
        <span class="hljs-comment">// 与每个 listener 一一对应</span>
        <span class="hljs-keyword">let</span> isSubscribed = <span class="hljs-literal">true</span>

        ensureCanMutateNextListeners()
        nextListeners.push(listener)

        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unsubscribe</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-comment">// 避免重复取消监听 例如</span>
            <span class="hljs-comment">// const off = store.subscribe(...)</span>
            <span class="hljs-comment">// off()</span>
            <span class="hljs-comment">// off()</span>
            <span class="hljs-keyword">if</span> (!isSubscribed) {
                <span class="hljs-keyword">return</span>
            }

            <span class="hljs-comment">// 正在执行 dispatch 操作时不允许取消监听</span>
            <span class="hljs-keyword">if</span> (isDispatching) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'...'</span>)
            }

            <span class="hljs-comment">// 代表这个 listener 已经取消监听了</span>
            isSubscribed = <span class="hljs-literal">false</span>

            ensureCanMutateNextListeners()
            <span class="hljs-comment">// 这里也利用了闭包 先找到当前闭包存储的入参 listerner 在数组中的下标</span>
            <span class="hljs-keyword">const</span> index = nextListeners.indexOf(listener)
            <span class="hljs-comment">// 移除数组中对应下标存储的元素</span>
            nextListeners.splice(index, <span class="hljs-number">1</span>)
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params">action</span>) </span>{
        <span class="hljs-comment">// 阻止开发者在 reducer 中去调用 dispatch</span>
        <span class="hljs-keyword">if</span> (isDispatching) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'...'</span>)
        }

        <span class="hljs-keyword">try</span> {
            isDispatching = <span class="hljs-literal">true</span>
            <span class="hljs-comment">// currentReducer 就是当前 Redux 正在使用的 Reducer</span>
            <span class="hljs-comment">// 将当前状态树和 action 传入 返回经 reducer 处理过后的新状态树</span>
            currentState = currentReducer(currentState, action)
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// 无论 reducer 处理过程中是否出错 都需要更改 flag</span>
            <span class="hljs-comment">// 代表本次 dispatch 操作结束 否则接下来 redux 就没法用了</span>
            isDispatching = <span class="hljs-literal">false</span>
        }

        <span class="hljs-comment">// 这里要注意执行顺序</span>
        <span class="hljs-comment">// 每次 dispatch 都会将当前的 currentListeners 指向 nextListeners</span>
        <span class="hljs-comment">// 所以每次执行的其实都是最新的 nextListeners 当中存储的的监听事件</span>
        <span class="hljs-comment">// 这里就可以理解 ensureCanMutateNextListeners() 的用处</span>
        <span class="hljs-comment">// 每次新增监听或取消监听时都要确保 nextListeners 是 currentListener 的拷贝</span>
        <span class="hljs-comment">// 这样保证在 dispatch 过程中的 currentListerner 不会发生变化</span>
        <span class="hljs-comment">// 例如如果我们在一个 listener 函数中去新 subscribe 或者 unsubscribe</span>
        <span class="hljs-comment">// 都不会立马生效 而是只有等到下一次 dispatch 才会生效</span>
        <span class="hljs-keyword">const</span> listeners = (currentListeners = nextListeners)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) {
            <span class="hljs-comment">// 注意这里的用法 并没有直接像 listeners[i]() 这样调用</span>
            <span class="hljs-comment">// 因为这样的话 listener 中的 this 会指向 listeners 而不是 window</span>
            <span class="hljs-keyword">const</span> listener = listeners[i]
            listener()
        }

        <span class="hljs-comment">// 将传入的 action 原封不动返回</span>
        <span class="hljs-comment">// 感觉基本来说不会用到这个函数的返回值</span>
        <span class="hljs-keyword">return</span> action
    }

    <span class="hljs-comment">// 替换当前正在使用的 Reducer</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceReducer</span>(<span class="hljs-params">nextReducer</span>) </span>{    
        <span class="hljs-comment">// 直接将闭包的存储指向新的 Reducer</span>
        currentReducer = nextReducer
        <span class="hljs-comment">// dispatch 一个 REPLACE Action 来重新生成新的状态树</span>
        dispatch({ <span class="hljs-attr">type</span>: ActionTypes.REPLACE })
    }

    <span class="hljs-comment">// dispatch 一个 INIT Action 初始化生成Redux的状态树</span>
    dispatch({ <span class="hljs-attr">type</span>: ActionTypes.INIT })

    <span class="hljs-comment">// 对外主要就提供了四个 API</span>
    <span class="hljs-keyword">return</span> {
        dispatch,
        subscribe,
        getState,
        replaceReducer,
        [$$observable]: observable <span class="hljs-comment">// 私有的 用于测试 这里不具体展开</span>
    }
}</code></pre>
<h3 id="combinereducer-js">combineReducer.js</h3>
<p>由于在大型应用中我们需要管理一个复杂的状态树<br>如果将所有的 Action 处理逻辑写在同一个 Reducer 中会很难维护<br>所以大多数情况下我们的项目中会有很多个不同的 Reducer 文件<br>而 Redux 的 <code>createStore(reducer)</code> 只接受一个 RootReducer 作为参数<br>所以这个时候就需要借助 Redux 提供的这个工具方法将所有的子 Reducer 合为最终的 RootReducer
其主要作用如下  </p>
<pre><code class="language-js"><span class="hljs-comment">// 应用的状态树</span>
<span class="hljs-keyword">const</span> state = {
    <span class="hljs-attr">a</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">b</span>: <span class="hljs-string">''</span>
}

<span class="hljs-keyword">const</span> reducerA = <span class="hljs-function">(<span class="hljs-params">a, action</span>) =&gt;</span> {}
<span class="hljs-keyword">const</span> reducerB = <span class="hljs-function">(<span class="hljs-params">b, action</span>) =&gt;</span> {}
<span class="hljs-comment">// 自己手动来生成 RootReducer</span>
<span class="hljs-keyword">const</span> rootReducer = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">a</span>: reducerA(state.a, action),
        <span class="hljs-attr">b</span>: reducerB(state.b, action)
    }
}
<span class="hljs-comment">// 借助 combineReducer</span>
<span class="hljs-comment">// 入参中的 key 需要与 state 中的 key 相对应</span>
<span class="hljs-comment">// 子 Reducer 的函数名可以任意 并无影响</span>
<span class="hljs-keyword">const</span> rootReducer = combineReducer({
    <span class="hljs-attr">a</span>: reducerA,
    <span class="hljs-attr">b</span>: reducerB
})</code></pre>
<p>下面看看源码</p>
<pre><code class="language-js"><span class="hljs-comment">// ...</span>

<span class="hljs-comment">// 将多个子 reducer 组合返回一个 root reducer 函数</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combineReducers</span>(<span class="hljs-params">reducers</span>) </span>{
    <span class="hljs-comment">// 拿到入参对象的所有 key</span>
    <span class="hljs-keyword">const</span> reducerKeys = <span class="hljs-built_in">Object</span>.keys(reducers)
    <span class="hljs-keyword">const</span> finalReducers = {}

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; reducerKeys.length; i++) {
        <span class="hljs-keyword">const</span> key = reducerKeys[i]

        <span class="hljs-comment">// 确保 fianalReducers 中的每个 value 都是一个函数</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reducers[key] === <span class="hljs-string">'function'</span>) {
            finalReducers[key] = reducers[key]
        }
    }
    <span class="hljs-keyword">const</span> finalReducerKeys = <span class="hljs-built_in">Object</span>.keys(finalReducers)

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combination</span>(<span class="hljs-params">state = {}, action</span>) </span>{
        <span class="hljs-keyword">let</span> hasChanged = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">const</span> nextState = {}
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; finalReducerKeys.length; i++) {
            <span class="hljs-keyword">const</span> key = finalReducerKeys[i]
            <span class="hljs-keyword">const</span> reducer = finalReducers[key]
            <span class="hljs-keyword">const</span> previouStateForKey = state[key]
            <span class="hljs-keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)
            <span class="hljs-comment">// Reducer 处理过后的状态不能返回为空</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextStateForKey === <span class="hljs-string">'undefined'</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'...'</span>)
            }
            nextState[key] = nextStateForKey
            <span class="hljs-comment">// 判断经 Reducer 处理后的状态前后是否发生变化</span>
            hasChanged = hasChanged || nextStateForKey !== previousStateForKey
        }
        <span class="hljs-comment">// 注意 对于 Redux 而言 整个状态树中只要有一处发生变化 则视为其有过变化</span>
        <span class="hljs-keyword">return</span> hasChanged ? nextState : state
    }
}</code></pre>
<h3 id="bindactioncreators-js">bindActionCreators.js</h3>
<p>在 Redux 中我们需要先生成 <code>Action</code> 然后再将其 <code>dispatch</code> 至 <code>Reducer</code> 来触发状态的改变<br>如果你觉得分俩步操作过于繁琐就可以通过 <code>bindActionCreators</code> 将这俩步操作绑定在一起  </p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindActionCreator</span>(<span class="hljs-params">actionCreator, dispatch</span>) </span>{
    <span class="hljs-comment">// 返回一个函数 执行会先 Create Action  </span>
    <span class="hljs-comment">// 然后 dispatch 这个生成的 Action</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        dispatch(actionCreator.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>))
    }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> bindActionCreators(actionCreators, dispatch) {
    <span class="hljs-comment">// 传入单个 Creator</span>
    <span class="hljs-comment">// 直接返回绑定后的 Creator</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> actionCreators === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> bindActionCreator(actionCreators, dispatch)
    }

    <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(actionCreators)
    <span class="hljs-comment">// 用于存储绑定后的 Creator</span>
    <span class="hljs-keyword">const</span> boundActionCreators = {}
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) {
        <span class="hljs-keyword">const</span> key = keys[i]
        <span class="hljs-keyword">const</span> actionCreator = actionCreators[key]
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> actionCreator === <span class="hljs-string">'function'</span>) {
            <span class="hljs-comment">// 依次绑定每一个 Creator</span>
            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
        }
    }
    <span class="hljs-comment">// 将绑定后的结果返回</span>
    <span class="hljs-keyword">return</span> boundActionCreators
}</code></pre>
</div></div><div id="category" class="category-box"><ul class="blogs-category"><li id="AntdForm" class="">Ant Design 表单的一些进阶使用方式</li><li id="CSSModules" class="">CSS Modules</li><li id="GuiLin" class="">桂林山，阳朔水</li><li id="MongoTooManyOpenFiles" class="">记一次解决 MongoDB 报错的心路历程</li><li id="MoesifBug" class="">记一次 Chrome 更新导致插件故障引发的问题</li><li id="Frameworks" class="">关于前端框架选型的一些思考</li><li id="LowDesireSociety" class="">观后感：《低欲望社会》大前研一</li><li id="Cascading" class="">浅谈 CSS（Cascading Style Sheets) 之层叠</li><li id="Axios" class="">Axios 源码解析</li><li id="VueVsReact" class="">React 与 Vue 的一些对比</li><li id="WhyPreflight" class="">为什么 CORS 需要在跨域请求前进行预校验 (Preflight)</li><li id="ArraySort" class="">Array.prototype.sort() 在使用默认 CompareFn 时的问题</li><li id="BinaryTreeType" class="">常见的二叉树类型</li><li id="Ajax" class="">Ajax (Asynchronous JavaScript And XML)</li><li id="XSSCSRF" class="">关于 XSS 以及 CSRF</li><li id="CookieAndWebStorage" class="">Cookie 和 WebStorage</li><li id="CrossOrigin" class="">关于跨域</li><li id="WebpackCommonProblem" class="">记录配置 Webpack 过程中碰到的问题以及解决方案</li><li id="SourceMapAndWebpack" class="">关于 Source Map 以及 Webpack 中 Devtool 的相关配置</li><li id="BinaryTreeTraversal" class="">二叉树的遍历</li><li id="ReactRedux" class="">React-Redux 从入门到后悔</li><li id="Redux" class="selected">Redux 从入门到放弃</li><li id="PreventModalScroll" class="">如何阻止模态框 (Modal / Popup / Dialog) 弹出后 Body 可滚动</li><li id="PromiseBlog" class="">Promise In ES6</li><li id="Collections" class="">New Collections In ES6</li><li id="ObjectAPI" class=""> Object's New API In ES6</li><li id="ArrayAPI" class="">Array's New API In ES6</li><li id="Generator" class="">Generator in ES6</li><li id="WebpackV3ToV4" class="">Webpack V3 升级至 V4</li><li id="IteratorBlog" class="">Iterator in ES6</li><li id="SymbolBlog" class="">Symbols in ES6</li><li id="GulpPlugin" class="">如何编写一个自己的GulpPlugin</li><li id="WebpackBaseConfig" class="">Webpack(v3.8.1)</li></ul></div><div class="category-toggle"></div></div></div></div>
<script type="text/javascript" src="main.60205f80f3b24de616b7.js"></script>
</body></html>