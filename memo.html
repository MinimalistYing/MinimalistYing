<!DOCTYPE html><html><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0">
	<meta name="baidu-site-verification" content="e7Xf8PjkZ4">
	<meta name="description" content="小影子的博客，记录工作经验，分享前端技术~">
	<meta name="keyword" content="博客 前端 技术 Blog FrontEnd Experience">
	<title>MinimalistYing.io</title>
	<script charset="utf-8" src="https://hmcdn.baidu.com/static/tongji/plugins/UrlChangeTracker.js"></script><script src="https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb"></script><script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb";
			var s = document.getElementsByTagName("script")[0]; 
			s.parentNode.insertBefore(hm, s);
		})();
	</script>
<link rel="shortcut icon" href="favicon.ico"><link href="main.da41f8ae8d650f389d21.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="0.ef1bd9dbce806a540650.css"><script charset="utf-8" src="0.e3fc404a03ea51474c0f.bundle.js"></script><link rel="stylesheet" type="text/css" href="3.88df23c22af9721cc296.css"><script charset="utf-8" src="3.81f4698ea6593acd139f.bundle.js"></script></head>
<body>
	<div id="app"><div><header><h3 class="header-title">MinimalistYing.io</h3><nav><ul><li><a href="/index.html">博客</a></li><li><a class="active" aria-current="page" href="/memo.html">备忘</a></li><li><a href="https://codepen.io/MinimalistYing" target="_blank">代码库</a></li><li><a href="https://leetcode.com/MinimalistYing" target="_blank">Leetcode</a></li><li><a href="https://stackoverflow.com/users/8459774/minimalistying" target="_blank">StackOverflow</a></li><li><a href="https://github.com/MinimalistYing" target="_blank">Github</a></li></ul></nav></header><main class="memos"><section class="memo-wrap"><div class="memo"><div class="my-md"><p>严格模式下函数中的<code>arguments</code>会被禁用</p>
</div></div><div class="memo"><div class="my-md"><p>HTTP响应中的Date首部应该表示原始服务器最初产生这个对象的日期</p>
</div></div><div class="memo"><div class="my-md"><p>箭头函数都是匿名的函数表达式(function expression)</p>
</div></div><div class="memo"><div class="my-md"><p>源IP地址、目标IP地址、源端口号、目标端口号这四个值一起唯一地定义了一个TCP连接</p>
</div></div><div class="memo"><div class="my-md"><p>Vue中对进行双向绑定的数据需进行初始化(包括向组件中传递的数据)，否则会导致双向绑定失效</p>
</div></div><div class="memo"><div class="my-md"><p>IE8 中的伪元素只支持类似 <code>:after</code> 的写法，不支持 <code>::after</code> 的写法</p>
</div></div><div class="memo"><div class="my-md"><p>HTTP中的URL中没有具体表明端口号时，默认访问80端口，而HTTPS中的默认端口号为443</p>
</div></div><div class="memo"><div class="my-md"><p><code>::selection</code>可用于改变文字选中时的字体颜色和背景色，IE9及以上和现代浏览器兼容</p>
</div></div><div class="memo"><div class="my-md"><p>全角空格占位符 <code>&amp;emsp;</code> 可以完美的用作一个中文字符大小的空白<br>不受字体大小变动影响</p>
</div></div><div class="memo"><div class="my-md"><p>可以使用 <code>&lt;pre&gt;</code> 来展示代码 / JSON 等内容<br>因为该标签内等空格换行会被完整保留</p>
</div></div><div class="memo"><div class="my-md"><p>React组件中的HTML标签必须闭合，否则会编译报错，例如 <code>&lt;img&gt;</code> 必须写作 <code>&lt;img/&gt;</code></p>
</div></div><div class="memo"><div class="my-md"><p>关于浏览器的同源策略:域名（需各级域名完全相同）、协议、端口号都相同称谓同源，非同源的请求会存在跨域问题</p>
</div></div><div class="memo"><div class="my-md"><p>匹配中文字符（简繁体都包含）的正则 <code>/^[\u4e00-\u9fa5]+$/</code> 暂时无法确认其是否完全正确</p>
</div></div><div class="memo"><div class="my-md"><p><code>z-index</code> 属性只有设置在定位元素也就是 <code>position</code> 不是 <code>static</code> 的元素上才会生效</p>
</div></div><div class="memo"><div class="my-md"><p>可以使用Object的 <code>hasOwnProperty()</code> 方法来检测一个属性是该对象独有还是由原型链继承而来</p>
</div></div><div class="memo"><div class="my-md"><p>判断一个值是否为 <code>NaN</code> 一定要通过 <code>isNaN()</code> 而不是通过等号比较<br>因为 <code>NaN !== NaN</code></p>
</div></div><div class="memo"><div class="my-md"><p>正则表达式中的 <code>.</code> 可以用于匹配除换行符外的所有字符,如果想匹配含换行符在内的所有字符可以使用 <code>[\s\S]</code></p>
</div></div><div class="memo"><div class="my-md"><p>Javascript的变量名允许使用Unicode字符集中的所有字母和数字，所以类似 <code>var 变量 = 1</code> 也是合法的</p>
</div></div><div class="memo"><div class="my-md"><p>实现文字模糊效果</p>
<pre><code class="language-css">{
    <span class="hljs-attribute">color</span>: transparent;
    <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">#111</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">5px</span>;
}</code></pre>
</div></div><div class="memo"><div class="my-md"><p>类似 <code>input/img/iframe</code> 等内部无法容纳其它内容的元素，
无法利用伪元素 <code>::after/::before</code> 来实现特定样式</p>
</div></div><div class="memo"><div class="my-md"><p>HTTP的版本号不会被当作小数来比较，而是每个数字都单独处理，
所以假设将来有这么俩个版本HTTP/2.22和HTTP/2.3，
前者的版本更高</p>
</div></div><div class="memo"><div class="my-md"><p>利用解构实现交换俩个变量的值，并且无需中间变量</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>;
[ y, x ] = [ x, y ];</code></pre>
</div></div><div class="memo"><div class="my-md"><p>通过在Response Header中配置 <code>Strict-Transport-Security</code> 可以实现将请求的页面强制重定向至HTTPS协议访问</p>
</div></div><div class="memo"><div class="my-md"><p>可以通过</p>
<pre><code class="language-css">filter: Alpha(opacity = ?)</code></pre>
<p>来在 IE7-8 中兼容 CSS3 的 <code>opacity</code> 属性</p>
</div></div><div class="memo"><div class="my-md"><p><code>&lt;input type="file" /&gt;</code> 只能是 Uncontrolled Component<br>因为在前端文件只能通过用户交互来选择，不能在程序中控制</p>
</div></div><div class="memo"><div class="my-md"><p>在开启Webpack <code>devServer</code> 遇到问题时可以路由至URL <code>/webpack-dev-server</code> 
来观察打包出来的bundle文件详情来Debug</p>
</div></div><div class="memo"><div class="my-md"><p>Vue-Router中路由配置的<code>redirect</code>和<code>alias</code>区别在于前者会将地址栏到URL重定向到新的而后者不改变URL，
使得不同的URL也可以绘制同样的组件</p>
</div></div><div class="memo"><div class="my-md"><p>在Vue中使用Scoped Style时最好采用类选择器或Id选择器，这样会使与属性选择器连用
(PostCSS实现Scoped Style的方式)时造成的性能损失最小</p>
</div></div><div class="memo"><div class="my-md"><p>IE8 切换为兼容性视图模式时会将原 User-Agent 中包含的 <code>MSIE8.0</code> 转变为 <code>MSIE7.0</code><br>所以在通过 UA 来判断 IE 版本时尤其要注意</p>
</div></div><div class="memo"><div class="my-md"><p>在HTML中属性可以用双引号、单引号、甚至不用引号包围，浏览器都是支持的。
所以Google为了节省字节会采用不用引号的风格，大概对访问量极大的网站这也是一种省钱的方式吧</p>
</div></div><div class="memo"><div class="my-md"><p>当页面的UI需要在后台数据返回后进行刷新时，一定要考虑到网络极差的情况下，请求会延迟很久后返回。
这期间UI要怎样展示，或者用户能否进行操作，会不会有遗留的表单数据等等。</p>
</div></div><div class="memo"><div class="my-md"><p>由于TCP具有慢启动特性（不能在连接的开始就将所有的IP分组一次发出，
而是只有在一个分组成功确认后才有发出其它俩个分组的权限），
所以新连接的速度一般会比已建立好的连接要慢</p>
</div></div><div class="memo"><div class="my-md"><p>Javascript中的假值( falsy values )</p>
<ul>
<li>false</li>
<li>null</li>
<li>undefined</li>
<li>空字符串''</li>
<li>0</li>
<li>NaN</li>
</ul>
<p>其它值都为 true</p>
</div></div><div class="memo"><div class="my-md"><p>ES7移入了新的指数计算操作符<code>**</code><br>可以用于替代以往使用的<code>Math.pow()</code>  </p>
<pre><code class="language-js"><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 4</span>
<span class="hljs-number">2</span> ** <span class="hljs-number">3</span> <span class="hljs-comment">//8</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>在自测与后台有交互，会发送请求的地方时一定要注意在Chrome的Network中观察发送请求的URL、参数等是否符合预期，
同时也要注意考虑请求返回失败或返回空结果时页面UI的展示</p>
</div></div><div class="memo"><div class="my-md"><p><code>Array.prototype.sort()</code> 可传入比较函数 <code>comparefn(a, b)</code> 来排序<br>希望a排在前该函数需返回一个负数，反之返回正数，俩者相等则返回0。</p>
</div></div><div class="memo"><div class="my-md"><p>通过 <code>Element.requestFullscreen()</code> 以及 <code>Document.exitFullscreen()</code><br>可以将页面上的内容进行全屏展示以及取消全屏展示</p>
</div></div><div class="memo"><div class="my-md"><p>一种提高使用transform以及opacity来做过度效果性能的思路<a href="https://aerotwist.com/blog/flip-your-animations/">FLIP</a></p>
</div></div><div class="memo"><div class="my-md"><p>使用 Fetch API 可以通过 <code>res.ok === true</code> 来判断请求是否成功<br>相当于 <code>res.status &gt;= 200 &amp;&amp; res.status &lt; 300</code></p>
</div></div><div class="memo"><div class="my-md"><p>AntD 表格组件 <code>columns</code> 的 <code>filteredValue</code> 字段只接受字符串数组<br>要注意把其它类型的 ID 转为字符串后再传入，否则会导致筛选项的多选框回填出现问题</p>
</div></div><div class="memo"><div class="my-md"><p>Javascript 中一共有六种种原始类型( primitive type )<br>string/boolean/number/null/undefined/symbol( ES6 新增 )</p>
</div></div><div class="memo"><div class="my-md"><p>使用 <code>$(dom).html('...')</code> 时需注意防范脚本注入攻击，如果传入的字符串中包含可由用户填写的字段需要先进行转义，
更好的办法是尽量使用 <code>$(dom).text('...')</code></p>
</div></div><div class="memo"><div class="my-md"><p>在Javascript中尝试去获取对象的某个属性值时，如果该对象没有该属性<br>则会继续在其原型链上查找直至 <code>Object.prototype</code> ,如果都没有找到才会返回 <code>undefined</code></p>
</div></div><div class="memo"><div class="my-md"><p>在使用ES6的Default Parameter时需要注意<br>调用函数时如果希望传入空参数应该传 <code>undefined</code> 而不是 <code>null</code><br>例如 <code>foo(undefined, 66)</code></p>
</div></div><div class="memo"><div class="my-md"><p>利用Function.prototype更快捷的创建一个空函数</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> cb = <span class="hljs-built_in">Function</span>.prototype; <span class="hljs-comment">// 相当于 var cb = function(){}</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>通过CSS3的 <code>vh(当前视窗高度百分比)</code>  <code>vw(当前视窗宽度百分比)</code>  <code>vmin</code>  <code>vmax</code> 
这几个熟悉来实现基于浏览器视窗高度的布局，例如全屏遮罩，左侧导航100%自适应当前视窗高度等</p>
</div></div><div class="memo"><div class="my-md"><p>HTML5新增了 <code>input</code> 事件来监听文本框的输入变化，但在IE9下存在用户删除输入或剪切文本时不会触发该事件的Bug,
并且IE8下没有该事件，需同时监听 <code>propertychange</code> 来实现兼容IE8</p>
</div></div><div class="memo"><div class="my-md"><pre><code class="language-js"><span class="hljs-comment">// 因为都是构造函数？</span>
typepf <span class="hljs-built_in">Object</span> <span class="hljs-comment">// =&gt; function</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// =&gt; function</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> <span class="hljs-comment">// =&gt; function</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>使用 Fetch API 时 <code>mode</code> 设为 <code>no-cors|same-origin</code> 会导致请求不会发出<br>浏览器会报错 <code>failed to fetch</code> 并且在 network 中也看不到请求的相关信息</p>
</div></div><div class="memo"><div class="my-md"><p>可以借助<code>\</code>来实现跨行书写单行字符串<br>ES6的Template String也支持这种写法</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'a\
b\
c'</span>

<span class="hljs-built_in">console</span>.log(str) <span class="hljs-comment">// =&gt; 'abc'</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>当 <code>display: inline-block</code> 的元素间有换行时，浏览器的渲染结果会带有间隙。
这是由于浏览器会将这个换行符当作字符，所以会占有一个的字符大小的宽度。
解决方法有很多，个人较喜欢 <code>font-size：0</code>。</p>
</div></div><div class="memo"><div class="my-md"><p>可以通过给锚点设置一个向上的负偏移量来实现调至锚点位置时不会将锚点至于页面最顶部(避免被顶部所固定的Header遮挡)，
类似: </p>
<pre><code class="language-css"><span class="hljs-selector-tag">a</span> {
    <span class="hljs-attribute">position</span>: relative;
    <span class="hljs-attribute">top</span>: -<span class="hljs-number">66px</span>;
}</code></pre>
</div></div><div class="memo"><div class="my-md"><p>判断点击是否在某个DOM外部发生的思路，判断 <code>event.srcElement(IE) || event.target(FF)</code><br>是否是这个DOM节点本身或者是其子元素,这里要注意在内部元素有特殊定位的情况下可能这个思路会有问题</p>
</div></div><div class="memo"><div class="my-md"><p>关于正则表达式量词(Regexp Quantifier)</p>
<ul>
<li>?  =&gt; {0,1}</li>
<li>\+ =&gt; {1,}</li>
<li>\*  =&gt; {0,}</li>
</ul>
<p>如果只有一个量词则为贪婪匹配，会尽可能的匹配更多结果。如果量词后附加后缀?则进行非贪婪匹配。</p>
</div></div><div class="memo"><div class="my-md"><p>IE8下可采用</p>
<pre><code class="language-css">filter:
progid:DXImageTransform
.Microsoft
.gradient(startColorstr=xxx,endColorstr=xxx);</code></pre>
<p>来兼容 <code>rgba()</code></p>
</div></div><div class="memo"><div class="my-md"><p>利用<code>Webpack</code>的Code Splitting特性以及Vue的Async Component特性可以很容易的做到按需加载</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> Com = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./my-async-compnent'</span>)</code></pre>
</div></div><div class="memo"><div class="my-md"><p>webpack配置中的 <code>optput.publicPath</code> 也会同时影响到webpack-dev-server去何处读取静态资源，
如果配置错误会导致页面或静态资源无法加载，页面报错404或 <code>Cannot get /index.html</code></p>
</div></div><div class="memo"><div class="my-md"><p>获取浏览器当前滚动条位置可通过 <code>window.scrollY(Chrome Safari FF)||window.pageYOffset(IE9+)</code><br>横向位置则通过 <code>window.scrollX||window.pageXOffset</code></p>
</div></div><div class="memo"><div class="my-md"><p>通过代码判断文件是否被压缩</p>
<pre><code class="language-js"><span class="hljs-comment">// 学习自 Redux</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCrushed</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-keyword">if</span> (isCrushed.name === <span class="hljs-string">'isCrushed'</span>) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'not minified'</span>)</code></pre>
</div></div><div class="memo"><div class="my-md"><p>Gulp在文件变化时触发回调函数</p>
<pre><code class="language-js">gulp.watch(<span class="hljs-string">'...'</span>, (event) =&gt; {})
<span class="hljs-comment">// event.path 发生变化文件的路径</span>
<span class="hljs-comment">// event.type added|changed|deleted|renamed</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>可以通过</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>抱歉 禁用 Javascript 会导致应用不能正常工作<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span></code></pre>
<p>在用户浏览器不支持 Javascript 或者用户手动禁用 Javascript 时展示相关提示信息</p>
</div></div><div class="memo"><div class="my-md"><p>当一个元素被设为 <code>display: flex</code> 时，它会被当作一个Flex Container，
而它的所有子元素都会被当作Flex Item，并且这时候在其子元素上设置 <code>float | clear | vertical-align</code> 
的值都是无效的</p>
</div></div><div class="memo"><div class="my-md"><p>小技巧，可以通过俩次位运算来将 <code>string</code> 形式的数字转为(效率比parseInt等高) <code>number</code><br>类似 <code>~~'123'// 123</code> ,Ps: 处理数字的上限是 <code>Math.pow(2,31) - 1</code> 对超出该值的数字无法正确转化</p>
</div></div><div class="memo"><div class="my-md"><p>最新的 ES 提案在 <code>Class</code> 内可以通过 <code>#</code> 申明私有属性</p>
<pre><code class="language-js">class Foo {
    #foo = 5
    #bar = 6
    test() {
        console.log(this.#foo, this.#bar)
    }
}</code></pre>
</div></div><div class="memo"><div class="my-md"><p>判断一个变量是否为数字</p>
<pre><code class="language-js"><span class="hljs-comment">// 排除 NaN +Infinity -Infinity</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">a</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> a === <span class="hljs-string">'number'</span> &amp;&amp; <span class="hljs-built_in">Number</span>.isFinite(a)
}</code></pre>
</div></div><div class="memo"><div class="my-md"><p>通过 ES5shim 和 Babel 使用新特性 Class 时如果类并没有继承却在 <code>contructor()</code> 中调用了 <code>super()</code>
会导致在 IE8 下报错 Stackoverflow。谨记如果没有继承关系则不应该调用 <code>super()</code> 方法</p>
</div></div><div class="memo"><div class="my-md"><p>Css 伪类也可以结合起来使用，例如</p>
<pre><code class="language-css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span><span class="hljs-selector-pseudo">:hover</span> {
    <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span><span class="hljs-selector-pseudo">:hover</span> {
    <span class="hljs-attribute">color</span>: green;
}</code></pre>
<p>可以使得鼠标悬浮未访问过的链接时字体为红色，悬浮访问过的链接字体为绿色</p>
</div></div><div class="memo"><div class="my-md"><p>通过Javascript</p>
<pre><code class="language-js">element.scrollTop = value
$(dom).scrollTop(value)</code></pre>
<p>去设置滚动条滚动位置时，注意所选取的元素就是设置了</p>
<pre><code class="language-css">overflow-y: scroll</code></pre>
<p>的元素</p>
</div></div><div class="memo"><div class="my-md"><p>用于监听CSS3动画结束的事件</p>
<ul>
<li>webkitAnimationEnd// Chrome Safari</li>
<li>mozAnimationEnd</li>
<li>MSAnimationEnd// IE10</li>
<li>oanimationend// Opera</li>
<li>animationend</li>
</ul>
</div></div><div class="memo"><div class="my-md"><p>想用 Unicode 动态生成字符时，如果试图通过 <code>const str = '\u' + '0000'</code> 会报错  </p>
<pre><code>Invalid Unicode <span class="hljs-built_in">escape</span> sequence</code></pre><p>需要通过 <code>String.fromCodePoint()</code> 来实现</p>
</div></div><div class="memo"><div class="my-md"><p>HTTP协议其实并未对url的长度做过多的限制，但各实际中各浏览器的实现都有着不同的长度限制，
RFC2616建议不应超过255 bytes也就是2040bit，实际中是IE浏览器最为严格url最长为2083个字符。
所以关于在get请求中传数组这种操作还需慎重考虑。</p>
</div></div><div class="memo"><div class="my-md"><p>为了使</p>
<pre><code class="language-css">display: inline-block</code></pre>
<p>在IE8中起作用，必须在文档开头加上</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>关于URI/URL/URN，URL和URM其实是URI(Uniform Resource Identifier)统一资源定位符的子集。
URL不止指定了资源的地址，同时还指定了获取资源的方式（协议/方法等等）。
而URN则只通过特定的命名空间标识资源，不关注操作获取资源的方式。</p>
</div></div><div class="memo"><div class="my-md"><p>Web服务器也可以接受一个目录的URL请求，类似 <code>/dir/</code> 通过配置服务器可以指定不同的返回形式，
可以返回一个错误，可以默认的去搜索该目录下的index.html并返回，
可以扫描目录返回包含目录内容的html页面(通常这是不安全的，因为这样会把站点的目录结构暴露出来)</p>
</div></div><div class="memo"><div class="my-md"><p>关于实现背景透明但文字不透明的效果，首先考虑的是使用 <code>opacity</code> 但其子元素都会继承这个属性，
且无法单独为其子元素设置一个值，所以不可行。如果只是背景色透明的话，
使用 <code>rgba()</code> 来设置透明 <code>background-color</code> 是一种不错的方法，兼容至IE9。</p>
</div></div><div class="memo"><div class="my-md"><p>Javascript中的原型是一种动态关系，改变原型的属性会立即对所有该原型链下的对象可见</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> a = {}
<span class="hljs-comment">// a.test =&gt; undefined</span>
<span class="hljs-built_in">Object</span>.prototype.test = <span class="hljs-string">'Hello'</span>
<span class="hljs-comment">// a.test =&gt; Hello</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>关于 NPM 中常见的 Sematic Version Operator<br><code>~1.0.1</code> 意味着可以接受大于或等于 <code>1.0.1</code> 但是小于 <code>1.1.0</code> 之间的所有版本<br><code>^1.0.1</code> 意味着可以接受大于或等于 <code>1.0.1</code> 但是小于 <code>2.0.0</code> 之间的所有版本</p>
</div></div><div class="memo"><div class="my-md"><p>关于函数参数同时采用解构以及默认参数时的细微不同</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"> { x = <span class="hljs-number">1</span> } = {}, { y } = { y: <span class="hljs-number">1</span> }</span>) </span>{
    <span class="hljs-built_in">console</span>.log(x,y)
}
test() <span class="hljs-comment">// 1,1</span>
test({}, {}) <span class="hljs-comment">// 1,undefined</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>判断是否是数组的方法，IE9+直接用原生的 <code>Array.isArray()</code> 如果要向下兼容的话</p>
<pre><code class="language-js"><span class="hljs-built_in">Object</span>.prototype.toString.call(arg) === <span class="hljs-string">'[object Array]'</span></code></pre>
<p>Ps:jQuery的 <code>$.isArray()</code> 亦是采用这种方式</p>
</div></div><div class="memo"><div class="my-md"><pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span>
    <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=utf-8"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span></code></pre>
<p>在HTML中俩者都可用来表明页面所采用的字符集，各浏览器的兼容性良好，但后者更短建议采用后者</p>
</div></div><div class="memo"><div class="my-md"><p>关于 <code>location.href = 'xx' || location.assign('xx')</code> 与 <code>location.replace('xx')</code> 
俩者的区别在于采用前者当前的地址会被计入History中而后者不会，所以通过后者跳转到新页面后无法通过后退返回，
这点在实现某些中间页面跳转页面是会很有用</p>
</div></div><div class="memo"><div class="my-md"><p>返回一个只能执行一次的函数</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">once</span>(<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-keyword">let</span> isCalled = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (!isCalled) {
            isCalled = <span class="hljs-literal">true</span>
            fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
        }
    }
}</code></pre>
</div></div><div class="memo"><div class="my-md"><p>当一个 <code>position: absolute</code> 的绝对定位元素的父元素的 <code>overflow</code> 值被设为非 <code>visible</code> 时，
会出现该定位元素超出父元素的部分会被遮盖掉无法显示的情况，
暂时对这种问题的解决方式只知道将父元素改为 <code>overflow: visible</code> 或者尽量保证定位元素不会超出父元素的边界</p>
</div></div><div class="memo"><div class="my-md"><p>关于ES6 Module</p>
<ul>
<li>基于文件，每个文件为一个Module，不可能一个文件中包含多个Module</li>
<li>静态，不能动态的去修改一个Module对外export的API</li>
<li>单例，所有的import都是指向同一实例</li>
<li>import和export只能出现在一个Module的最顶层，也就是说不能出现在任何块中或函数中</li>
</ul>
</div></div><div class="memo"><div class="my-md"><p>npm安装node-sass报错 <code>%1 is not a valid Win32 application</code> 看了看报错信息大概是说什么东西下载失败导致的，
切换成淘宝镜像用cnmp安装就好了 <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
</div></div><div class="memo"><div class="my-md"><p>关于webpack devServer 的 <code>historyApiFallback</code> 在使用 类似 <code>vue-router</code> 或 <code>react-router</code> 来开发SPA时，
如果将模式设为history模式需要将此项设为 <code>true</code> 
为了将404的页面请求重定向至index.html以显示相应的404错误提示页面</p>
</div></div><div class="memo"><div class="my-md"><p>Andriod 部分机型的 WebView 不支持通过</p>
<pre><code class="language-js"><span class="hljs-selector-tag">window</span><span class="hljs-selector-class">.location</span><span class="hljs-selector-class">.replace</span>()</code></pre>
<p>来实现无法返回的页面中转操作，
因此建议优先考虑采用 History API 来实现相应功能</p>
<pre><code class="language-js"><span class="hljs-selector-tag">window</span><span class="hljs-selector-class">.history</span><span class="hljs-selector-class">.replaceState</span>({}, <span class="hljs-selector-tag">title</span>, <span class="hljs-selector-tag">url</span>)</code></pre>
</div></div><div class="memo"><div class="my-md"><p>在Javascript中 <code>Object</code> 是 <code>truthy value</code><br>所以哪怕是 <code>new Boolean(false)</code> 也会在类型转化时被判断为true</p>
<pre><code class="language-js"><span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) <span class="hljs-comment">// false</span>
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>) &amp;&amp; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>IE10+ 以及各现代浏览器提供了原生的方法 <code>btoa</code> 以及 <code>atob</code> 支持对字符串进行 Base64 编解码  </p>
<pre><code class="language-js"><span class="hljs-comment">// Binary to ASCII 编码</span>
<span class="hljs-built_in">window</span>.btoa(<span class="hljs-string">'a'</span>) <span class="hljs-comment">// "YQ=="</span>
<span class="hljs-comment">// ASCII to Binary 解码</span>
<span class="hljs-built_in">window</span>.atob(<span class="hljs-string">'YQ=='</span>) <span class="hljs-comment">// "a"</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>使用React-Router(3.x版本 其它版本估计也一样)，如果在 <code>&lt;Router history={xxx}&gt;</code> 上不配置 <code>history</code>
会报错 <code>Uncaught TypeError: Cannot read property 'getCurrentLocation' of undefined</code> 所以这个属性是SPA必配？</p>
</div></div><div class="memo"><div class="my-md"><p>对比<code>let o1 = {}</code>以及<code>let o2 = Object.create(null)</code>可以发现<br>在o2并没有从Object.prototype上继承任何属性<code>o2.__proto__ === undefined</code>，是一个干净的空对象<br>通过<code>{}</code>创建对象等同于<code>Object.create(Object.prototype)</code></p>
</div></div><div class="memo"><div class="my-md"><p>关于HTML中的相对路径 <code>./</code> 是文档相对路径，也就是当前访问页面的路径 <code>/</code> 是基于站点根目录的相对路径，
举例说明访问网址<a href="http://0.0.0.0/1/2/son.html">http://0.0.0.0/1/2/son.html</a></p>
<ul>
<li>./test.js =&gt; <a href="http://0.0.0.0/1/2/test.js">http://0.0.0.0/1/2/test.js</a></li>
<li>/test.js =&gt; <a href="http://0.0.0.0/test.js">http://0.0.0.0/test.js</a></li>
</ul>
</div></div><div class="memo"><div class="my-md"><p>由于node有许多底层依赖包需要依靠c++,所以需要额外安装 <code>node-gyp</code> 提供跨平台的编译支持，
安装之前需要先装好相应的python/c++等环境，
根据官方文档 <code>npm install --global --production windows-build-tools</code> 即可
（很多情况下的npm安装失败可能都是因为这个没装好）</p>
</div></div><div class="memo"><div class="my-md"><p>ES6的 <code>import</code> 除了通常的 <code>import xx from 'lib'</code> 外，还可以采用 <code>import 'lib'</code><br>将依赖全部引入但不将其赋值给任何变量。在使用webpack引入样式文件时有一些作用<br>我们可以 <code>import 'xx.less'</code> 而不需要繁琐的 <code>import Style from 'xx.less'</code></p>
</div></div><div class="memo"><div class="my-md"><p>部分 Andriod 4.4.4 版本的机型 WebView 不支持 CSS3 的 <code>transform</code> 加了前缀 <code>-webkit-transform</code> 也不行<br>但是手机自带的浏览器应该是支持带前缀的形式的，只是 WebView 中不支持<br>询问 Andriod 的同学得知 WebView 采用的浏览器内核和手机自带浏览器的内核还是有差别的</p>
</div></div><div class="memo"><div class="my-md"><p>Webpack 中 <code>resolve.extensions</code> 的默认值为 <code>['.wasm', '.mjs', '.js', '.json']</code><br>当我们自定义这个值时，会把默认规则覆盖<br>为了确保默认值仍可使用，可以把默认值也加入新定义的规则中<br>例如  <code>['.vue', '.wasm', '.mjs', '.js', '.json']</code> </p>
</div></div><div class="memo"><div class="my-md"><p>页面上引用静态资源时的相对路径与绝对路径的区别，</p>
<ul>
<li><code>src='xx.js'</code> 相对于当前页面的路径，</li>
<li><code>src='./xx.js'</code> 相对于当前页面的路径，</li>
<li><code>src='../xx.js'</code> 相对与当前页面的上级路径，</li>
<li><code>src='/xx.js'</code> 相对于根目录路径，</li>
<li><code>src='http//:xx.com/xx.js'</code> 绝对路径</li>
</ul>
</div></div><div class="memo"><div class="my-md"><p>当使用 Uncontrolled Component 时，如果想要指定一个输入框当默认值需要采用 <code>defaultValue</code>  </p>
<pre><code class="language-js"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">"默认值"</span> /&gt;</span></code></pre>
<p>因为直接设置 <code>value</code> 会导致输入框的值无法修改，因为 React 当每次 Render 都会根据 <code>value</code> 重新设置输入框的值  </p>
</div></div><div class="memo"><div class="my-md"><p>在Less 1.x和2.x的版本中会默认的对calc中的数值进行计算，从而导致一些意外的结果，例如<br><code>height: calc(100vh - 20px)</code>经less编译后的结果是80vh，很明显与我们想要的不符<br>为了避免这个问题需要采用<code>height: calc(~"100vh - 20px")</code>这样的写法(Ps: Less 3.x版本已修复这个问题)</p>
</div></div><div class="memo"><div class="my-md"><p>Andriod 中调用 WebView 来访问 H5 页面时 HTML5 的 DOMStorage 也就是<br><code>localStorage|sessionStorage</code> 默认是关闭的<br>需要通过 <code>settings.setDomStorageEnabled(true)</code> 来开启<br>未开启的话会碰到在 H5 中读取 localStorage 为 null 的问题</p>
</div></div><div class="memo"><div class="my-md"><p>关于</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span></code></pre>
<p>详情参看<a href="https://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do">这个回答</a></p>
</div></div><div class="memo"><div class="my-md"><p>Javascript的 <code>setTimeout()</code> 和 <code>setInterval()</code> 都可以接受字符串参数，并类似eval()将其执行<br>不安全并且效率低下，最好不要使用<br>具体可见<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">这篇文档</a></p>
</div></div><div class="memo"><div class="my-md"><p>Javascript <code>catch</code> 块中申明的变量具有块级作用域（小技巧 应该用不到）</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-literal">undefined</span>
} <span class="hljs-keyword">catch</span>(a) {<span class="hljs-comment">// 这里的a具有块级作用域</span>
    a = <span class="hljs-number">1</span>
  <span class="hljs-built_in">console</span>.log(a)
}
<span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>Javascript中的整数在超过9007199254740992也就是 <code>Math.pow(2, 53)</code> 时精度无法精确至个位<br>会出现 <code>Math.pow(2, 53) + 1 === Math.pow(2, 53)</code> 的情况<br>关于其它数字过大时存在的问题可见<a href="http://www.plqblog.com/views/article.php?id=29">这篇Blog</a></p>
</div></div><div class="memo"><div class="my-md"><p>在使用Javascript的 <code>parseInt()</code> 时，最好显示的指明进制，因为 <code>parseInt('0x16') === 22</code><br>而你可能期望的结果是 <code>parseInt('0x16') === 0</code> 所以显示的指定进制才能做到真正的结果可控 </p>
<pre><code class="language-js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'0x16'</span>, <span class="hljs-number">16</span>) === <span class="hljs-number">22</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'0x16'</span>, <span class="hljs-number">10</span>) === <span class="hljs-number">0</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>Gulp确保任务按一定顺序执行</p>
<pre><code class="language-js">gulp.task(<span class="hljs-string">'second'</span>, [<span class="hljs-string">'first'</span>], () =&gt; {})</code></pre>
<p>Gulp在匹配的文件列表中剔除指定文件</p>
<pre><code class="language-js">gulp.src([<span class="hljs-string">'asset/*.js'</span>, <span class="hljs-string">'!asset/exclude.js'</span>], () =&gt; {})</code></pre>
<p>上述代码会匹配asset目录下除去exclude.js的所有以.js结尾的文件</p>
</div></div><div class="memo"><div class="my-md"><p>Webpack中的 <code>url-loader</code> 和 <code>file-loader</code> 都是用于打包一些图片字体之类的静态资源文件，
区别在于 <code>url-loader</code> 会对一定大小限制内的图片进行Base64编码并采用DataUrl的形式嵌入页面或css，
这些编码后的图片不会占用HTTP请求。但在图片过大的情况下会增加文件的大小，得不偿失，
更适用于处理一些项目中多处用到的小图片（1kb以下）</p>
</div></div><div class="memo"><div class="my-md"><p>考虑如下一种比较情景</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (value === <span class="hljs-string">'a'</span> || value === <span class="hljs-string">'b'</span> || value === <span class="hljs-string">'c'</span>)</code></pre>
<p>如果都是字符串的话，可以运用正则使得比较更加优雅</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^a|b|c$/</span>.test(value))</code></pre>
<p>如果是变量，可以运用数组来比较</p>
<pre><code class="language-js"><span class="hljs-selector-tag">if</span> (<span class="hljs-selector-attr">[foo, bar, zoo]</span><span class="hljs-selector-class">.includes</span>(<span class="hljs-selector-tag">value</span>))</code></pre>
</div></div><div class="memo"><div class="my-md"><p>当一个</p>
<pre><code class="language-css">display: inline-block</code></pre>
<p>元素的overflow被设为visible以外的值时，它的baseline位置会被从默认的字符x的底线位置修改为下外边沿，
与此同时同一包含块的其它</p>
<pre><code class="language-css">display : inline-block</code></pre>
<p>元素会被迫向下偏移来和这个元素对齐，遵循IFC(Inline Formatting Contexts)原则</p>
</div></div><div class="memo"><div class="my-md"><p>关于React中的Event Handlers传参数有一下俩种方式</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{(e)</span> =&gt;</span> this.func(id, e)}&gt;click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<p>或者</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.func.bind(this,</span> <span class="hljs-attr">id</span>)}&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<p>第二种方式下的 <code>e</code> 会默认作为最后一个参数传递</p>
</div></div><div class="memo"><div class="my-md"><p>可以通过 <code>attr()</code> 来在样式中获取到 Dom 上的属性，例如  </p>
<pre><code class="language-css"><span class="hljs-comment">/*
&lt;p data-foo="hello"&gt;world&lt;/p&gt;
含有 data-foo 属性的 dom 元素会在之前显示一个与其属性值相同的伪元素
*/</span>
<span class="hljs-selector-attr">[data-foo]</span><span class="hljs-selector-pseudo">::before</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-built_in">attr</span>(data-foo) <span class="hljs-string">" "</span>;
}</code></pre>
<p>Ps: 这个函数的兼容性好像欠佳，建议谨慎使用</p>
</div></div><div class="memo"><div class="my-md"><p>避免浏览器缓存HTML页面可以在head中加上标签</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">'Cache-Control'</span> <span class="hljs-attr">content</span>=<span class="hljs-string">'no-store'</span>&gt;</span></code></pre>
<p>通常会采用 <code>no-cache</code> 的策略，只有在服务器的资源发生变化时才去再重新拉取，否则返回304采用缓存的资源
Ps: 这种方式好像不可靠，不能保证浏览器一定会按照这个规则来执行，最好还是去配置提供静态资源的服务端容器</p>
</div></div><div class="memo"><div class="my-md"><p>在 Javascript 中进行浮点数运算是不可靠的，遵循IEEE 754标准，二进制的浮点数运算不能正确的处理十进制小数<br>例如典型的 <code>0.1 + 0.2 !== 0.3</code> <del>在一定的精度范围内可通过将小数转化为整数再进行比较来解决这个问题</del>  </p>
<pre><code class="language-js"><span class="hljs-comment">// 这才是正确判断浮点数是否相等的方式</span>
<span class="hljs-built_in">Math</span>.abs(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> - <span class="hljs-number">0.3</span>) &lt;= <span class="hljs-built_in">Number</span>.EPSILON</code></pre>
</div></div><div class="memo"><div class="my-md"><p>HTML 中的类名 / ID等都建议以字母开头<br>虽然有少部分浏览器兼容数字或下划线开头<br>但还是有不少浏览器不支持以数字或下划线开头的CSS选择器<br>并且通过 <code>document.querySelector()</code> 查找节点时<br>部分浏览器会报错 <code>Failed to execute 'querySelector' on 'Document': xxx is not a valid selector.</code></p>
</div></div><div class="memo"><div class="my-md"><p>现在 CSS 提供了原生的全局变量支持(IE 不兼容)</p>
<pre><code><span class="hljs-selector-pseudo">:root</span> {
    <span class="hljs-attribute">--somecolor</span>: <span class="hljs-number">#666</span>;
    <span class="hljs-attribute">--someshadow</span>: <span class="hljs-number">#ddd</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6px</span>;
}

<span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">var</span>(--somecolor);
    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-built_in">var</span>(--someshadow);
    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--none, red); <span class="hljs-comment">/* 支持设置默认值 */</span>
}</code></pre></div></div><div class="memo"><div class="my-md"><p>关于</p>
<pre><code class="language-js"><span class="hljs-built_in">String</span>.prototype.split([separator[, limit]])
<span class="hljs-comment">// 'abc'.split() =&gt; ['abc']</span>
<span class="hljs-comment">// 'abc'.split('') =&gt; ['a','b','c']</span>
<span class="hljs-comment">// 'a,b'.split(/(,)/) =&gt; ['a', ',', 'b']</span>
<span class="hljs-string">'abc'</span>.split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>) <span class="hljs-comment">// 字符串倒序</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>使用 <code>String.prototype.length()</code> 来判断字符串长度在某些特殊场景下存在问题，例如 <code>'𝒜'.length === 2</code> 
因为这个方法判断的是给定字符串用了几个UTF-16（16bit）来编码，而有些特殊字符需要32bit来编码<br>这时候这个方法计算一个字符的长度是2，判断方法可见<a href="http://ife.baidu.com/note/detail/id/583">这篇Blog</a></p>
</div></div><div class="memo"><div class="my-md"><p>可以通过mask属性来实现对一块区域的遮罩效果
兼容性不佳，目前只有webkit内核支持
Ps:知乎在内容收起时的渐变透明文字遮罩的实现方式</p>
<pre><code class="language-css"><span class="hljs-selector-tag">-webkit-mask-image</span>: <span class="hljs-selector-tag">linear-gradient</span>(<span class="hljs-selector-id">#1a1a1a</span> <span class="hljs-selector-tag">calc</span>(100% <span class="hljs-selector-tag">-</span> 8<span class="hljs-selector-tag">rem</span>),<span class="hljs-selector-tag">transparent</span> <span class="hljs-selector-tag">calc</span>(100% <span class="hljs-selector-tag">-</span> 2<span class="hljs-selector-class">.8rem</span>));
<span class="hljs-selector-tag">-webkit-mask-size</span>: 100% 100%;</code></pre>
</div></div><div class="memo"><div class="my-md"><p>实现类似改变一个DOM元素的滚动条位置但不触发绑定在上面的onscroll函数<br>或者改变一个input元素的值不触发绑定在上面的onchange函数的一种思路：在改变值之前先将其绑定的事件函数解绑<br>改变完成后再将原有函数绑定回元素上注意如果值的改变如果是连续的，也就是这个过程会短时间内重复多次执行时<br>需要将解绑和绑定操作放在延时函数中执行，避免反复多次的绑定事件和解绑事件消耗过多资源，导致浏览器卡顿</p>
</div></div><div class="memo"><div class="my-md"><p>假设有如下俩个锚</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>不带 href<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"www.xxx.com"</span>&gt;</span>带有 href<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>
<p>设置如下样式</p>
<pre><code class="language-css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> {
    <span class="hljs-attribute">color</span>: red;
}</code></pre>
<p>只有第二个真正代表链接第锚标签会变为红色<br>如果通过</p>
<pre><code class="language-css"><span class="hljs-selector-tag">a</span> {
    <span class="hljs-attribute">color</span>: red;
}</code></pre>
<p>来设置未访问链接的字体颜色会发现页面上所有的 <code>&lt;a&gt;</code> 都字体都变成了红色</p>
</div></div><div class="memo"><div class="my-md"><p>当页面有大量图片需要展示时可以考虑采用Google提出的<a href="https://developers.google.com/speed/webp/">webp</a>来进行优化<br>由于兼容性还欠佳所以仍需要做一些降级工作，在浏览器不支持时降级为其它图片格式
相关细节可以看<a href="https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html">这篇Blog</a></p>
</div></div><div class="memo"><div class="my-md"><p>Edge / IE11 / Safari 好像会试图去识别页面上的数字是否像电话号码<br>如果像的话会在这些数字下加一个下划线，并使其可点击打开Skype之类的应用拨号(有些邮箱以及地址也同理)<br>想禁用这一特性可在 <code>&lt;head&gt;</code> 中加上</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span>
    <span class="hljs-attr">name</span>=<span class="hljs-string">"format-detection"</span>
    <span class="hljs-attr">content</span>=<span class="hljs-string">"telephone=no,email=no,address=no"</span>
&gt;</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>在 IE8 下如果在 <code>table-layout: auto</code> 的表格中为单元格设置</p>
<pre><code class="language-css">white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;</code></pre>
<p>想实现单元格内文字过长时出现...并截断多余内容会发现无效，反而表格会被内容撑宽，破坏原有布局。
要想实现这种效果，只能将表格设为 </p>
<pre><code class="language-css">table-layout: fixed</code></pre>
</div></div><div class="memo"><div class="my-md"><p>阅读垠神博客有感</p>
<ul>
<li>会写程序不是一件很了不起的事情，不要自负</li>
<li>语言、框架都只是工具，会用即可，不必过于推崇，重要的是我们脑海里的思想</li>
<li>开发软件也是一种工程，一定要极力避免Bug，这才是一个工程师该做的</li>
<li>面对同事、新人的提问请耐心解答，不要动不动就让提问者自行Google</li>
<li>不要觉得向他人提问是什么难为情的事，世界上总有东西是你不清楚的，哪怕是你日常工作所用的东西</li>
<li>复杂的代码不是显示能力的途径，简单易懂的才是</li>
</ul>
</div></div><div class="memo"><div class="my-md"><p>React-Router采用动态路由的形式时页面报错 <code>The root route must render a single element</code>
可能是因为React组件是采用ES6的 <code>export default</code> 导出，
而React-Router是采用CommonJS来 <code>require</code> 所以需要在导出的组件后加上 <code>.default</code> 
类似 <code>require('components/Comp')).default</code></p>
</div></div><div class="memo"><div class="my-md"><p>在用 Vue 开发 IOS WebView 内嵌 H5 SPA 页面时碰到点击APP返回上一页时出现页面白屏的问题<br>需要滑动一下页面，内容才会显示<br>具体问题以及解决方式可以参考<a href="https://github.com/vuejs/vue/issues/5533#issuecomment-343864468">issue</a><br>导致这个问题的主要原因应该还是在返回时仍去异步加载数据，最佳解决方式应该是缓存相应的异步请求数据</p>
</div></div><div class="memo"><div class="my-md"><p><code>moment</code>的国际化资源文件很大，所以在生产环境打包时要留意不要将不必要的国际化文件也包含进来
可以通过在webpack生产环境的配置文件中新增如下插件来解决这个问题</p>
<pre><code class="language-js">plugins: [
    <span class="hljs-comment">// 以下的配置会使打包出来的文件只包含简体以及繁体中文的国际化</span>
    <span class="hljs-keyword">new</span> webpack.ContextReplacementPlugin(<span class="hljs-regexp">/moment[/\\]locale$/</span>, /zh-cn|zh-tw/)
]</code></pre>
</div></div><div class="memo"><div class="my-md"><p>关于<code>Object.keys()</code>以及<code>Object.getOwnPropertyNames()</code>的区别<br>相同的是俩者都不会列出从原型上继承的属性key值<br>区别在于前者只会列出所有可枚举属性的key值，而后者会列出所有属性的key值，包括不可枚举的<br>所谓不可枚举的属性，即是通过类似<br><code>Object.defineProperty(o, 'a', { enumerable: false, value: 0 })</code>定义的属性</p>
</div></div><div class="memo"><div class="my-md"><p>Javascript中的Array其实是一种类数组的对象，效率比真正的数组要低，所以会有如下一些奇怪的行为</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-comment">// arr[0] =&gt; 1</span>
<span class="hljs-comment">// arr['0'] =&gt; 1</span>
arr.name = <span class="hljs-string">'Hello'</span>
<span class="hljs-comment">// arr.name =&gt; 'Hello'</span>
arr[<span class="hljs-number">10</span>] = <span class="hljs-number">10</span>
<span class="hljs-comment">// arr[6] =&gt; undefined</span>
arr.length = <span class="hljs-number">1</span>
<span class="hljs-comment">// arr =&gt; [1]</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>读完 <a href="https://overreacted.io/things-i-dont-know-as-of-2018/">Dan Abramov 的 Blog</a> 的感想</p>
<ul>
<li>即使是一名经验再丰厚的开发者也不是什么都会<br>不应该期望一个开发者能熟练的掌握所有技能</li>
<li>但是开发者应该有着各自擅长的专业方向<br>并且具备快速学习新技术的能力</li>
<li>开发者需要更深入的去学习理解自己的专精技能<br>并且对其充满自信，总有一些方面那些更有经验的开发者也没有你理解的透彻</li>
</ul>
</div></div><div class="memo"><div class="my-md"><p>算法题中经常出现要求输出modulo 10^9+7后的结果<br>是因为当数字过大时，程序需要特定的算法才能精确的计算<br>而通过模计算，可以使得不需要实现大数计算的算法便可比较结果的正确性
<a href="https://stackoverflow.com/questions/25689186/what-is-the-significance-of-modulo-1097-used-in-codechef-and-spoj-problems">Stackoverflow</a></p>
</div></div><div class="memo"><div class="my-md"><p>JSX 其实仅仅是一种方便我们写 React App 的语法糖，经过 Babel 编译最后的产出仍是 Vanilla Javascript</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> App = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"app"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre>
<p>如让 JSX 编译后其实就是</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> App = React.creatElement(<span class="hljs-string">'div'</span>, {
    <span class="hljs-attr">className</span>: <span class="hljs-string">'app'</span>
}, <span class="hljs-string">'Hello World'</span>)</code></pre>
</div></div><div class="memo"><div class="my-md"><p><code>Cache-Control : no-store</code> 禁止代理缓存 <code>Cache-Control : no-cache  Pragma : no-cache// 兼容HTTP/1.0</code> 
允许缓存，但必须先与服务器进行新鲜度验证，之后才能将内容返回给客户端
<code>Cache-Control : max-age:66,must-revalidate</code> 允许缓存，
并且只有在内容过期后才必须进行新鲜度验证（在缓存过期时即使服务器错误也不会将这个陈旧的缓存返回给客户端）</p>
</div></div><div class="memo"><div class="my-md"><p><code>UslifyJs</code> 不支持压缩 ES6 的代码，所以当我们想不经过 <code>Babel</code> 编译直接压缩混淆 ES6 代码时<br>需要使用 <a href="https://webpack.js.org/plugins/terser-webpack-plugin/">TerserWebpackPlugin</a><br>而不是通常用的 <a href="https://webpack.js.org/plugins/uglifyjs-webpack-plugin/">UglifyjsWebpackPlugin</a></p>
</div></div><div class="memo"><div class="my-md"><p>使用Javascript时如果选择在行尾不加上 <code>;</code> 是比较危险的行为，例如</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-keyword">var</span> b = arr
[<span class="hljs-number">2</span>].toString()
<span class="hljs-built_in">console</span>.info(b)</code></pre>
<p>的结果可能会出人意料，自动加分号的结果是</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> b = arr[<span class="hljs-number">2</span>].toString();
<span class="hljs-built_in">console</span>.info(b);</code></pre>
<p>再第二行以 <code>( [ + -</code> 开头时都需要注意避免以上情况</p>
</div></div><div class="memo"><div class="my-md"><p>一种将全部元素reset为 <code>box-sizing: border-box</code> 的方法</p>
<pre><code class="language-css">{
    <span class="hljs-attribute">box-sizing</span>: border-box;
}
*, *<span class="hljs-selector-pseudo">:before</span>, *<span class="hljs-selector-pseudo">:after</span> {
    <span class="hljs-attribute">box-sizing</span>: inherit;
}</code></pre>
<p>可能会有更好的方法？详情可见<a href="https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/">这篇文章</a></p>
</div></div><div class="memo"><div class="my-md"><p>关于ES6的Object super关键字</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o1 = {
    foo() { <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) }
}
<span class="hljs-keyword">const</span> o2 = {
    foo() {
        <span class="hljs-comment">// 只能在Object concise methods 中使用</span>
        <span class="hljs-comment">// 且只能以super.XXX这种形式调用</span>
        <span class="hljs-keyword">super</span>.foo()
        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)
    }
}
<span class="hljs-built_in">Object</span>.setPrototypeOf(o2, o1)
o2.foo() <span class="hljs-comment">// 1 2</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>如果希望在React组件内部进行路由、页面跳转，可以借助React-Router提供的 <code>withRouter(comp)</code> 
之后便可在组件内部通过 <code>this.props.router</code> 来进行跳转。但有时候我们希望在组件外部来跳转，
这就需要借助history来实现</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> {browserHistory} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router'</span>
browserHistory.goBack()
browserHistory.push()</code></pre>
</div></div><div class="memo"><div class="my-md"><p>关于 React 中的组件名称为何需要以大写字母开头<br>因为如下 JSX</p>
<pre><code class="language-js"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> /&gt;</span></code></pre>
<p>经 Babel 编译后生成</p>
<pre><code class="language-js"><span class="hljs-comment">// 所以要求 Button 必须在作用域中可见</span>
React.creatElement(Button, <span class="hljs-literal">null</span>)</code></pre>
<p>而</p>
<pre><code class="language-js"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> /&gt;</span></code></pre>
<p>编译后生成的是</p>
<pre><code class="language-js"><span class="hljs-comment">// 直接生成 &lt;button&gt;  标签</span>
React.creatElement(<span class="hljs-string">'button'</span>, <span class="hljs-literal">null</span>)</code></pre>
</div></div><div class="memo"><div class="my-md"><p>jQuery部分版本(1.10.X 1.8.X 可能还有其它)存在一个很奇怪的Bug，
在HTML标签中使用nodeName作为ID(或者input的name)会导致页面报错 <code>a.nodeName.toLowerCase is not a function</code> 
使用nodeType作为ID会导致$(window)发生变化并且绑定在上面的resize事件会失效。
综上所述，以后谨记不要使用nodeName/nodeType/nodeValue作为HEML标签的ID或者name。</p>
</div></div><div class="memo"><div class="my-md"><p>通常Web服务器的文件系统会有一个根目录(Document Root)来专门用于存放Web内容，
当服务器收到一个对静态资源的请求时会获取其URI并附加在根目录后去寻找相应的文件，
例如服务器的根目录为 <code>/usr/home</code> 请求为 <code>/test/haha.gif</code> 
服务器会在文件系统的 <code>/usr/home/test/haha.gif</code> 目录下去寻找被请求的资源文件。
要注意的是，一个服务器也可能同时提供多个Web站点，它可以通过不同的请求Host或者IP来访问不同的根目录</p>
</div></div><div class="memo"><div class="my-md"><p>HTTP常见状态码</p>
<ul>
<li>200 =&gt; 请求成功</li>
<li>301 =&gt; 资源永久迁移</li>
<li>302 =&gt; 资源临时迁移</li>
<li>303 =&gt;需要去另一个地址获取资源</li>
<li>304 =&gt; 资源未发生变化</li>
<li>400 =&gt; 请求异常</li>
<li>401 =&gt; 未授权</li>
<li>403 =&gt; 服务器拒绝请求</li>
<li>404 =&gt; 未找到</li>
<li>405 =&gt; 不支持的请求方法</li>
<li>408 =&gt; 请求超时</li>
<li>414 =&gt; 请求URL过长</li>
<li>500 =&gt; 服务器错误</li>
<li>502 =&gt; 网关故障</li>
<li>504 =&gt; 网关超时</li>
</ul>
</div></div><div class="memo"><div class="my-md"><p>CSS 中如下几个伪类选择器中 n 的值不止支持数字类型还支持关键字 (odd / even) 以及公式 (an + b)</p>
<ul>
<li>nth-child(n)</li>
<li>nth-last-child(n)</li>
<li>nth-of-type(n)</li>
<li>nth-last-of-type(n)</li>
</ul>
<p>例如 <code>p:nth-child(even)</code> 可以选择所有父元素中下标为偶数的 <code>&lt;p&gt;</code> 元素<br>又例如 <code>p:nth-child(3n+1)</code> 可以选择所有父元素中下标为 3 的倍数加 1 的 <code>&lt;p&gt;</code> 元素</p>
</div></div><div class="memo"><div class="my-md"><p>手机端的 H5 页面长按会弹出复制分享的菜单，如果想要禁用 IOS 可以通过</p>
<pre><code class="language-css"><span class="hljs-comment">// 这个属性会导致IOS上的input能唤起浏览器键盘 但无法聚焦input框</span>
<span class="hljs-comment">// 最终结果就是无法正常输入!!!</span>
<span class="hljs-comment">// 感觉这种禁用需求应该直接予以否决</span>
user-select: none; 
-webkit-touch-callout: none;</code></pre>
<p>Andriod 通过</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.oncontextmenu = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.preventDefault()</code></pre>
</div></div><div class="memo"><div class="my-md"><p>如何判断一个函数是正常被调用还是通过 <code>new</code> 当作构造函数调用</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 严格模式下 this 为 undefined</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> === <span class="hljs-built_in">window</span> || <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'普通调用'</span>)
    }

    <span class="hljs-comment">// 构造函数中的 this 指向新创建的实例</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Foo) {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'构造函数调用'</span>)
    }    
}</code></pre>
</div></div><div class="memo"><div class="my-md"><p>利用好jQuery的事件命名空间可以减少很多需要在一个Dom元素的同一事件上绑定多个不同回调函数时会碰到的问题，例如</p>
<pre><code class="language-js">$(dom).on(<span class="hljs-string">'click.a'</span>, () =&gt; {})
$(dom).on(<span class="hljs-string">'click.b'</span>, () =&gt; {})</code></pre>
<p>当出于某种原因需要解绑第一个函数时，只需要<code>$(dom).off('.a')</code> 即可实现，
同时也不会对b命名空间下的绑定事件有任何影响。如果想触发某个特定空间下的事件，
可以通过 <code>$(dom).trigger('click.b')</code> 来实现</p>
</div></div><div class="memo"><div class="my-md"><p>关于 <code>$.trim()</code> IE9+应该已经实现了原生的 <code>String.prototype.trim()</code> 
低版本浏览器可以使用jQuery的方式来实现Polyfill</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> text </span>) </span>{
    <span class="hljs-keyword">return</span> text == <span class="hljs-literal">null</span> ?
        <span class="hljs-string">''</span>
        :
        ( text + <span class="hljs-string">''</span> ).replace( <span class="hljs-regexp">/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g</span>, <span class="hljs-string">''</span> )
}</code></pre>
<p>其正则中的 <code>\xA0</code> 代表全角空格 <code>\uFEFF</code> 代表BOM头</p>
</div></div><div class="memo"><div class="my-md"><p>在使用ES6的Concise Methods时要注意</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o = {
    f() {
        <span class="hljs-comment">// ....</span>
        f() <span class="hljs-comment">// Error: f is not a function</span>
    }
}</code></pre>
<p>其实等同于</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o = {
    <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
        f() <span class="hljs-comment">// Error: f is not a function</span>
    }
}</code></pre>
<p>所以如果想要在函数<code>f()</code>通过<code>f()</code>来递归调用函数会导致报错，因为<code>f()</code>其实是一个匿名函数</p>
</div></div><div class="memo"><div class="my-md"><p>关于 'box-sizing: content-box' 以及 'box-sizing: border-box' 前者其实是W3C提出，
后者是早期IE6、7quirk mode下的盒模型实现。但后来人们发现其实后者更符合人的逻辑，所以加了这个属性。
对于 <code>content-box</code> 盒子宽度等于 <code>width</code> + <code>padding</code> + <code>border</code> 
对于 <code>border-box</code> 盒子宽度就等于所设的 <code>width</code>  减去 <code>padding</code> 以及 <code>border</code> 才是真正展示内容的宽度</p>
</div></div><div class="memo"><div class="my-md"><p>利用原生的JS即可输出格式化后的JSON字符串</p>
<pre><code class="language-js"><span class="hljs-built_in">JSON</span>.stringify(value[, replacer[, space]])
<span class="hljs-comment">// space即是缩进数，默认无缩进，最大为10</span>
<span class="hljs-comment">// replacer可以是一个过滤函数，用来筛选或替换最后的输出结果</span></code></pre>
<p>具体参数意义以及接口可见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">这篇文档</a></p>
</div></div><div class="memo"><div class="my-md"><p>通过webpack引入相关polyfill时要留意，polyfill需要确保在所有bundle之前引入，
而webpack并不会确保主entry中的</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> xx <span class="hljs-keyword">from</span> xx</code></pre>
<p>会按顺序引入，所以需要采取在entry中进行类似</p>
<pre><code class="language-js">app: [<span class="hljs-string">'babel-polyfill'</span>, <span class="hljs-string">'./app.js'</span>]</code></pre>
<p>这样的形式确保依赖顺序。
详情可参见 <code>React</code> 的<a href="https://github.com/facebook/react/issues/8379">Issue</a></p>
</div></div><div class="memo"><div class="my-md"><p><code>void</code> 操作符会计算其后的表达式并返回 <code>undefined</code><br>我们会在一些代码中看到开发者使用 <code>void 0</code> 代替 <code>undefined</code><br>因为再早期的 Javascript (ES5 之前)中 <code>undefined</code> 是一个变量，所以可能会在程序执行过程中被修改<br>为了避免这个语言设计上的错误，所以开发者会使用 <code>void 0</code><br>此外还可以利用 <code>void</code> 来执行 IIFE 例如  </p>
<pre><code class="language-js"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>)
}()</code></pre>
</div></div><div class="memo"><div class="my-md"><p>关于<code>encodeURI|decodeURI</code>以及<code>encodeURIComponent|decodeURIComponent</code>，俩者都是用于对URI进行编解码操作<br>区别在于前者默认接受的是一个完整的URL所以不会对所有的字符进行编解码<br>而后者会对所有需要被编解码的字符进行编解码，例如对<code>http://www.a.com?a=1+1</code>进行<code>encodeURI</code><br>不会发生任何变化而进行<code>encodeURIComponent</code>的结果是<code>http%3A%2F%2Fwww.a.com%3Fa%3D1%2B1</code></p>
</div></div><div class="memo"><div class="my-md"><pre><code class="language-js"><span class="hljs-comment">//  函数表达式</span>
<span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> }
<span class="hljs-comment">// 函数表达式</span>
<span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> }
<span class="hljs-comment">// 函数声明</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> }</code></pre>
<p>在混合时其实也是函数表达式，所以此时的 <code>g</code> 在函数外部是不可见的，试图执行 <code>g()</code> 会报错<br>关于函数表达式以及函数声明的具体差别可见<a href="http://kangax.github.io/nfe/">这篇文章</a><br>Ps:函数申明会存在函数提升的情况而函数表达式不会</p>
</div></div><div class="memo"><div class="my-md"><p>在 ES6 的对象方法中使用 <code>super</code> </p>
<pre><code class="language-js"><span class="hljs-comment">// 注意只能在采用简写的函数中使用且只能用super,xx()的形式不能用super()的形式</span>
<span class="hljs-keyword">var</span> parent = {
    foo() {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parent'</span>)
  }
}

<span class="hljs-keyword">var</span> son = {
    foo() {
      <span class="hljs-keyword">super</span>.foo()
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'son'</span>)
  }
}

<span class="hljs-built_in">Object</span>.setPrototypeOf(son, parent)
son.foo() <span class="hljs-comment">// parent son</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>在联调 Andriod WebView 内嵌 H5 页面时发现一个问题，页面的 <code>font-size|line-height</code>  会随着系统字体大小的调整而缩放导致布局错位<br>比如设置一个div的<code>font-size: 14px</code>当手机字体设为超小时<br>通过 Chrome inspect WebView 可能会发现 Computed Style 中显示的实际 <code>font-size</code> 为 <code>14*0.86=12.04px</code><br>在Andriod端通过<code>webview.getSettings().setTextZoom(100)</code>可完美解决问题</p>
</div></div><div class="memo"><div class="my-md"><p>Iframe 内嵌的子页面与父页面间可以通过 postMessage 来相互通信</p>
<pre><code class="language-js"><span class="hljs-comment">// 子页面发送</span>
<span class="hljs-built_in">window</span>.parent.postMessage(<span class="hljs-string">'你好 爸爸'</span>, <span class="hljs-string">'*'</span>)
<span class="hljs-comment">// 父页面发送</span>
<span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"iframe"</span>)[<span class="hljs-number">0</span>].contentWindow.postMessage(<span class="hljs-string">'你好 儿子'</span>, <span class="hljs-string">'*'</span>)
<span class="hljs-comment">// 接受页面</span>
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, e =&gt; <span class="hljs-built_in">console</span>.log(e))</code></pre>
<p>有安全方面顾虑的话最好把 * 改为特定的域名</p>
</div></div><div class="memo"><div class="my-md"><p>Sublime 安装问题以及解决</p>
<h3 id="there-are-no-packages-available-for-install">There are no packages available for install</h3>
<p>修改 Package Control 设置，增加</p>
<pre><code><span class="hljs-string">"channels"</span>:
    [
        <span class="hljs-string">"http://cst.stu.126.net/u/json/cms/channel_v3.json"</span>
    ]</code></pre><h3 id="-package-control">无法安装 Package Control</h3>
<p>下载 Package Control.sublime-package 放入 Sublime Installed Package 目录下</p>
</div></div><div class="memo"><div class="my-md"><p>为了实现隐藏一个元素的滚动条但仍可以在鼠标移入其中时进行滚动操作，
可以通过将其用父元素包裹，并将父元素设为</p>
<pre><code class="language-css">overflow: hidden;</code></pre>
<p>同时将其向右偏移或者增宽，这样可以使得其滚动条隐藏在父元素之下，类似</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">calss</span>=<span class="hljs-string">"wrapper"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"overflow: hidden; width: 200px"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"inner"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"max-height: 10px; overflow: scroll; width: 220px"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>的写法</p>
</div></div><div class="memo"><div class="my-md"><p>关于React-Router中 <code>browserHisory</code> 和 <code>hashHistory</code> 的区别，
前者的URL类似 <code>xx/xx</code> 后者是 <code>/#/xx</code> 由于HTTP协议的约定，URL中 <code>#</code> 后作为片段(frag)不会随请求发送至后台，
所以不需要服务器进行特殊配置，而前者是借助浏览器下的 <code>history</code> API实现，
在IE8/9下会导致跳页时Full Load，并且需要服务器配置接受所有请求都返回 <code>index.html</code> 。
优点时使得站点有清晰干净的URL，并且服务器端渲染只能通过这种方式实现，固推荐使用 <code>browserHistory</code></p>
</div></div><div class="memo"><div class="my-md"><p>Javascript中字符串替换API</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> replacement = <span class="hljs-function">(<span class="hljs-params">match, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span>, offset, string</span>) =&gt;</span>{}
<span class="hljs-comment">// 其中的replacement可以是一个回调函数</span>
<span class="hljs-built_in">String</span>.replace(reg, replacement)</code></pre>
<p>通过种方法可以实现将被匹配的文本做特殊的转化后再替换的功能<br>具体参数意义以及接口可见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace">这篇文档</a></p>
</div></div><div class="memo"><div class="my-md"><p>在 React <code>children</code> 属性有着特殊的含义，所以如下代码</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span> (<span class="hljs-params">props</span>) </span>{
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{props.children}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
    )
}

&lt;MyComponent children=<span class="hljs-string">'舒客舒克'</span>&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
&lt;<span class="hljs-regexp">/MyComponent&gt;</span></code></pre>
<p>最终显示出来的是按钮而不是舒客舒克，但是如果是按照如下方式调用则会显示舒客舒克</p>
<pre><code class="language-js"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">children</span>=<span class="hljs-string">'舒客舒克'</span> /&gt;</span></code></pre>
<p>由此可见在 React 中 <code>props.children</code> 会优先被传入的子元素覆盖</p>
</div></div><div class="memo"><div class="my-md"><p>随意使用通配符来设定样式可能会引来问题，例如有如下样式</p>
<pre><code class="language-css">* {
    <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-selector-tag">p</span> {
    <span class="hljs-attribute">color</span>: black;
}</code></pre>
<p>我们希望页面上的段落中字体颜色都为黑色<br>由于样式继承的存在，假设我们的文档结构如下</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...<span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>
<p>我们会认为 <code>&lt;em&gt;</code> 会继承 <code>&lt;p&gt;</code> 的样式，字体颜色同样为黑色<br>但结果可能会出乎意料 <code>&lt;em&gt;</code> 的字体颜色会显示为红色<br>这是因为继承而来的样式没有特殊性，而通配符设置的样式特殊性为 0<br>哪怕是 0 特殊性仍然会覆盖掉没有特殊性的样式<br>所以不建议使用通配符来设定页面的样式</p>
</div></div><div class="memo"><div class="my-md"><p>jQuery可以通过 <code>$(':visible')/$(':hidden')</code> 来查找可见/不可见的Dom元素
(通过判断元素的height和width是否大于0，所以</p>
<pre><code class="language-css"><span class="hljs-selector-tag">opacity</span><span class="hljs-selector-pseudo">:0</span>;
<span class="hljs-selector-tag">visibility</span>: <span class="hljs-selector-tag">hidden</span>;</code></pre>
<p>的元素会被认为是可见的)。
这俩种选择器会带来性能上的问题，尽量避免使用，
一定要使用的话也应该先通过纯CSS选择器将目标选出再通过 <code>$(dom).is(':visible')</code> 或 <code>$(dom).is(':hidden')</code> 判断，
或者通过 <code>$(dom).filter(':visible')</code> 或 <code>$(dom).filter(':hidden')</code> 过滤</p>
</div></div><div class="memo"><div class="my-md"><p>jQuery核心函数的几种重载形式：</p>
<pre><code class="language-js">$(($) =&gt; {  <span class="hljs-comment">//文档加载完毕  //相当于$( document ).ready()  })</span>
$(<span class="hljs-string">'selector'</span>) <span class="hljs-comment">// 选择器</span>
$(<span class="hljs-string">'selector'</span>, parentDom) <span class="hljs-comment">// 选择器(在父元素的范围下)</span>
$(dom) <span class="hljs-comment">// 将Dom对象包装成jQuery对象</span>
$(domArray) <span class="hljs-comment">// 将Dom对象的数组包装成jQuery对象</span>
$() <span class="hljs-comment">// 1.4以后返回空的jQuery对象</span>
$(<span class="hljs-string">'&lt;div&gt;&lt;/div&gt;'</span>) <span class="hljs-comment">// 将Html字符串包装成jQuery对象</span>
$(<span class="hljs-string">'&lt;div&gt;'</span>, {<span class="hljs-string">'class'</span>: <span class="hljs-string">'a'</span>}) <span class="hljs-comment">// 生成一个标签并包装成jQuery对象</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>关于 Webpack output 配置中的 [hash]/[chunkhash]/[contenthash]<br>[hash] 会在每一构建时都重新生成一个唯一的哈希值，会导致所有的静态资源文件都不会被浏览器缓存<br>[chunkhash] 会根据不同的 entry 来计算hash值,如果一个 entry 中的文件被修改过则会产生不同的哈希值<br>缺点在于假设有一个 Css 以及 JS 文件都来自同一 entry 会导致输出中的这俩个文件名包含的哈希值相同<br>也就是说，如果只变动了 Css 文件也会同时影响到 JS 文件的缓存<br>[contenthash] 会根据每个输出文件的内容来计算哈希值，只要有过改动则会产生不同的值，推荐使用这个</p>
</div></div><div class="memo"><div class="my-md"><p>想实现鼠标悬浮在一个父元素上能触发其子元素在 <code>:hover</code> 下的样式，
之前的思路是通过借助jQuery <code>$(parent).hover(() =&gt; $(son).hover())</code>来实现，
今天突然发现原来的方法太复杂，其实只需要几行CSS即可实现想要的效果，类似 </p>
<pre><code class="language-css">.parent:hover .son {
    <span class="hljs-comment">// 这里是鼠标悬浮在父元素上时子元素的样式</span>
}</code></pre>
<p>先前的思路在使用原生的Javascript时更难实现，因为原生的规范中并没有hover事件，
与之相关的是鼠标的 <code>mouseenter/mouseleave/mousemove</code> 事件，
而即使是在代码中触发了这些事件也是无法触发CSS的 <code>:hover</code> 状态的</p>
</div></div><div class="memo"><div class="my-md"><p>在使用</p>
<pre><code class="language-js"><span class="hljs-selector-tag">gulp</span><span class="hljs-selector-class">.src</span>(...)<span class="hljs-selector-class">.pipe</span>(...)<span class="hljs-selector-class">.pipe</span>(...)</code></pre>
<p>的过程中会发现当出错时控制台中报出的错误信息很难看懂,这是由于在Node.js中stream出错时会抛出error事件，
而上述代码里没有写有关错误事件的处理函数，所以Node会默认的报出堆栈跟踪信息作为错误信息。
如果采取如下捕获异常事件的方式来处理错误</p>
<pre><code class="language-js">gulp.src().pipe().on(<span class="hljs-string">'err'</span>, () =&gt; {})</code></pre>
<p>会使代码变得很复杂，推荐使用Pump的方式来进行处理</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> pump = <span class="hljs-built_in">require</span>(<span class="hljs-string">'pump'</span>)
pump([gulp.src(), uglify(), concat()], cb)</code></pre>
</div></div><div class="memo"><div class="my-md"><p>在新的HTML5规范中，如果一个元素拥有ID属性，那么ID属性的属性值就会成为window对象的属性名，
属性值就是ID对应的元素。如果下列标签中的元素拥有name属性</p>
<ul>
<li><code>&lt;a&gt;</code></li>
<li><code>&lt;applet&gt;</code></li>
<li><code>&lt;area&gt;</code></li>
<li><code>&lt;embed&gt;</code></li>
<li><code>&lt;form&gt;</code></li>
<li><code>&lt;frame&gt;</code></li>
<li><code>&lt;frameset&gt;</code></li>
<li><code>&lt;iframe&gt;</code></li>
<li><code>&lt;img&gt;</code></li>
<li><code>&lt;object&gt;</code></li>
</ul>
<p>那么name属性的属性值就会成为window对象的属性名。
例如页面上有这么一个元素</p>
<pre><code class="language-html">&lt;div id=<span class="hljs-string">'a'</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="hljs-string">`
在script中
`</span><span class="hljs-string">``</span>js
<span class="hljs-built_in">console</span>.info(a)  <span class="hljs-comment">//结果为&lt;div id='a'&gt;&lt;/div&gt;</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>在条件语句中申明函数会出现的情况</p>
<pre><code class="language-js"><span class="hljs-comment">// 不建议使用这种形式</span>
<span class="hljs-comment">// 估计许多语法校验工具会视这种写法为错误写法</span>

<span class="hljs-comment">// 按照ES6的  Block-Scoped Function</span>
<span class="hljs-comment">// 理论上调用a()和b()时应该报错</span>
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1'</span>)
    }
} <span class="hljs-keyword">else</span> {
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2'</span>)
    }
} 
a() <span class="hljs-comment">// 1</span>

<span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) {
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1'</span>)
    }
} <span class="hljs-keyword">else</span> {
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'2'</span>)
    }
} 
b() <span class="hljs-comment">// 2</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>在使用webpack提供的alias特性时，如果配置了eslint的import/no-unresolved规则<br>会发现eslint并不会识别alias，然后当你使用alias时会报错<br>这时需要借助<a href="https://github.com/benmosher/eslint-plugin-import/tree/master/resolvers/webpack">eslint-import-resolver-webpack</a><br>然后再.eslintrc文件中增加配置项  </p>
<pre><code class="language-js">{
    <span class="hljs-attribute">settings</span>: {
        <span class="hljs-string">'import/resolver'</span>: {
            webpack: {
                // 配置alias的文件路径
                config: <span class="hljs-string">'./webpack.base.js'</span>
            }
        }
    }
}</code></pre>
</div></div><div class="memo"><div class="my-md"><p>关于 <code>Date</code> 对象有几点需要注意 <code>new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]])</code>
使用这个构造函数时 <code>month</code> 参数0代表一月，11代表十二月，
同理 <code>dateObj.getMonth()</code> 一月返回0，十二月返回11<code>dateObj.getDay()</code> 0代表周日，6代表周一<code>}, {
    date:</code>2017/11/22<code>,
    content:</code>
关于 <code>typeof</code> 一共有六种可能结果</p>
<ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>undefined</li>
<li>function</li>
<li>object</li>
<li>symbol // ES6新增</li>
</ul>
<p>其中有一种较怪异的行为需注意<code>typeof null // 'object'</code></p>
</div></div><div class="memo"><div class="my-md"><p>在WebView中动态设置title</p>
<pre><code class="language-js">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// 利用iframe的onload事件刷新页面</span>
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">'xxxxxxxx'</span>
    <span class="hljs-keyword">const</span> iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'iframe'</span>)
    iframe.style.visibility = <span class="hljs-string">'hidden'</span>
    iframe.style.width = <span class="hljs-string">'1px'</span>
    iframe.style.height = <span class="hljs-string">'1px'</span>
    iframe.onload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-built_in">document</span>.body.removeChild(iframe)
        }, <span class="hljs-number">0</span>)
    }
    <span class="hljs-built_in">document</span>.body.appendChild(iframe)
}, <span class="hljs-number">0</span>)</code></pre>
</div></div><div class="memo"><div class="my-md"><p>在 HTML 中一个带有初始值的输入框可以简单写作 <code>&lt;input value="hello" /&gt;</code><br>但在 React 中由于推崇使用 Controlled Component  </p>
<pre><code class="language-js">ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"hello"</span> /&gt;</span>, document.getElementById('root'))</span></code></pre>
<p>会发现上述代码生成的输入框虽然正确设置了初始值但是用户无法对其进行修改<br>要修复这个问题需要加上</p>
<pre><code class="language-js">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{null}</span> /&gt;</span>, document.getElementById('root'))
}, 1000)</span></code></pre>
<p>也就是在一段时延后将其 value 修改为 <code>null</code><br>当然最好的方式还是直接使用 Controlled Component</p>
</div></div><div class="memo"><div class="my-md"><p>给定一组数 <code>1 2 3 4 5 6 7 8 9</code> 在其间隔处任意加上 <code>+ - * / 空白</code> 五种操作符<br>列出其所有计算结果为 <code>100</code> 的组合</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> num = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]
<span class="hljs-keyword">const</span> operators = [<span class="hljs-string">''</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'-'</span> , <span class="hljs-string">'*'</span>, <span class="hljs-string">'/'</span>]

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursive</span>(<span class="hljs-params">t, i</span>) </span>{
    <span class="hljs-keyword">let</span> str
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> operator <span class="hljs-keyword">of</span> operators) {
        str = t + operator + num[i]
        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">7</span>) {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">eval</span>(str) === <span class="hljs-number">100</span>) <span class="hljs-built_in">console</span>.log(str, <span class="hljs-built_in">eval</span>(str))
        } <span class="hljs-keyword">else</span> {
            recursive(str, i+<span class="hljs-number">1</span>)
        }
    }
}

<span class="hljs-comment">// 以 1 为起始进行递归</span>
recursive(<span class="hljs-string">'1'</span>, <span class="hljs-number">0</span>)
</code></pre>
</div></div><div class="memo"><div class="my-md"><p>Iterator 实现斐波那契数列</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> febonacci = {
    [<span class="hljs-built_in">Symbol</span>.iterator]() {
        <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>
        <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> {
            next() {
                <span class="hljs-keyword">const</span> value = b
                <span class="hljs-keyword">let</span> done = b &gt;= <span class="hljs-number">1000</span> <span class="hljs-comment">// 超过1000结束迭代</span>
                b = a
                a = value + a       

                <span class="hljs-keyword">return</span> {
                    value,
                    done
                }
            },
            <span class="hljs-keyword">return</span>() {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Stop iterate'</span>)
                <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }
            }
        }
    }
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> febonacci) {
    <span class="hljs-built_in">console</span>.log(i)
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">500</span>) {
        <span class="hljs-keyword">break</span>;
    }
}</code></pre>
</div></div><div class="memo"><div class="my-md"><pre><code class="language-js"><span class="hljs-keyword">const</span> listeners = []
listeners.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)
})
listeners.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)
})

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) {
    <span class="hljs-keyword">const</span> listener = listeners[i]
    listener() <span class="hljs-comment">// 指向 window</span>
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) {
    listeners[i]() <span class="hljs-comment">// 指向 listeners 数组</span>
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> listener <span class="hljs-keyword">of</span> listeners) {
    listener() <span class="hljs-comment">// 指向 window</span>
}</code></pre>
<p>理解这个问题关键在于认识到数组在 Javascript 中其实只是一种特殊的对象</p>
</div></div><div class="memo"><div class="my-md"><p>关于 Closure 的几个代码片段</p>
<pre><code class="language-js"><span class="hljs-comment">// var let const 不会影响Closure</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>
    <span class="hljs-keyword">const</span> c = <span class="hljs-number">3</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(a, b, c)
    }

    <span class="hljs-keyword">return</span> bar
}

foo()()

<span class="hljs-comment">// Arrow Function不会影响Closure</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>
    <span class="hljs-keyword">const</span> c = <span class="hljs-number">3</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(a, b, c)
}

foo()()

<span class="hljs-comment">// setTimeout会创建一个Closure</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">message</span>) </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(message)
    }, <span class="hljs-number">1000</span>)
}

wait(<span class="hljs-string">'hi'</span>)</code></pre>
</div></div><div class="memo"><div class="my-md"><p>关于采集站点的PV、UV数据，传统的做法是当页面load完成后像后台发送数据，
当作一次PV但在SPA(Single Page App)以及PWA(Progressive Web App)的情景下，这样的断定方式显得不那么合理，
用户有可能一天中只Load一次页面然后在一天的任意时间段在这个应用中活动
而不需要再一次Load页面考虑用更新的方式进行统计可能比较合理，
例如借助<a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API">Page Visibility API</a>
在用户初次打开应用浏览以及过去合理的一段时间后(可以用Session持续的最长时间来判断)后
从其它再次切换到这个Tab页都作为一次PV
详情可见这篇<a href="https://philipwalton.com/articles/how-we-track-pageviews-is-all-wrong/">Blog</a></p>
</div></div><div class="memo"><div class="my-md"><p>关于 NPM 的 <code>dependencies</code> <code>devDependencies</code> <code>peerDependencies</code><br>项目实际依赖的包通常是 <code>dependencies</code> 通过 <code>npm i package --save-prod</code> 或者默认的 <code>npm i package</code> 安装的包会被列在该目录下<br>仅在开发过程中被使用的依赖是 <code>devDependencies</code> 通过 <code>npm i package --save-dev</code> 会被列在该目录下，类似 <code>babel</code> <code>sass</code> <code>webpack</code> 等通常属于这一类<br>最后 <code>peerDependencies</code> 通常会在开发一些插件包的时候被使用。例如开发一个 React 的 UI 组件，如果其他开发者想要使用的话必须确保在他的本地环境中已经安装好了使用该 UI 组件的 <code>peerDependencies</code> 例如特定版本的 <code>react</code> 。这样做的好处是可以尽可能的减少不必要的依赖被安装。</p>
</div></div><div class="memo"><div class="my-md"><p>关于在 Promise 中使用 <code>return Promise.reject()</code> 以及 <code>return new Error()</code> 的不同</p>
<pre><code class="language-js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'a'</span>)
.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>) {
    <span class="hljs-keyword">return</span> res
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'error'</span>)
    <span class="hljs-comment">// return new Error('error')</span>
  }
}, err =&gt; {
  <span class="hljs-built_in">console</span>.error(err + <span class="hljs-string">'1 reject'</span>)
}).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-comment">// 使用 return new Error() 会执行</span>
  <span class="hljs-built_in">console</span>.log(res + <span class="hljs-string">'2 fulfill'</span>)
}, err =&gt; {
    <span class="hljs-comment">// 使用 return Promise.reject() 会执行</span>
  <span class="hljs-built_in">console</span>.error(err + <span class="hljs-string">'2 reject'</span>)
})</code></pre>
</div></div><div class="memo"><div class="my-md"><p>关于 ES6 新引入的 Regexp Sticky Mode (适用于匹配一串以一定规则重复的字符串)</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/foo/</span>
<span class="hljs-keyword">var</span> regSticky = <span class="hljs-regexp">/foo/y</span>
<span class="hljs-keyword">var</span> str = <span class="hljs-string">'***foo***'</span>

reg.test(str) <span class="hljs-comment">// true</span>
reg.lastIndex = <span class="hljs-number">4</span>
reg.test(str) <span class="hljs-comment">// true</span>

regSticky.test(str) <span class="hljs-comment">// false</span>
regSticky.lastIndex = <span class="hljs-number">3</span> <span class="hljs-comment">// 只有在lastIndex处完全匹配 才算做匹配成功</span>
regSticky.test(str) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(regSticky.lastIndex) <span class="hljs-comment">// 6 匹配成功会将lastIndex移动至匹配结果后紧接着的index</span>
regSticky.test(str) <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(regSticky.lastIndex) <span class="hljs-comment">// 0 匹配失败会将lastIndex重置为0</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>项目中开发接入支付宝跳转流程时碰到了一个问题<br>需要通过 Ajax 向后台请求跳转 URL 并通过 <code>window.open()</code> 在新窗口中打开<br>由于浏览器限制只允许在 Dom 事件处理函数中通过 <code>window.open()</code> 来打开新页面<br>所以如果直接在请求成功的回调函数中进行操作会发现打开新窗口的操作被浏览器拦截<br>需要用户确认允许该页面弹窗才能正常跳转<br>该问题的最终解决方案如下</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 先在点击事件中打开原项目的中转页</span>
    <span class="hljs-keyword">const</span> newWindow = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">'redirect.html'</span>, <span class="hljs-string">'_blank'</span>)
    axios.post(<span class="hljs-string">'xxx'</span>)
    .then(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> newWindow.location.href = url) <span class="hljs-comment">// 请求成功 将新页面的地址修改为后台返回的 URL</span>
    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> newWindow.close()) <span class="hljs-comment">// 请求失败 关闭新开的窗口</span>
}</code></pre>
</div></div><div class="memo"><div class="my-md"><p>如果确定一个Component再初始化后不需要重新render，可以在组件中声明</p>
<pre><code class="language-js">shouldComponentUpdate (nextProps, nextState) {<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;}</code></pre>
<p>这会使React跳过对该组件是否需要重绘的检查，并且跳过调用</p>
<ul>
<li>componentWillUpdate()</li>
<li>render()</li>
<li>componentDidUpdate()
获得性能上的提升。
还有一种情况下，如果你希望只有在组件的部分属性发生变化时才检查，可以通过在上述方法中比较
<code>nextProps</code> 和 <code>nextState</code> 中的指定值是否发生变化来实现。
还可以通过继承React提供的 <code>React.PureComponent</code> 来方便的实现上述需求，
PureComponent只会对属性进行浅比较，当属性的数据结构复杂，层级较深时比较可能会失败
从而一直返回false导致组件不会发生更新
就最近的经验来看，把一些展示型的组件设为PureComponent可以获得较为明显的性能提升</li>
</ul>
</div></div><div class="memo"><div class="my-md"><p>如何通过函数模拟 <code>new</code> 操作符？Javascript 中 <code>new</code> 到底做了什么？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeNew</span> (<span class="hljs-params">construct, ...params</span>) </span>{
    <span class="hljs-keyword">const</span> o = <span class="hljs-built_in">Object</span>.create(construct.prototype)
    <span class="hljs-keyword">const</span> re = construct.apply(o, params)
    <span class="hljs-comment">// 当构造函数中会返回一个引用类型的值时 最终 new 操作符返回的是这个值 而不是新构造的对象</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> re === <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> re === <span class="hljs-string">'function'</span>) ? re : o
}

<span class="hljs-comment">// test</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span> (<span class="hljs-params">name, age</span>) </span>{
    <span class="hljs-keyword">this</span>.name = name
    <span class="hljs-keyword">this</span>.age = age
}
Foo.prototype.hello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span> <span class="hljs-subst">${<span class="hljs-keyword">this</span>.age}</span>`</span>)
}

<span class="hljs-keyword">const</span> a = fakeNew(Foo, <span class="hljs-string">'a'</span>, <span class="hljs-number">18</span>)</code></pre>
</div></div><div class="memo"><div class="my-md"><p>在各类 Dom 事件中可以通过</p>
<pre><code class="language-js"><span class="hljs-comment">// e.path Chrome采用 非标准属性</span>
<span class="hljs-comment">// e.composedPath() 标准属性 最新的 FF Chrome Safari都兼容</span>
<span class="hljs-keyword">const</span> path = e.path || (e.composedPath &amp;&amp; e.composedPath())

<span class="hljs-comment">// 如果需要兼容更低版本的浏览器 可以自己去遍历</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPath</span>(<span class="hljs-params">e</span>) </span>{
    <span class="hljs-keyword">const</span> path = []
    <span class="hljs-keyword">let</span> dom = e.target || e.srcElement
    <span class="hljs-keyword">while</span> (dom) {
        path.push(dom)

        <span class="hljs-comment">// 为了和composedPath()行为一致</span>
        <span class="hljs-keyword">if</span> (dom.tagName === <span class="hljs-string">'HTML'</span>) {
            path.push(<span class="hljs-built_in">document</span>)
            path.push(<span class="hljs-built_in">window</span>)

            <span class="hljs-keyword">return</span> path
       }

        dom = dom.parentNode
    }
}</code></pre>
<p>去获取这个事件从触发事件的 Dom 节点开始到 Window 的 Dom 路径</p>
</div></div><div class="memo"><div class="my-md"><p>JavaScript 实现大数相加</p>
<pre><code class="language-js"><span class="hljs-comment">/**
*    在JS中超出Math.pow(2,53) 也就是 9007199254740992 的整数会失去精度
*     包括通过parseInt()无法正确转化 在console中无法直接输出等 只能通过字符串的形式进行操作或传输
**/</span>
<span class="hljs-comment">// 入参 字符串形式的大数a和b</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{
    a = a.split(<span class="hljs-string">''</span>)
  b = b.split(<span class="hljs-string">''</span>)
  <span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>
  <span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>
  <span class="hljs-keyword">while</span> (a.length || b.length || c &gt; <span class="hljs-number">0</span>) {
      c += ~~a.pop() + ~~b.pop() <span class="hljs-comment">//各位对应相加 结果可能是0~18</span>
    result = c%<span class="hljs-number">10</span> + result
    c = c&gt;<span class="hljs-number">9</span> ? ~~(c/<span class="hljs-number">10</span>) : <span class="hljs-number">0</span> <span class="hljs-comment">// 处理可能的进位</span>
  }

  <span class="hljs-keyword">return</span> result.replace(<span class="hljs-regexp">/^0+/</span>,<span class="hljs-string">''</span>) <span class="hljs-comment">// 处理以0开头的数字</span>
}

<span class="hljs-built_in">console</span>.log(sum(<span class="hljs-string">'9007199254740992'</span>, <span class="hljs-string">'1007199254740992'</span>))</code></pre>
</div></div><div class="memo"><div class="my-md"><p>众所周知，页面的加载顺序是从上至下的，并且浏览器中的 JavaScript 为单线程执行<br>所以当碰到 <code>&lt;script src="xxx"&gt;&lt;/script&gt;</code> 时，浏览器会等待脚本下载并执行完才继续渲染页面<br>如果脚本文件很大或者网络较慢就会导致浏览器长时间处于白屏状态，不那么耐心的用户可能会选择直接关闭网页<br>起初开发者想到的优化办法是尽可能的把 <code>&lt;script&gt;</code> 放到页面底部（也就是 <code>&lt;/body&gt;</code> 前）<br>这样脚本加载便不会影响到页面最初的渲染效率了<br>HTML5 新引入了 <code>defer</code> 以及 <code>async</code> 来优化这个过程  </p>
<ul>
<li><code>&lt;script defer src="xxx"&gt;&lt;/script&gt;</code>  会使脚本的下载与页面渲染并行进行<br>当页面渲染完毕后才去依次执行下载完的脚本文件</li>
<li><code>&lt;script async src="xxx"&gt;&lt;/script&gt;</code>  也会使脚本的下载与页面渲染并行进行<br>与 <code>defer</code> 的区别在于一等到脚本下载完成浏览器便会暂停渲染并执行相应的脚本  </li>
</ul>
<p><a href="https://segmentfault.com/q/1010000000640869">点击看图</a></p>
</div></div><div class="memo"><div class="my-md"><p>由于 React Component 只允许有一个根结点<br>所以当碰到当我们当组件由一个列表组成时需要在最外层加上一个额外的 <code>&lt;div&gt;</code>  </p>
<pre><code class="language-js">function Columns() {
    // 如果该组件嵌套在 <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span> 中 =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Columns</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    // 会导致最终生成的 HTML 不符合标准 =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    return (
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    )
}</code></pre>
<p>现在我们可以借助 <code>React.Fragment</code> 来解决这个问题</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Columns</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span>
    )
}</span></code></pre>
<p>如果不需要像 Fragment 传递 Props 或者 key, 可以采用简</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Columns</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/&gt;</span>
    )
}</span></code></pre>
</div></div><div class="memo"><div class="my-md"><p>为什么说使用无单位的数字来设置 <code>line-height</code> 最好  </p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font-size: 12px; line-height: 1.5em; width: 60px;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font-size: 40px;"</span>&gt;</span>段落内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font-size: 12px; line-height: 1.5; width: 60px;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font-size: 40px;"</span>&gt;</span>段落内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>上述代码中的俩个 <code>div</code> 样式差别仅在于 <code>line-height</code>。<br>但是可以发现第一个段落中的文字会重叠在一起，因为当使用带单位的值时子元素继承的 <code>line-height</code> 是计算值而不是比例。所以第一个段落的实际计算行高为 <code>18px(12px * 1.5em)</code> 而字体大小为 <code>40px</code>，第二个段落的行高为 <code>60px(40px * 1.5)</code> 字体大小与第一段相同。
所以第一段中的文字会发生重叠，为了避免这种问题通常建议使用无单位的数字来设置 <code>line-height</code>。<br>Ps: <code>line-height</code> 的值最好不要设置小于 1.5 ，这样才能保持文本良好的可读性</p>
</div></div><div class="memo"><div class="my-md"><p>JavaScript 实现数组乱序</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]

<span class="hljs-comment">// 错误的方法 以下代码并不能做到真正乱序</span>
<span class="hljs-comment">// 由于Array.sort()内部的实现方式导致</span>
<span class="hljs-comment">// Array.prototype.sort(comparefn)</span>
<span class="hljs-comment">// Calling comparefn(a,b) always returns the same value v when given a specific pair of values a and b as its two arguments.</span>
arr.sort(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span>)

<span class="hljs-comment">// 进阶班 保证对于相同的a,b arr.sort()比较产生的结果相同</span>
<span class="hljs-keyword">const</span> random = arr.map(<span class="hljs-built_in">Math</span>.random);
arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> random[a] - random[b]);

<span class="hljs-comment">// Fisher–Yates shuffle</span>
<span class="hljs-keyword">let</span> i = arr.length
<span class="hljs-keyword">while</span>(i) {
    <span class="hljs-keyword">const</span> random = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()*i);
  i--;
  [arr[i], arr[random]] = [arr[random], arr[i]]
}</code></pre>
</div></div><div class="memo"><div class="my-md"><p>关于 JavaScript 中的 Timer <code>setTimeout</code> 以及 <code>setInterval</code></p>
<ul>
<li>每次调用会返回一个自增的 ID 用于传入 <code>clearTimeout</code> 以及<code>clearInterval</code> 来清除计时器</li>
<li>由于 JavacScript 是单线程的，所以这俩个函数并不能确保一定会在指定时间到达后立即执行  </li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 超出 100ms 一段时间后才会输出</span>
<span class="hljs-comment">// 因为线程被循环阻塞</span>
<span class="hljs-built_in">console</span>.time(<span class="hljs-string">'执行间隔'</span>)
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">'执行间隔'</span>), <span class="hljs-number">100</span>)

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000000000</span>; i++){}</code></pre>
<ul>
<li>不传入延时参数时默认为 0ms，哪怕延时 0ms 也是异步，只有主线程空闲时才执行</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 输出顺序为 2 1</span>
<span class="hljs-comment">// 并不会按正常执行顺序输出</span>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>))

<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)</code></pre>
<ul>
<li><code>setInterval</code> 所指的间隔并不是指多长时间执行一次，而是多长时间将该函数放到执行队列中一次<br>所以当传入其中的函数执行时间超过所设的间隔时间时，函数真实的执行间隔可能为 0ms</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();
<span class="hljs-keyword">const</span> timer = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    i++;
    i === <span class="hljs-number">5</span> &amp;&amp; clearInterval(timer);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`第<span class="hljs-subst">${i}</span>次开始`</span>, <span class="hljs-built_in">Date</span>.now() - start);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) {}
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`第<span class="hljs-subst">${i}</span>次结束`</span>, <span class="hljs-built_in">Date</span>.now() - start);
}, <span class="hljs-number">100</span>);</code></pre>
<p>Ps: 还有一个 IE 专属的 <code>setImmediate</code> 可以理解为 <code>setTimeout(0)</code> 的替代，在此不做展开</p>
</div></div><div class="memo"><div class="my-md"><p>一种特殊的数组去重方法，不考虑兼容性的话最好直接使用 <code>Array.from(new Set(originArr))</code> </p>
<pre><code class="language-js"><span class="hljs-comment">// 该方法有个缺陷</span>
<span class="hljs-comment">// 不能兼容一些特殊情况 因为JSON.stringify()方法有一些特例</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">let</span> obj = {}

  arr.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
      <span class="hljs-keyword">let</span> key = <span class="hljs-built_in">JSON</span>.stringify(item) + <span class="hljs-keyword">typeof</span> item <span class="hljs-comment">// 避免基本类型 类似 1与'1' stringify后作为key相同</span>

    obj[key] = item<span class="hljs-comment">// 利用JS对象的key不能重复的特性</span>
  })

  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.values(obj))<span class="hljs-comment">// 打印结果数组</span>
}
<span class="hljs-comment">// 注意以下特例</span>
unique([<span class="hljs-literal">undefined</span>,<span class="hljs-string">'undefined'</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">'null'</span>,<span class="hljs-literal">NaN</span>,<span class="hljs-string">'NaN'</span>,<span class="hljs-literal">Infinity</span>,<span class="hljs-string">'Infinity'</span>,-<span class="hljs-literal">Infinity</span>,<span class="hljs-string">'-Infinity'</span>])
<span class="hljs-comment">// 无法进行深度比较 也就无法区分 [1,2,3] 和 [1,2,3] 类似这样的引用类型</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uniqueBySet</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr)))
}

<span class="hljs-keyword">let</span> test1 = [<span class="hljs-number">1</span>,<span class="hljs-string">'1'</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-string">'true'</span>]
unique(test1)
uniqueBySet(test1)
<span class="hljs-keyword">let</span> test2 = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], {<span class="hljs-attr">a</span> : <span class="hljs-number">1</span>}, {<span class="hljs-attr">a</span> : <span class="hljs-string">'1'</span>}, {<span class="hljs-attr">b</span> : <span class="hljs-number">1</span>}, {<span class="hljs-attr">b</span> : <span class="hljs-number">1</span>}]
unique(test2)
uniqueBySet(test2)
<span class="hljs-keyword">let</span> test3 = [<span class="hljs-literal">undefined</span>, <span class="hljs-string">'undefined'</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'null'</span>]
unique(test3)
uniqueBySet(test3)
<span class="hljs-keyword">let</span> a = {<span class="hljs-attr">a</span> : <span class="hljs-number">1</span>}
<span class="hljs-keyword">let</span> test4 = [a , a,  {<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>}]
unique(test4)
uniqueBySet(test4)</code></pre>
</div></div><div class="memo"><div class="my-md"><p>一些有关 Javascript 变量提升的实例</p>
<pre><code class="language-js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> a = b = <span class="hljs-number">1</span>;<span class="hljs-comment">// var 声明的是a 导致b其实是一个全局变量</span>
})();

<span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a)<span class="hljs-comment">//undefined 注意 如果直接试图使用a变量会抛出错误 但在typeof操作符后就不会</span>
<span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">// Uncaught ReferenceError: a is not defined</span>


(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">    'use strict'</span><span class="hljs-comment">// 严格模式下不加var声明会直接报错</span>
    <span class="hljs-keyword">var</span> a = b = <span class="hljs-number">1</span>;<span class="hljs-comment">// Uncaught ReferenceError: b is not defined</span>
})();


<span class="hljs-comment">// 函数声明会提升 函数表达式不会</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
   <span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">// undefined</span>
   <span class="hljs-built_in">console</span>.log(foo());<span class="hljs-comment">// 2</span>
   <span class="hljs-built_in">console</span>.log(bar());<span class="hljs-comment">// Uncaught TypeError: bar is not a function</span>
   <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-comment">// 函数声明</span>
      <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
   }
   <span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<span class="hljs-comment">// 函数表达式</span>
           <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
   }
})()


<span class="hljs-comment">/*
相当于
var a
function a(){ return 1 }
a=123
console.log(a)
*/</span>
<span class="hljs-keyword">var</span> a=<span class="hljs-number">123</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> }
<span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">//123 </span>


<span class="hljs-comment">/*
相当于
var a
function a(){ return 1 }
a()
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> }
<span class="hljs-keyword">var</span> a;
a();<span class="hljs-comment">// 1</span>

<span class="hljs-comment">/**
const和let不会申明提升？
*/</span>
<span class="hljs-keyword">typeof</span> a; <span class="hljs-keyword">var</span> a=<span class="hljs-number">1</span>;
<span class="hljs-keyword">typeof</span> a; <span class="hljs-keyword">const</span> a=<span class="hljs-number">1</span>; <span class="hljs-comment">//Uncaught ReferenceError: a is not defined</span>
<span class="hljs-keyword">typeof</span> a; <span class="hljs-keyword">let</span> a=<span class="hljs-number">1</span>; <span class="hljs-comment">//Uncaught ReferenceError: a is not defined</span>

</code></pre>
</div></div><div class="memo"><div class="my-md"><p>初学者在 React 中处理事件时会碰到 <code>this</code> 指向为 <code>undefined</code> 的问题</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    handleClick() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)
    }

    render () {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">"this.handleClick"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
    }
}</code></pre>
<p>如果在页面上点击上述组件会发现打印出来的是 <code>undefined</code><br>当我们想要在函数中通过 <code>this.setState()</code> 去改变组件状态时会报错<br>解决这个问题可以通过下面三种方式</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-comment">// 借助 Function.prototype.bind</span>
        <span class="hljs-keyword">this</span>.handleClick = <span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>)
    }
    handleClick() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)
    }

    render() {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
    }
}</code></pre>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-comment">// 使用 public class fields syntax 来声明函数</span>
    handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)
    }

    render() {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
    }
}</code></pre>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    handleClick() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)
    }

    <span class="hljs-comment">// 借助箭头函数</span>
    <span class="hljs-comment">// 这种方式的缺点是每次 Button 组件的重绘都需要生成一个新函数</span>
    <span class="hljs-comment">// 当这个函数被当作 props 传入子组件时 可能会导致不必要的重绘</span>
    <span class="hljs-comment">// 所以更推荐采用先前的俩种方式</span>
    <span class="hljs-comment">// 但是当需要传递多余参数当时候可能不得不采用这种这种形式</span>
    <span class="hljs-comment">// 下面会给出当碰到渲染长列表的性能问题时如何进行优化</span>
    render() {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{e</span> =&gt;</span> this.handleClick(e)}&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alphabet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    state = {
        <span class="hljs-attr">num</span>: <span class="hljs-literal">null</span>
    }
    <span class="hljs-comment">// 通过将数据存放到 HTML 的 data-num 属性中来避免使用箭头函数引起的性能问题</span>
    handleClick = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
        <span class="hljs-keyword">this</span>.setState({
            <span class="hljs-attr">num</span>: e.target.dataset.num
        })
    }

    render() {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
                {[1,2,3].map(num =&gt;
                    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{num}</span> <span class="hljs-attr">data-num</span>=<span class="hljs-string">{num}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleClick}</span>&gt;</span>
                        {num}
                    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                )}
            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
        )
    }
}</code></pre>
</div></div></section></main></div></div>
<script type="text/javascript" src="main.60205f80f3b24de616b7.js"></script>
</body></html>