<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>MinimalistYing.io-Memo</title>
	
	<link rel="shortcut icon" type="image/x-icon" href="./assets/img/favicon.ico">
	<link rel="stylesheet" type="text/css" href="./assets/css/main.css">
</head>
<body>
	<header>
        <h3 class="header-title">MinimalistYing.io</h3>
        <nav>
            <ul>
                <li ><a href="./index.html">Home</a></li>
                <li ><a href="https://github.com/MinimalistYing">Github</a></li>
            </ul>
        </nav>
    </header>
    <main class="memo-main">
    	<div class="memo-col">
			<div class="memo-card">为了使<pre>display: inline-block</pre>在IE8中起作用，必须在文档开头加上<pre>&lt;!DOCTYPE html&gt;</pre>并在头部加上<pre>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</pre></div>

			<div class="memo-card">判断一个值是否为<pre>NaN</pre>一定要通过<pre>isNaN()</pre>而不是通过等号比较，因为<pre>NaN !== NaN</pre></div>
    	</div>
    	<div class="memo-col">
			<div class="memo-card">IE8中的伪元素只支持类似<pre>:after</pre>的写法，不支持<pre>::after</pre>的写法</div>

			<div class="memo-card">通过Javascript<pre>element.scrollTop = value</pre>或者jQuery<pre>$(dom).scrollTop(value)</pre>去设置滚动条滚动位置时，注意所选取的元素就是设置了<pre>overflow-y : scroll</pre>的元素</div>
    	</div>
    	<div class="memo-col">
			<div class="memo-card">在使用Javascript的<pre>parseInt()</pre>时，最好显示的指明进制，因为<pre>parseInt('0x16') = 22</pre>而你可能期望的结果是<pre>parseInt('0x16') = 0</pre>所以显示的指定进制才能做到真正的结果可控<pre>parseInt('0x16', 16) = 22</pre><pre>parseInt('0x16', 10) = 0</pre></div>

			<div class="memo-card">为了实现隐藏一个元素的滚动条但仍可以在鼠标移入其中时进行滚动操作，可以通过将一个带有滚动条的元素用父元素包裹，并将父元素设为<pre>overflow : hidden</pre>同时将其向右偏移或者增宽，这样可以使得其滚动条隐藏在父元素之下，类似<pre>
			&lt;div calss=&quot;wrapper&quot; style=&quot;overflow : hidden&quot;&gt;
			<br/>
			&lt;div class=&quot;inner&quot; style=&quot;overflow : hidden&quot;&gt;&lt;/div&gt;
			<br/>&lt;/div&gt;
			</pre>的写法</div>
    	</div>
    	<div class="memo-col">
			<div class="memo-card">在Javascript中进行浮点数运算是不可靠的，遵循IEEE 754标准，二进制的浮点数运算不能正确的处理十进制小数，例如典型的<pre>0.1 + 0.2 !== 0.3</pre>在一定的精度范围内可通过将小数转化为整数再进行比较来解决这个问题</div>
    	</div>
    </main>
    <aside class="memo-anchor">
		<ul></ul>
    </aside>
</body>
</html>