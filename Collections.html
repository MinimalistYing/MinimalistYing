<!DOCTYPE html><html><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0">
	<meta name="baidu-site-verification" content="e7Xf8PjkZ4">
	<meta name="description" content="小影子的博客，记录工作经验，分享前端技术~">
	<meta name="keyword" content="博客 前端 技术 Blog FrontEnd Experience">
	<title>MinimalistYing.io</title>
	<script charset="utf-8" src="https://hmcdn.baidu.com/static/tongji/plugins/UrlChangeTracker.js"></script><script src="https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb"></script><script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb";
			var s = document.getElementsByTagName("script")[0]; 
			s.parentNode.insertBefore(hm, s);
		})();
	</script>
<link rel="shortcut icon" href="favicon.ico"><link href="main.da41f8ae8d650f389d21.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="0.ef1bd9dbce806a540650.css"><script charset="utf-8" src="0.e3fc404a03ea51474c0f.bundle.js"></script><script charset="utf-8" src="5.4749751c69454854f14e.bundle.js"></script><link rel="stylesheet" type="text/css" href="2.41696c5507cad7d5f341.css"><script charset="utf-8" src="2.510b9aa996f2336192b4.bundle.js"></script></head>
<body>
	<div id="app"><div><header><h3 class="header-title">MinimalistYing.io</h3><nav><ul><li><a href="/index.html">博客</a></li><li><a href="/memo.html">备忘</a></li><li><a href="https://codepen.io/MinimalistYing" target="_blank">代码库</a></li><li><a href="https://leetcode.com/MinimalistYing" target="_blank">Leetcode</a></li><li><a href="https://stackoverflow.com/users/8459774/minimalistying" target="_blank">StackOverflow</a></li><li><a href="https://github.com/MinimalistYing" target="_blank">Github</a></li></ul></nav></header><div class="blogs"><div class="blog"><div class="my-md"><h1 id="new-collections-in-es6">New Collections In ES6</h1>
<h2 id="map">Map</h2>
<p>以往当我们需要一种键/值对形式的数据结构时通常使用的是原生的 Object</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> o = {}
o[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>
o[<span class="hljs-string">'a'</span>] = <span class="hljs-string">'a'</span>
<span class="hljs-built_in">console</span>.log(o) <span class="hljs-comment">// { 1: 1, a: 'a'}</span>
o[<span class="hljs-string">'1'</span>] = <span class="hljs-number">2</span>
<span class="hljs-built_in">console</span>.log(o) <span class="hljs-comment">// {1: 2, a: 'a'}</span>

<span class="hljs-keyword">const</span> map = {}
<span class="hljs-keyword">const</span> x = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }
<span class="hljs-keyword">const</span> y = { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> }
map[x] = <span class="hljs-number">1</span>
map[y] = <span class="hljs-number">2</span>
<span class="hljs-comment">// 因为x.toString() === '[object Object]'</span>
<span class="hljs-built_in">console</span>.log(map) <span class="hljs-comment">// {[object Object]: 2}</span></code></pre>
<p>可以看到这种方法有一个缺陷，由于 Object 的 Key 只能是字符串<br>这样生成的 Map 同样只能以字符串作为键<br>ES6 提供了对 Map 的原生支持，它可以将任何数据类型作为 Key</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()
<span class="hljs-keyword">const</span> x = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }
<span class="hljs-comment">// 支持链式调用</span>
map.set(x, <span class="hljs-number">1</span>).set(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>).set(<span class="hljs-string">'2'</span>, <span class="hljs-string">'2string'</span>)
    .set(<span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'sym'</span>), <span class="hljs-string">'symbol'</span>).set(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>)

map.get(x) <span class="hljs-comment">// 1</span>
map.get(<span class="hljs-number">2</span>) <span class="hljs-comment">// 2</span>
map.get(<span class="hljs-string">'2'</span>) <span class="hljs-comment">// 2string</span>
map.get(<span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'sym'</span>)) <span class="hljs-comment">// 'symbol'</span>
map.get(<span class="hljs-literal">true</span>) <span class="hljs-comment">// true</span>

map.size <span class="hljs-comment">// 5</span>

map.delete(<span class="hljs-literal">true</span>)
map.delete(x)
map.delete(<span class="hljs-string">'2'</span>)

map.size <span class="hljs-comment">// 2</span>

map.has(<span class="hljs-number">2</span>) <span class="hljs-comment">// true</span>
map.has(<span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'sym'</span>)) <span class="hljs-comment">// true</span>

[...map.keys()] <span class="hljs-comment">// [2, Symbol(sym)]</span>
[...map.values()] <span class="hljs-comment">// [2, "symbol"]</span>
[...map.entries()] <span class="hljs-comment">// [[2, 2], [Symbol(sym), "symbol"]]</span>

map.clear()
map.size <span class="hljs-comment">// 0</span></code></pre>
<p>Map 的实例是 Iterable 的，并且其默认的 Iterator 与 <code>map.entries()</code> 返回的结果一致<br>所以以下方法都可以用于拷贝产生一个新的 Map</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()
<span class="hljs-keyword">const</span> copy2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(map.entries())
<span class="hljs-keyword">const</span> copy1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(map) <span class="hljs-comment">// 推荐 更简洁</span></code></pre>
<h2 id="weakmap">WeakMap</h2>
<p>WeakMap 的大部分行为与 Map 一致，主要区别在于 WeakMap 对内存分配机制的特殊处理<br>WeakMap 的 Key 只能是 Object ，并且当作为 Key 的 Object 被 GC 回收后<br>其存储在 WeakMap 中的 Entry 也会随之被销毁<br>WeakMap 相较 Map 而言只提供了 <code>set()</code> <code>get()</code> <code>delete()</code> <code>has()</code> 四个有限的API<br>尤其适用于需要把不受我们控制的对象(例如 DOM 对象)作为 Key 值的情况</p>
<h2 id="set">Set</h2>
<p>ES6 新增的 Set 用于存储一系列不重复的值<br>其判断是否重复的规则除了 Set 会认为 +0 等与 -0 外都与 <code>Object.is()</code> 相同</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
<span class="hljs-keyword">const</span> x = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> }
<span class="hljs-keyword">const</span> y = { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> }
<span class="hljs-comment">// 支持链式调用</span>
set.add(x).add(y).add(x)

set.size <span class="hljs-comment">// 2</span>

set.delete(y)
set.size <span class="hljs-comment">// 1</span>

set.has(x) <span class="hljs-comment">// true</span>
set.clear()
set.size <span class="hljs-comment">// 0</span>

set.add(<span class="hljs-number">1</span>).add(<span class="hljs-string">'1'</span>).add(<span class="hljs-number">2</span>);
[...set.keys()] <span class="hljs-comment">// [1, "1", 2]</span>
[...set.values()] <span class="hljs-comment">// [1, "1", 2]</span>
[...set.entries()] <span class="hljs-comment">// [[1, 1], ["1", "1"], [2, 2]]</span></code></pre>
<p>与 Map 不同的是 Set 实例的默认 Iterator 与 <code>values()</code> 相同<br>可以利用 Set 来进行数组去重</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">'4'</span>]
<span class="hljs-keyword">const</span> unique = [...new <span class="hljs-built_in">Set</span>(arr)]
<span class="hljs-built_in">console</span>.log(unique) <span class="hljs-comment">// [1, 2, 3, 4, "4"]</span></code></pre>
<h2 id="weakset">WeakSet</h2>
<p>同 WeakMap 类似，WeakSet 中存储的值只能是 Object
并且当 Object 被 GC 后 WeakSet 也会自动将其从集合中删除</p>
</div></div><div id="category" class="category-box"><ul class="blogs-category"><li id="AntdForm" class="">Ant Design 表单的一些进阶使用方式</li><li id="CSSModules" class="">CSS Modules</li><li id="GuiLin" class="">桂林山，阳朔水</li><li id="MongoTooManyOpenFiles" class="">记一次解决 MongoDB 报错的心路历程</li><li id="MoesifBug" class="">记一次 Chrome 更新导致插件故障引发的问题</li><li id="Frameworks" class="">关于前端框架选型的一些思考</li><li id="LowDesireSociety" class="">观后感：《低欲望社会》大前研一</li><li id="Cascading" class="">浅谈 CSS（Cascading Style Sheets) 之层叠</li><li id="Axios" class="">Axios 源码解析</li><li id="VueVsReact" class="">React 与 Vue 的一些对比</li><li id="WhyPreflight" class="">为什么 CORS 需要在跨域请求前进行预校验 (Preflight)</li><li id="ArraySort" class="">Array.prototype.sort() 在使用默认 CompareFn 时的问题</li><li id="BinaryTreeType" class="">常见的二叉树类型</li><li id="Ajax" class="">Ajax (Asynchronous JavaScript And XML)</li><li id="XSSCSRF" class="">关于 XSS 以及 CSRF</li><li id="CookieAndWebStorage" class="">Cookie 和 WebStorage</li><li id="CrossOrigin" class="">关于跨域</li><li id="WebpackCommonProblem" class="">记录配置 Webpack 过程中碰到的问题以及解决方案</li><li id="SourceMapAndWebpack" class="">关于 Source Map 以及 Webpack 中 Devtool 的相关配置</li><li id="BinaryTreeTraversal" class="">二叉树的遍历</li><li id="ReactRedux" class="">React-Redux 从入门到后悔</li><li id="Redux" class="">Redux 从入门到放弃</li><li id="PreventModalScroll" class="">如何阻止模态框 (Modal / Popup / Dialog) 弹出后 Body 可滚动</li><li id="PromiseBlog" class="">Promise In ES6</li><li id="Collections" class="selected">New Collections In ES6</li><li id="ObjectAPI" class=""> Object's New API In ES6</li><li id="ArrayAPI" class="">Array's New API In ES6</li><li id="Generator" class="">Generator in ES6</li><li id="WebpackV3ToV4" class="">Webpack V3 升级至 V4</li><li id="IteratorBlog" class="">Iterator in ES6</li><li id="SymbolBlog" class="">Symbols in ES6</li><li id="GulpPlugin" class="">如何编写一个自己的GulpPlugin</li><li id="WebpackBaseConfig" class="">Webpack(v3.8.1)</li></ul></div><div class="category-toggle"></div></div></div></div>
<script type="text/javascript" src="main.d008203a7b2c68848879.js"></script>
</body></html>