<!DOCTYPE html><html><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0">
	<meta name="baidu-site-verification" content="e7Xf8PjkZ4">
	<meta name="description" content="小影子的博客，记录工作经验，分享前端技术~">
	<meta name="keyword" content="博客 前端 技术 Blog FrontEnd Experience">
	<title>MinimalistYing.io</title>
	<script charset="utf-8" src="https://hmcdn.baidu.com/static/tongji/plugins/UrlChangeTracker.js"></script><script src="https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb"></script><script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb";
			var s = document.getElementsByTagName("script")[0]; 
			s.parentNode.insertBefore(hm, s);
		})();
	</script>
<link rel="shortcut icon" href="favicon.ico"><link href="main.963473cab43172722d02.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="0.34dc1d228a2b3001916f.css"><script charset="utf-8" src="0.9d82b534399ca40448c9.bundle.js"></script><script charset="utf-8" src="5.4749751c69454854f14e.bundle.js"></script><link rel="stylesheet" type="text/css" href="2.1102e7ba37877810cde5.css"><script charset="utf-8" src="2.2397e918c534f0d6fc83.bundle.js"></script></head>
<body>
	<div id="app"><div><header><h3 class="header-title">MinimalistYing.io</h3><nav><ul><li><a href="/index.html">博客</a></li><li><a href="/memo.html">备忘</a></li><li><a href="https://codepen.io/MinimalistYing" target="_blank">代码库</a></li><li><a href="https://leetcode.com/MinimalistYing" target="_blank">Leetcode</a></li><li><a href="https://stackoverflow.com/users/8459774/minimalistying" target="_blank">StackOverflow</a></li><li><a href="https://github.com/MinimalistYing" target="_blank">Github</a></li></ul></nav></header><div class="blogs"><div class="blog"><div class="my-md"><h1 id="react-redux-">React-Redux 从入门到后悔</h1>
<h2 id="-">序</h2>
<p>Redux 作为一个简单的用于管理应用状态的工具，可以与任何其它的前端框架共用<br>当然，尤其适用于数据驱动视图的框架(Vue/React/Angular)<br>React-Redux 利用高阶组件(HOC) / Context<br>将 React UI 的更新与 Redux Store 的变化绑定在了一起</p>
<h2 id="how-to-use">How to use</h2>
<p>首先，用 <code>&lt;Provider&gt;</code> 包裹根组件</p>
<pre><code class="language-js"><span class="hljs-comment">// 新建Redux的Store</span>
<span class="hljs-keyword">const</span> store = createStore(reducers)

ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>,
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
)</code></pre>
<p>然后通过</p>
<pre><code class="language-js"><span class="hljs-selector-tag">connect</span>(<span class="hljs-selector-attr">[mapStateToProps]</span>, <span class="hljs-selector-attr">[mapDispatchToProps]</span>, <span class="hljs-selector-attr">[mergeProps]</span>, <span class="hljs-selector-attr">[options]</span>)(<span class="hljs-selector-tag">Comp</span>)</code></pre>
<p>这样就能得到注入 Redux 后的新组件<br>如果不传入<code>mapStateToProps</code>，则不会在该组件中去监听<code>store</code>的变化<br>如果不传入<code>mapDispatchToProps</code>，则默认只将<code>dipatch</code>注入组件  </p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect()(Comp)</code></pre>
<p>将<code>dispatch</code>注入组件<br>这样在组件中就可以通过<code>this.props.dispatch(action)</code>来修改Redux的<code>store</code><br>但不会去监听<code>store</code>的变化</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function">(<span class="hljs-params">state, ownProps</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">all</span>: state.total + ownProps.total }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(mapStateToProps)(Comp)</code></pre>
<p>注入<code>all</code>以及<code>dispatch</code>，并且监听<code>store</code>的变化<br>当<code>store</code>中的<code>total</code>或者组件自身的<code>total</code>发生变化时都会重绘组件</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> mapDispatchToProps = <span class="hljs-function"><span class="hljs-params">dispatch</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">addTodo</span>: <span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> dispatch(todoActionCreator(todo))
        <span class="hljs-comment">// 可以在此处借助bindActionCreators</span>
        <span class="hljs-comment">// addTodo: bindActionCreators(todoActionCreator, dispatch)</span>
    }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(<span class="hljs-literal">null</span>, mapDispatchToProps)(Comp)</code></pre>
<p>不监听 <code>store</code> 在组件中可以通过调用<code>this.props.addTodo('xx')</code>来改变应用状态</p>
<h2 id="-">源码中学习到的小技巧</h2>
<p>React-Redux 默认通过以下方法来比较组件的Props是否相等<br>如果不等则意味着组件需要进行重绘</p>
<pre><code class="language-js"><span class="hljs-comment">// 通过hasOwn.call(xx, xx)</span>
<span class="hljs-comment">// 相较于xx.hasOwnProperty(xx) 更简洁？</span>
<span class="hljs-keyword">const</span> hasOwn = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty

<span class="hljs-comment">// Object.is()的Polyfill</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is</span>(<span class="hljs-params">x, y</span>) </span>{
    <span class="hljs-keyword">if</span> (x === y) {
        <span class="hljs-comment">// Object.is(0, -0) =&gt; false</span>
        <span class="hljs-keyword">return</span> x !== <span class="hljs-number">0</span> || y !== <span class="hljs-number">0</span> || <span class="hljs-number">1</span> / x === <span class="hljs-number">1</span> / y 
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Object.is(NaN, NaN) =&gt; true</span>
        <span class="hljs-keyword">return</span> x !== x &amp;&amp; y !== y
    }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowEqual</span>(<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">if</span> (is(a, b)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>

    <span class="hljs-comment">// 如果a或者b不是object 并且Object.is(a, b) =&gt; false</span>
    <span class="hljs-comment">// 则认为a和b不等</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">'object'</span> || a === <span class="hljs-literal">null</span> ||
        <span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">'object'</span> || b === <span class="hljs-literal">null</span>
    ) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }

    <span class="hljs-keyword">const</span> keysA = <span class="hljs-built_in">Object</span>.keys(a)
    <span class="hljs-keyword">const</span> keysB = <span class="hljs-built_in">Object</span>.keys(b)

    <span class="hljs-comment">// 在a和b都是object的情况下</span>
    <span class="hljs-comment">// 如果a与b的所有key值相同 并且与之对应的value都满足Object.is(v1, v2) =&gt; true</span>
    <span class="hljs-comment">// 则也认为a和b相等</span>
    <span class="hljs-keyword">if</span> (keysA.length !== keysB.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keysA.length; i++) {
        <span class="hljs-keyword">if</span> (!hasOwn.call(b, keysA[i]) ||
            !is(objA[keysA[i]], objB[keysA[i]])
        ) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}</code></pre>
<hr>
<p>React的PropTypes除了进行如下的基础校验</p>
<pre><code class="language-js">number string object bool func
array
symbol
node <span class="hljs-comment">// 任何可以被当作节点绘制的类型</span>
element <span class="hljs-comment">// React Element</span></code></pre>
<p>还可以利用相关API进行更严格的格式校验</p>
<pre><code class="language-js">MyComponent.propTypes = {
    <span class="hljs-comment">// 指定值中的其中一个 类似枚举类型</span>
    xx: PropTypes.oneOf([<span class="hljs-string">'News'</span>, <span class="hljs-string">'Photos'</span>]),
    <span class="hljs-comment">// 特定实例</span>
    xx: PropTypes.instanceOf(Foo),
    <span class="hljs-comment">// 多种可选基础类型</span>
    xx: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.number
    ]),
    <span class="hljs-comment">// 只包含特定类型值的数组</span>
    xx: PropTypes.arrayOf(PropTypes.number),
    <span class="hljs-comment">// 只包含特定类型值的对象</span>
    xx: PropTypes.objectOf(PropTypes.number),
    <span class="hljs-comment">// 必须包含指定属性的对象</span>
    xx: PropTypes.shape({
        <span class="hljs-attr">xx</span>: PropTypes.number,
        <span class="hljs-attr">yy</span>: PropTypes.bool.isRequired
    }),
    <span class="hljs-comment">// 只能包含指定属性的对象</span>
    xx: PropTypes.exact({
        <span class="hljs-attr">xx</span>: PropTypes.number,
        <span class="hljs-attr">yy</span>: PropTypes.bool.isRequired
    }),
    <span class="hljs-comment">// 任意值</span>
    xx: PropTypes.any.isRequired
}</code></pre>
<hr>
<p>React 的高阶组件(HOC)并不会自动将被包裹组件的静态方法自动继承到新返回的组件中<br>会导致以下问题</p>
<pre><code class="language-js">WrappedComponent.staticMethod = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}

<span class="hljs-keyword">const</span> EnhancedComponent = HOC(WrappedComponent)
EnhancedComponent.staticMethod <span class="hljs-comment">// =&gt; undefined</span></code></pre>
<p>可以借助<a href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</a>来解决这个问题</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> hoistNonReactStatic <span class="hljs-keyword">from</span> <span class="hljs-string">'hoist-non-react-statics'</span>

<span class="hljs-keyword">const</span> EnhancedComponent = hoistNonReactStatic(HOC(WrappedComponent), WrappedComponent)
EnhancedComponent.staticMethod <span class="hljs-comment">// =&gt; () =&gt; {}</span></code></pre>
</div></div><div id="category" class="category-box"><ul class="blogs-category"><li class="">记一次 Chrome 更新导致插件故障引发的问题</li><li class="">关于前端框架选型的一些思考</li><li class="">观后感：《低欲望社会》大前研一</li><li class="">浅谈 CSS（Cascading Style Sheets) 之层叠</li><li class="">Axios 源码解析</li><li class="">React 与 Vue 的一些对比</li><li class="">为什么 CORS 需要在跨域请求前进行预校验 (Preflight)</li><li class="">Array.prototype.sort() 在使用默认 CompareFn 时的问题</li><li class="">常见的二叉树类型</li><li class="">Ajax (Asynchronous JavaScript And XML)</li><li class="">关于 XSS 以及 CSRF</li><li class="">Cookie 和 WebStorage</li><li class="">关于跨域</li><li class="">记录配置 Webpack 过程中碰到的问题以及解决方案</li><li class="">关于 Source Map 以及 Webpack 中 Devtool 的相关配置</li><li class="">二叉树的遍历</li><li class="selected">React-Redux 从入门到后悔</li><li class="selected">Redux 从入门到放弃</li><li class="">如何阻止模态框 (Modal / Popup / Dialog) 弹出后 Body 可滚动</li><li class="">Promise In ES6</li><li class="">New Collections In ES6</li><li class=""> Object's New API In ES6</li><li class="">Array's New API In ES6</li><li class="">Generator in ES6</li><li class="">Webpack V3 升级至 V4</li><li class="">Iterator in ES6</li><li class="">Symbols in ES6</li><li class="">如何编写一个自己的GulpPlugin</li><li class="">Webpack(v3.8.1)</li></ul></div><div class="category-toggle"></div></div></div></div>
<script type="text/javascript" src="main.ad613e76dfba0372d7c6.js"></script>
</body></html>