<!DOCTYPE html><html><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0">
	<meta name="baidu-site-verification" content="e7Xf8PjkZ4">
	<meta name="description" content="小影子的博客，记录工作经验，分享前端技术~">
	<meta name="keyword" content="博客 前端 技术 Blog FrontEnd Experience">
	<title>MinimalistYing.io</title>
	<script charset="utf-8" src="https://hmcdn.baidu.com/static/tongji/plugins/UrlChangeTracker.js"></script><script src="https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb"></script><script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb";
			var s = document.getElementsByTagName("script")[0]; 
			s.parentNode.insertBefore(hm, s);
		})();
	</script>
<link rel="shortcut icon" href="favicon.ico"><link href="main.da41f8ae8d650f389d21.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="0.ef1bd9dbce806a540650.css"><script charset="utf-8" src="0.e3fc404a03ea51474c0f.bundle.js"></script><script charset="utf-8" src="5.4749751c69454854f14e.bundle.js"></script><link rel="stylesheet" type="text/css" href="2.41696c5507cad7d5f341.css"><script charset="utf-8" src="2.510b9aa996f2336192b4.bundle.js"></script></head>
<body>
	<div id="app"><div><header><h3 class="header-title">MinimalistYing.io</h3><nav><ul><li><a href="/index.html">博客</a></li><li><a href="/memo.html">备忘</a></li><li><a href="https://codepen.io/MinimalistYing" target="_blank">代码库</a></li><li><a href="https://leetcode.com/MinimalistYing" target="_blank">Leetcode</a></li><li><a href="https://stackoverflow.com/users/8459774/minimalistying" target="_blank">StackOverflow</a></li><li><a href="https://github.com/MinimalistYing" target="_blank">Github</a></li></ul></nav></header><div class="blogs"><div class="blog"><div class="my-md"><h1 id="promise-in-es6">Promise In ES6</h1>
<h2 id="-">序</h2>
<p>以往我们通常用回调函数来处理异步编程<br>但类似下例中嵌套过深的回调会使程序的可读性很差（也就是人们通常说的 Callback Hell）  </p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">cb</span>) </span>{
    asyncFunc1(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        cb()
        asyncFunc2(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            cb()
            asyncFun3(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                cb()
            })
        })
    })
}</code></pre>
<p><code>Promise</code> 的出现为开发者提供了一种更优雅的方式来处理异步编程</p>
<h2 id="-promise">如何构造一个 <code>Promise</code></h2>
<pre><code class="language-js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> rand = <span class="hljs-built_in">Math</span>.random()
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (rand &gt; <span class="hljs-number">0.5</span>) {
            resolve(<span class="hljs-string">'finish'</span>)
        } <span class="hljs-keyword">else</span> {
            reject(<span class="hljs-string">'err'</span>)
        }
    }, <span class="hljs-number">3000</span>)
})

<span class="hljs-comment">// 在3秒后输出 'finish' or 'err'</span>
p.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res))
.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err))

<span class="hljs-comment">// 同上</span>
p.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res), err =&gt; <span class="hljs-built_in">console</span>.log(err))</code></pre>
<p>一个 <code>Promise</code> 最终只会有俩种状态 <strong>fulfilled</strong> 或 <strong>rejected</strong><br>前者可以在 <code>then()</code> 的第一个参数中获得处理完成的结果<br>后者可以在 <code>then()</code> 的第二个参数或者 <code>catch()</code> 中获得处理失败的原因<br>每一个 <code>Promise</code> 只会被 resolve(fulfill 或 reject)一次<br>并且一旦当 <code>Promise</code> 执行完毕，它就成为了一个不可变的值  </p>
<h2 id="-promise-">为什么说 <code>Promise</code> 更优雅</h2>
<p><code>Promise</code> 支持链式调用<br>我们将上例中重写一遍 高下立判</p>
<pre><code class="language-js">asyncFunc1().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> asyncFunc2()
}).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> asyncFunc3()
}).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(res)
})</code></pre>
<h2 id="promise-api">Promise API</h2>
<h3 id="promise-resolve-promise-reject-">Promise.resolve() 和 Promise.reject()</h3>
<pre><code class="language-js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>)
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(<span class="hljs-number">1</span>))

<span class="hljs-keyword">const</span> p3 = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">1</span>)
<span class="hljs-keyword">const</span> p4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(<span class="hljs-number">1</span>))</code></pre>
<p>可以通过 <code>Promise.resolve()</code> 将 thenable 对象转为真正的 <code>Promise</code> 对象<br>如果你以前用了类似 <code>Promise</code> 语法的异步处理库<br>现在想将其行为转成和 <code>Promise</code> 一致时可能会用到</p>
<h3 id="promise-all-">Promise.all([...])</h3>
<p>该方法的入参是一个包含多个 Promise 对象的数组<br>它会等到其中所有的 Promise 完成(fulfilled)后将结果集返回<br>或者其中任意一个 Promise 失败(rejected)后将错误抛出</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-number">1</span>
<span class="hljs-keyword">const</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)
<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        resolve(<span class="hljs-number">3</span>)
    }, <span class="hljs-number">3000</span>)
})

<span class="hljs-comment">// 3s 后输出 [1, 2, 3]</span>
<span class="hljs-built_in">Promise</span>.all([p1, p2, p3]).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res))

<span class="hljs-keyword">const</span> e1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        reject(<span class="hljs-string">'err'</span>)
    }, <span class="hljs-number">1000</span>)
})

<span class="hljs-comment">// 1s 后输出 "err"</span>
<span class="hljs-built_in">Promise</span>.all([p1, p2, p3, e1])
.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res))
.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err))</code></pre>
<h3 id="promise-race-">Promise.race([...])</h3>
<p>与 <code>Promise.all()</code> 不同，该方法只会取入参中所有 Promise 中最快返回的结果<br>不管是接受(resolve)或是拒绝(reject)<br>其余 Promise 的处理结果都会被忽略</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        resolve(<span class="hljs-number">1</span>)
    }, <span class="hljs-number">1000</span>)
})
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        resolve(<span class="hljs-number">2</span>)
    }, <span class="hljs-number">2000</span>)
})
<span class="hljs-comment">// 1s 后输出 1</span>
<span class="hljs-comment">// 无论执行多少遍都是该结果 永远不会输出2</span>
<span class="hljs-built_in">Promise</span>.race([p1, p2]).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res))</code></pre>
<p>要注意的是当传入空数组时 <code>Promise.all([])</code> 会立即执行完毕<br>而 <code>Promise.race([])</code> 会永远处于等待状态，所以建议永远别这么使用 Promise</p>
<h2 id="async-await-es7-"><code>async</code> + <code>await</code> （ES7）</h2>
<p>当 ES6 的 Generator 与 Promise 共同使用时可以产生一些更酷的特性<br>让我们能够像写同步代码一样去实现异步过程<br>但是需要实现一个特殊的 Runner 来执行这个 Generator<br>ES7新增了语法糖 <code>async</code> 以及 <code>await</code> 来帮助我们更便捷的使用这一特性</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFunc1</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">'1 done'</span>)
        }, <span class="hljs-number">3000</span>)
    })
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFunc2</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">'2 done'</span>)
        }, <span class="hljs-number">3000</span>)
    })
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFunc3</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-string">'3 done'</span>)
        }, <span class="hljs-number">3000</span>)
    })
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> res1 = <span class="hljs-keyword">await</span> asyncFunc1()
    <span class="hljs-built_in">console</span>.log(res1)
    <span class="hljs-keyword">const</span> res2 = <span class="hljs-keyword">await</span> asyncFunc2()
    <span class="hljs-built_in">console</span>.log(res2)
    <span class="hljs-keyword">const</span> res3 = <span class="hljs-keyword">await</span> asyncFunc3()
    <span class="hljs-built_in">console</span>.log(res3)
}

<span class="hljs-comment">// 3s后 "1 done"</span>
<span class="hljs-comment">// 再3s后 "2 done"</span>
<span class="hljs-comment">// 再3s后 "3 done"</span>
main()</code></pre>
<p>可以看到，相较于 <code>Promise.then(...).then(...)</code><br>这种方式让异步程序的执行过程更加一目了然
需要注意的一点是 <code>await</code> 只能出现在 <code>async</code> 函数中<br>也就是说直接出现在最外层代码中的 <code>const res = await fetch('xxx')</code> 是错误的<br>除此之外，<code>await</code> 还可以和 <code>Promise.all()</code> 一起使用</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> allRes = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([
        fetch(<span class="hljs-string">'aaa'</span>),
        fetch(<span class="hljs-string">'bbb'</span>)
    ])
}</code></pre>
</div></div><div id="category" class="category-box"><ul class="blogs-category"><li id="CSSModules" class="">CSS Modules</li><li id="GuiLin" class="">桂林山，阳朔水</li><li id="MongoTooManyOpenFiles" class="">记一次解决 MongoDB 报错的心路历程</li><li id="MoesifBug" class="">记一次 Chrome 更新导致插件故障引发的问题</li><li id="Frameworks" class="">关于前端框架选型的一些思考</li><li id="LowDesireSociety" class="">观后感：《低欲望社会》大前研一</li><li id="Cascading" class="">浅谈 CSS（Cascading Style Sheets) 之层叠</li><li id="Axios" class="">Axios 源码解析</li><li id="VueVsReact" class="">React 与 Vue 的一些对比</li><li id="WhyPreflight" class="">为什么 CORS 需要在跨域请求前进行预校验 (Preflight)</li><li id="ArraySort" class="">Array.prototype.sort() 在使用默认 CompareFn 时的问题</li><li id="BinaryTreeType" class="">常见的二叉树类型</li><li id="Ajax" class="">Ajax (Asynchronous JavaScript And XML)</li><li id="XSSCSRF" class="">关于 XSS 以及 CSRF</li><li id="CookieAndWebStorage" class="">Cookie 和 WebStorage</li><li id="CrossOrigin" class="">关于跨域</li><li id="WebpackCommonProblem" class="">记录配置 Webpack 过程中碰到的问题以及解决方案</li><li id="SourceMapAndWebpack" class="">关于 Source Map 以及 Webpack 中 Devtool 的相关配置</li><li id="BinaryTreeTraversal" class="">二叉树的遍历</li><li id="ReactRedux" class="">React-Redux 从入门到后悔</li><li id="Redux" class="">Redux 从入门到放弃</li><li id="PreventModalScroll" class="">如何阻止模态框 (Modal / Popup / Dialog) 弹出后 Body 可滚动</li><li id="PromiseBlog" class="selected">Promise In ES6</li><li id="Collections" class="">New Collections In ES6</li><li id="ObjectAPI" class=""> Object's New API In ES6</li><li id="ArrayAPI" class="">Array's New API In ES6</li><li id="Generator" class="">Generator in ES6</li><li id="WebpackV3ToV4" class="">Webpack V3 升级至 V4</li><li id="IteratorBlog" class="">Iterator in ES6</li><li id="SymbolBlog" class="">Symbols in ES6</li><li id="GulpPlugin" class="">如何编写一个自己的GulpPlugin</li><li id="WebpackBaseConfig" class="">Webpack(v3.8.1)</li></ul></div><div class="category-toggle"></div></div></div></div>
<script type="text/javascript" src="main.8a084a3c90abaa7c0527.js"></script>
</body></html>