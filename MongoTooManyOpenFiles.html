<!DOCTYPE html><html><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0">
	<meta name="baidu-site-verification" content="e7Xf8PjkZ4">
	<meta name="description" content="小影子的博客，记录工作经验，分享前端技术~">
	<meta name="keyword" content="博客 前端 技术 Blog FrontEnd Experience">
	<title>MinimalistYing.io</title>
	<script charset="utf-8" src="https://hmcdn.baidu.com/static/tongji/plugins/UrlChangeTracker.js"></script><script src="https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb"></script><script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb";
			var s = document.getElementsByTagName("script")[0]; 
			s.parentNode.insertBefore(hm, s);
		})();
	</script>
<link rel="shortcut icon" href="favicon.ico"><link href="main.ba348b966d7b4dc69e1d.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="0.ef1bd9dbce806a540650.css"><script charset="utf-8" src="0.e3fc404a03ea51474c0f.bundle.js"></script><script charset="utf-8" src="5.4749751c69454854f14e.bundle.js"></script><link rel="stylesheet" type="text/css" href="2.41696c5507cad7d5f341.css"><script charset="utf-8" src="2.510b9aa996f2336192b4.bundle.js"></script></head>
<body>
	<div id="app"><div><header><h3 class="header-title">MinimalistYing.io</h3><nav><ul><li><a href="/index.html">博客</a></li><li><a href="/memo.html">备忘</a></li><li><a href="https://codepen.io/MinimalistYing" target="_blank">代码库</a></li><li><a href="https://leetcode.com/MinimalistYing" target="_blank">Leetcode</a></li><li><a href="https://stackoverflow.com/users/8459774/minimalistying" target="_blank">StackOverflow</a></li><li><a href="https://github.com/MinimalistYing" target="_blank">Github</a></li></ul></nav></header><div class="blogs"><div class="blog"><div class="my-md"><h1 id="-mongodb-">记一次解决 MongoDB 报错的心路历程</h1>
<h2 id="-">起因</h2>
<p>最近闲来无事打算学习一下 Node/MogoDB，新手上路难免出现问题。  </p>
<p>我试着在循环中去新建大量 Collections 来初始化数据库，代码如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">await</span> Mongo.connect(url)
  <span class="hljs-comment">// All 是一个包含了大概有 3000 个元素的数组</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> ALL) {
    <span class="hljs-keyword">const</span> db = client.db(<span class="hljs-string">'stock'</span>)
    <span class="hljs-keyword">const</span> collection = <span class="hljs-keyword">await</span> db.collection(item.symbol)
    <span class="hljs-keyword">await</span> collection.insertOne({
      <span class="hljs-attr">name</span>: item.name
    })
  }
  <span class="hljs-keyword">await</span> client.close()
}</code></pre>
<p>很简单对吧？但是问题的出现就是这么出其不意。  </p>
<p>当创建到第 112 个 Collection 时程序就会运行出错，抛出异常 <code>Too Many Open Files</code>，并且数据库的进程也会挂掉。</p>
<h2 id="-">探究原因</h2>
<p>首先从错误的字面意思看，大概猜测是数据库占用的资源超出了一定限制。  </p>
<p>Google 一下，发现 Mac 对当前进程能打开的最大的文件句柄数量的默认设置是 256。  </p>
<p>通过 <code>$ ulimit -a</code> 指令可以查看系统对当前进程的一些限制。  </p>
<p>通过 <code>$ ulimit -n 1024</code> 可以修改系统对当前进程最大打开文件数量的限制（Ps：修改只会对当前 Shell 有效）。  </p>
<p>我把限制从 256 增加到 1024，再次启动 Mongo 并执行程序，发现这次创建了 500 多个 Collection 才报错。看来这个错误确实和系统对最大可打开文件数的限制有关。  </p>
<p>但是，为什么 Mongo 会同时打开这么多文件呢？每次连接结束为什么不把占用的文件资源释放掉呢？会不会是程序没有正确的把资源释放？  </p>
<p>首先想到的可能是程序没有正确的关闭数据库连接，导致资源一直被占用。但是通过 Mongo <code>db.getServerStutus()</code> 观察，发现连接在程序结束时已经正确被关闭。  </p>
<p>但是当我重新执行程序时，发现创建第一个 Collection 时就会立马报错，哪怕重启 MogoDB 服务后重试仍是一样的结果。  </p>
<p>Emmmmmm... 重启都解决不了的问题确实很难办，只能推测这个错误和当前数据库所拥有的 Collection 数量有关。也就是说，不管是否有连接存在，Mongo 都会一直占用着与 Collection 相关的文件资源。  </p>
<p>然后就只能试着去找一下看 Mongo 的实现原理了：</p>
<blockquote>
<p> WiredTiger的工作原理跟MMAPv1不太一样，一个集合一个文件，一个索引一个文件。所以你一共有多少集合，至少就会有集合数量x2个打开文件（以1集合文件+1索引文件计算）被占用。再考虑到网络连接数量，要保证足够大的open files值。</p>
</blockquote>
<p>最新的 Mongo 默认使用 WiredTiger 作为存储引擎。也就是说，当你当数据库里有 1000 个 Collection。那么你至少需要支持同时打开 2000 个文件才能正确运行 Mongo 。  </p>
<p>这一点如果你在默认的 256 个最大文件数下启动 Mongo 就可以直接在命令行中看到如下提示</p>
<blockquote>
<p> I CONTROL [initandlisten] ** WARNING: soft rlimits too low. Number of files is 256, should be at least 1000</p>
</blockquote>
<p>解决办法就是尽可能的通过 <code>$ ulimit -n</code> 把系统对 Mongo 进程对最大文件数限制调大，例如 8192 。  </p>
<p>另外，从业务场景上来讲，一个数据库不应该有这么多 Collection，就像传统的 RDBMS 通常不会建几千张表一样。</p>
<h2 id="-">总结</h2>
<p>这个问题我来回折腾了一天才解决，一开始确实有点摸不着头脑。  </p>
<p>但对于一个熟悉 Mongo 或者数据库的人来讲这个问题可能太基础了，所以在网上也很少有相关问题的记录。  </p>
<p>可见对计算机基础知识以及一些技术原理的理解，在解决疑难问题时真的很重要。</p>
</div></div><div id="category" class="category-box"><ul class="blogs-category"><li id="MongoTooManyOpenFiles" class="selected">记一次解决 MongoDB 报错的心路历程</li><li id="MoesifBug" class="">记一次 Chrome 更新导致插件故障引发的问题</li><li id="Frameworks" class="">关于前端框架选型的一些思考</li><li id="LowDesireSociety" class="">观后感：《低欲望社会》大前研一</li><li id="Cascading" class="">浅谈 CSS（Cascading Style Sheets) 之层叠</li><li id="Axios" class="">Axios 源码解析</li><li id="VueVsReact" class="">React 与 Vue 的一些对比</li><li id="WhyPreflight" class="">为什么 CORS 需要在跨域请求前进行预校验 (Preflight)</li><li id="ArraySort" class="">Array.prototype.sort() 在使用默认 CompareFn 时的问题</li><li id="BinaryTreeType" class="">常见的二叉树类型</li><li id="Ajax" class="">Ajax (Asynchronous JavaScript And XML)</li><li id="XSSCSRF" class="">关于 XSS 以及 CSRF</li><li id="CookieAndWebStorage" class="">Cookie 和 WebStorage</li><li id="CrossOrigin" class="">关于跨域</li><li id="WebpackCommonProblem" class="">记录配置 Webpack 过程中碰到的问题以及解决方案</li><li id="SourceMapAndWebpack" class="">关于 Source Map 以及 Webpack 中 Devtool 的相关配置</li><li id="BinaryTreeTraversal" class="">二叉树的遍历</li><li id="ReactRedux" class="">React-Redux 从入门到后悔</li><li id="Redux" class="">Redux 从入门到放弃</li><li id="PreventModalScroll" class="">如何阻止模态框 (Modal / Popup / Dialog) 弹出后 Body 可滚动</li><li id="PromiseBlog" class="">Promise In ES6</li><li id="Collections" class="">New Collections In ES6</li><li id="ObjectAPI" class=""> Object's New API In ES6</li><li id="ArrayAPI" class="">Array's New API In ES6</li><li id="Generator" class="">Generator in ES6</li><li id="WebpackV3ToV4" class="">Webpack V3 升级至 V4</li><li id="IteratorBlog" class="">Iterator in ES6</li><li id="SymbolBlog" class="">Symbols in ES6</li><li id="GulpPlugin" class="">如何编写一个自己的GulpPlugin</li><li id="WebpackBaseConfig" class="">Webpack(v3.8.1)</li></ul></div><div class="category-toggle"></div></div></div></div>
<script type="text/javascript" src="main.b439df5ad0b326f3ff83.js"></script>
</body></html>