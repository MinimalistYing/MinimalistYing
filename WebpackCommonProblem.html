<!DOCTYPE html><html><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0">
	<meta name="baidu-site-verification" content="e7Xf8PjkZ4">
	<meta name="description" content="小影子的博客，记录工作经验，分享前端技术~">
	<meta name="keyword" content="博客 前端 技术 Blog FrontEnd Experience">
	<title>MinimalistYing.io</title>
	<script charset="utf-8" src="https://hmcdn.baidu.com/static/tongji/plugins/UrlChangeTracker.js"></script><script src="https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb"></script><script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?a3319bfaaf51660db9fb0bbf68d309cb";
			var s = document.getElementsByTagName("script")[0]; 
			s.parentNode.insertBefore(hm, s);
		})();
	</script>
<link rel="shortcut icon" href="favicon.ico"><link href="main.963473cab43172722d02.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="0.34dc1d228a2b3001916f.css"><script charset="utf-8" src="0.9d82b534399ca40448c9.bundle.js"></script><script charset="utf-8" src="5.4749751c69454854f14e.bundle.js"></script><link rel="stylesheet" type="text/css" href="2.1102e7ba37877810cde5.css"><script charset="utf-8" src="2.2397e918c534f0d6fc83.bundle.js"></script></head>
<body>
	<div id="app"><div><header><h3 class="header-title">MinimalistYing.io</h3><nav><ul><li><a href="/index.html">博客</a></li><li><a href="/memo.html">备忘</a></li><li><a href="https://codepen.io/MinimalistYing" target="_blank">代码库</a></li><li><a href="https://leetcode.com/MinimalistYing" target="_blank">Leetcode</a></li><li><a href="https://stackoverflow.com/users/8459774/minimalistying" target="_blank">StackOverflow</a></li><li><a href="https://github.com/MinimalistYing" target="_blank">Github</a></li></ul></nav></header><div class="blogs"><div class="blog"><div class="my-md"><h1 id="-webpack-">记录配置 Webpack 过程中碰到的问题以及解决方案</h1>
<p>Ps: 基于 Webpack V4</p>
<h2 id="vue">Vue</h2>
<h3 id="-vueloaderplugin">未配置 VueLoaderPlugin</h3>
<p>错误信息</p>
<pre><code>ERROR <span class="hljs-keyword">in</span> ./src/component/App.vue
Module <span class="hljs-built_in">Error</span> (<span class="hljs-keyword">from</span> ./node_modules/vue-loader/lib/index.js):
vue-loader was used without the corresponding plugin.
Make sure to include VueLoaderPlugin <span class="hljs-keyword">in</span> your webpack config.</code></pre><p><a href="https://vue-loader.vuejs.org/guide/#manual-configuration">参考文档</a><br>解决方案</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-keyword">const</span> VueLoaderPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vue-loader/lib/plugin'</span>)

<span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">// ...</span>
    plugins: [
        <span class="hljs-keyword">new</span> VueLoaderPlugin() <span class="hljs-comment">// 新增VueLoaderPlugin</span>
    ]
    <span class="hljs-comment">// ...</span>
}</code></pre>
<h3 id="-vue-template-compiler">未安装 vue-template-compiler</h3>
<p>错误信息</p>
<pre><code>ERROR <span class="hljs-keyword">in</span> ./src/component/App.vue
Module build failed (<span class="hljs-keyword">from</span> ./node_modules/vue-loader/lib/index.js):
<span class="hljs-built_in">Error</span>: [vue-loader] vue-template-compiler must be installed <span class="hljs-keyword">as</span> a peer dependency, 
or a compatible compiler implementation must be passed via options.</code></pre><p><a href="https://github.com/vuejs/vue/tree/dev/packages/vue-template-compiler#vue-template-compiler">参考文档</a><br>由于<code>vue-loader</code>内部实现需要依赖<code>vue-template-compiler</code><br>但我们通过 npm 安装<code>vue-loader</code>时并未同时安装<code>vue-template-complier</code><br>所以需要显示的在本地项目安装一下
解决方案</p>
<pre><code>npm i vue-template-complier --save-dev</code></pre><h3 id="-css-loader">未安装配置css-loader</h3>
<p>错误信息</p>
<pre><code>ERROR <span class="hljs-keyword">in</span> ./src/component/App.vue?vue&amp;type=style&amp;index=<span class="hljs-number">0</span>&amp;lang=css&amp; 
(./node_modules/vue-loader/lib??vue-loader-options!./src/component/App.vue?vue&amp;type=style&amp;index=<span class="hljs-number">0</span>&amp;lang=css&amp;) <span class="hljs-number">24</span>:<span class="hljs-number">0</span>
Module parse failed: Unexpected token (<span class="hljs-number">24</span>:<span class="hljs-number">0</span>)
You may need an appropriate loader to handle <span class="hljs-keyword">this</span> file type.
|
|
&gt; .app {
|       font-size: <span class="hljs-number">24</span>px;
|       margin-top: <span class="hljs-number">50</span>%;</code></pre><p>由于默认的<code>.vue</code>文件中<code>&lt;style&gt;</code>的lang属性值为<code>css</code><br>所以<code>vue-loader</code>默认会将<code>&lt;style&gt;</code>块中的样式文件抽出作为 Css 文件提供给<code>webpack</code>加载<br>而不配置<code>css-loader</code>的话<code>webpack</code>是无法正确加载 Css 文件的
解决方案</p>
<pre><code>npm i css-loader --save-dev</code></pre><pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-built_in">module</span>: {
        <span class="hljs-attr">rules</span>: [{
            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.css$/</span>,
            <span class="hljs-attr">use</span>: <span class="hljs-string">'css-loader'</span>
        }]
    }
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>凭以上配置虽然页面能正常访问，但会发现样式并不会生效</p>
<pre><code>npm i style-loader --save-dev</code></pre><pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-built_in">module</span>: {
        <span class="hljs-attr">rules</span>: [{
            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.css$/</span>,
            <span class="hljs-attr">use</span>: [
                <span class="hljs-string">'style-loader'</span>,
                <span class="hljs-string">'css-loader'</span>
            ]
        }]
    }
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p><a href="https://webpack.js.org/loaders/style-loader/">Style Loader</a><br><a href="https://webpack.js.org/loaders/css-loader/">Css Loader</a><br>Css Loader 的作用是使我们可以在 Js 文件中通过 <code>import style from 'xxx.css'</code> 来告诉 webpack 这个文件对样式的依赖<br>这样当打包这个 Css 文件时也会将 xxx.css 算入其中<br>当这样并不能使样式文件被浏览器正确加载<br>Style Loader 正是启到将依赖的样式文件通过在页面上插入 <code>&lt;style&gt;</code> 标签的形式注入到页面中<br>所以简单来讲 不做其他特殊配置的话 一定要同时使用这俩个 Loader 才能使得样式正确加载</p>
<h3 id="-vue-">未正确配置项目所使用的 Vue 文件</h3>
<p>错误信息</p>
<pre><code><span class="hljs-comment">// 页面报错</span>
[Vue warn]: You are using the runtime-only build <span class="hljs-keyword">of</span> Vue where the template compiler is not available. 
Either pre-compile the templates into render functions, or use the compiler-included build.</code></pre><p>页面并未正常渲染，而是在 <code>HTML</code> 中出现了如下片段</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!--function (a, b, c, d) { return createElement(vm, a, b, c, d, true); }--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p><a href="https://vuejs.org/v2/guide/installation.html#Explanation-of-Different-Builds">参考文档</a><br>这个问题出现主要是由于 Vue 对外提供了俩个版本的最终构造文件 Full(Runtime + Compiler) 以及 Runtime-only<br>俩者的区别就在于一个有 Compiler 另一个没有<br>此外，在 Vue 的 package.json 中可以看到 <code>"module": "dist/vue.runtime.esm.js"</code><br>也就是说在使用 webpack 打包时 <code>import Vue from 'vue'</code> 默认使用的是 vue.runtime.esm.js 也就是 Rutime-only 的版本<br>Compiler 的主要作用在于将文件中的模版字符串转化为 render 函数（注意这里的文件不包括 .vue 文件 因为他们会被 vue-loader 自动预编译）<br>举例，在如下 Vue 应用的主入口文件中  </p>
<pre><code class="language-js"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-comment">// 这种形式需要引用 Full(Runtime + Compiler)</span>
<span class="hljs-keyword">new</span> Vue({
    <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,
    <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;&lt;/div&gt;'</span>
})

<span class="hljs-comment">// 引用 Runtime-only 即可</span>
<span class="hljs-keyword">new</span> Vue({
    <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,
    rendre(h) {
        <span class="hljs-keyword">return</span> h(<span class="hljs-string">'div'</span>)
    }
})</code></pre>
<p>所以以上问题的解决方案有俩种<br>其一是如果我们确定不会在除 .vue 文件外使用 Vue 的 template<br>那么直接照常引入默认的 Runtime-only 版本即可<br>否则则需要我们显示的引入 Full(Runtime + Compiler) 版本  </p>
<pre><code class="language-js"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue/dist/vue.esm.js'</span></code></pre>
<p>可以利用 webpack 的别名功能简化这个操作，也是官方推荐的方式</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">// ...</span>
    resolve: {
        <span class="hljs-attr">alias</span>: {
            <span class="hljs-string">'vue$'</span>: <span class="hljs-string">'vue/dist/vue.esm.js'</span> <span class="hljs-comment">// 'vue/dist/vue.common.js' for webpack 1</span>
            <span class="hljs-comment">// Ps: 最后的 $ 意味着完全匹配 也就是说只有在 import xx from 'vue' 时这条规则才会生效</span>
            <span class="hljs-comment">// import xx from 'vue/xx.js' 并不会触发以上规则</span>
        }
    }
    <span class="hljs-comment">// ...</span>
}</code></pre>
<p>之后只要照常引用 <code>import Vue from 'vue'</code> 则会正确引入 Full(Runtime + Compiler) 版本</p>
<h3 id="es6-babel-">ES6 代码未正确经过Babel编译</h3>
<p><a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx">参考文档</a><br>Ps: 基于 Babel V7<br>解决方案</p>
<pre><code>npm install
  babel-plugin-syntax-jsx
  babel-plugin-transform-vue-jsx
  babel-helper-vue-jsx-merge-props
  babel-preset-env
  --save-dev</code></pre><pre><code class="language-js"><span class="hljs-comment">// babel.config.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">api</span>) </span>{
    api.cache(<span class="hljs-literal">true</span>)
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">presets</span>: [<span class="hljs-string">'env'</span>],
        <span class="hljs-attr">plugins</span>: [<span class="hljs-string">'transform-vue-jsx'</span>]
    }
}

<span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-built_in">module</span>: {
        <span class="hljs-attr">rules</span>: [{
            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.js$/</span>,
            <span class="hljs-attr">use</span>: <span class="hljs-string">'babel-loader'</span>
        }]
    }
    <span class="hljs-comment">// ...</span>
}</code></pre>
<h3 id="hmr-">HMR未启用</h3>
<p>错误信息</p>
<pre><code><span class="hljs-comment">// 如果在 devServer 中开启了 hot 确并未配置 HotModuleReplacementPlugin </span>
<span class="hljs-comment">// 浏览器控制台会出现如下报错</span>
Uncaught <span class="hljs-built_in">Error</span>: [HMR] Hot Module Replacement is disabled.
    at <span class="hljs-built_in">eval</span> (webpack:<span class="hljs-comment">///(:9000/webpack)/hot/dev-server.js?:7:8)</span>
    at <span class="hljs-built_in">Object</span>../node_modules/webpack/hot/dev-server.js (main.js:<span class="hljs-number">485</span>)
    at __webpack_require__ (main.js:<span class="hljs-number">20</span>)
    at <span class="hljs-built_in">eval</span> (webpack:<span class="hljs-comment">///multi_(:9000/webpack)-dev-server/client?:2:1)</span>
    at <span class="hljs-built_in">Object</span><span class="hljs-number">.0</span> (main.js:<span class="hljs-number">578</span>)
    at __webpack_require__ (main.js:<span class="hljs-number">20</span>)
    at main.js:<span class="hljs-number">84</span>
    at main.js:<span class="hljs-number">87</span></code></pre><p><a href="https://webpack.js.org/guides/hot-module-replacement/">参考文档</a><br>解决方案</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.dev.config.js</span>
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)

<span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">// ...</span>
    devServer: {
        <span class="hljs-comment">// ...</span>
        hot: <span class="hljs-literal">true</span>
    },
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin()
    ]
    <span class="hljs-comment">// ...</span>
}</code></pre>
<h3 id="css-url-xxx-">CSS 中通过 <code>url(xxx)</code> 引入的的图片路径不正确</h3>
<p>当我们通过配置使得输出的静态文件放到不同目录下时很容易碰到这个问题<br>例如我们将打包后的文件分别放到js/css/images三个目录下<br>这时如果没有特意配置过的话被 <code>url-loader</code> 处理过后的图片引用路径通常会变为 <code>images/xxx.png</code><br>如果是在根目录下的 HTML 中的文件下这样访问图片不会有问题<br>但如果是在 CSS 中的  <code>url(images/xxx.png)</code> 则会出现找不到图片的问题<br>因为这种形式的 URL 是一种相对路径<br>而 CSS 文件时放在 css 目录下的，而这个路径下并没有 images 文件夹<br>所以当然找不到正确的图片<br>这时可通过配置 <code>url-loader</code> 的 <code>publicPath</code> 为相对服务器根目录的相对路径来解决<br>关于 <code>publicPath</code> 有如下这些<a href="https://webpack.js.org/configuration/output/#output-publicpath">配置方式</a>  </p>
<pre><code class="language-js"><span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">//...</span>
    output: {
        <span class="hljs-comment">// One of the below</span>
        publicPath: <span class="hljs-string">'https://cdn.example.com/assets/'</span>, <span class="hljs-comment">// CDN (always HTTPS)</span>
        publicPath: <span class="hljs-string">'//cdn.example.com/assets/'</span>, <span class="hljs-comment">// CDN (same protocol)</span>
        publicPath: <span class="hljs-string">'/assets/'</span>, <span class="hljs-comment">// server-relative</span>
        publicPath: <span class="hljs-string">'assets/'</span>, <span class="hljs-comment">// relative to HTML page</span>
        publicPath: <span class="hljs-string">'../assets/'</span>, <span class="hljs-comment">// relative to HTML page</span>
        publicPath: <span class="hljs-string">''</span>, <span class="hljs-comment">// relative to HTML page (same directory)</span>
    }
}</code></pre>
<h2 id="react">React</h2>
<h2 id="-">优化</h2>
<h3 id="-optimization-moduleids">关于 <code>optimization.moduleIds</code></h3>
<p>Webpack V4 新引入的这条配置其功能相当于之前的 <code>xxxModuleIdsPlugin</code><br>一共有 <code>natural/named/hashed/size/total-size</code> 这五个可选值<br>默认为 <code>false</code> 即以一个自增的数字作为 moduleId<br>首先要理解在 Webpack 中 module 的含义就是我们在代码里每一处 <code>import xx from 'xx'</code> 中的 xx 模块<br>moduleId 即是 Webpack 在打包过程中赋予每一个模块的唯一 Id<br>个人认为在开发环境下将其设为 <code>named</code> 也就是每个模块的文件路径作为 Id 可以方便 Debug<br>在生产环境下将其设为 <code>hashed</code> 避免每次改动都导致所有模块的 Id 发生变化</p>
<h3 id="-tree-shaking">启用 Tree Shaking</h3>
<p>Webpack 提供了 Tree Shaking 的功能<br>帮助我们在打包的过程把无用的代码块移除，进一步减小包的体积<br>在V4中要正确启用这个功能需要确保下列这几点</p>
<ul>
<li>使用 ES6 的 <code>import</code> 以及 <code>export</code> 来管理 Module</li>
<li><code>mode</code> 设为 <code>production</code></li>
<li>在 <code>package.json</code> 中加入 <code>"sideEffects": false</code> 或者 <code>"sideEffects": ["*.css"]</code> 避免不小心移除样式文件</li>
<li>如果有使用 <code>@babel/preset-env</code> 注意在 .babelrc 中将其默认的配置 <code>"modules": "commonjs"</code> 
改为 <code>"modules": false</code> 也就是说不让 Babel 转义源码中的 ES6 Module 语法</li>
</ul>
</div></div><div id="category" class="category-box"><ul class="blogs-category"><li class="">记一次 Chrome 更新导致插件故障引发的问题</li><li class="">关于前端框架选型的一些思考</li><li class="">观后感：《低欲望社会》大前研一</li><li class="">浅谈 CSS（Cascading Style Sheets) 之层叠</li><li class="">Axios 源码解析</li><li class="">React 与 Vue 的一些对比</li><li class="">为什么 CORS 需要在跨域请求前进行预校验 (Preflight)</li><li class="">Array.prototype.sort() 在使用默认 CompareFn 时的问题</li><li class="">常见的二叉树类型</li><li class="">Ajax (Asynchronous JavaScript And XML)</li><li class="">关于 XSS 以及 CSRF</li><li class="">Cookie 和 WebStorage</li><li class="">关于跨域</li><li class="selected">记录配置 Webpack 过程中碰到的问题以及解决方案</li><li class="">关于 Source Map 以及 Webpack 中 Devtool 的相关配置</li><li class="">二叉树的遍历</li><li class="">React-Redux 从入门到后悔</li><li class="">Redux 从入门到放弃</li><li class="">如何阻止模态框 (Modal / Popup / Dialog) 弹出后 Body 可滚动</li><li class="">Promise In ES6</li><li class="">New Collections In ES6</li><li class=""> Object's New API In ES6</li><li class="">Array's New API In ES6</li><li class="">Generator in ES6</li><li class="">Webpack V3 升级至 V4</li><li class="">Iterator in ES6</li><li class="">Symbols in ES6</li><li class="">如何编写一个自己的GulpPlugin</li><li class="">Webpack(v3.8.1)</li></ul></div><div class="category-toggle"></div></div></div></div>
<script type="text/javascript" src="main.ad613e76dfba0372d7c6.js"></script>
</body></html>